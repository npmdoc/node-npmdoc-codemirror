<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://codemirror.net">codemirror (v5.25.2)</a>
</h1>
<h4>Full-featured in-browser code editor</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.codemirror">module codemirror</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.MergeView">
            function <span class="apidocSignatureSpan">codemirror.</span>MergeView
            <span class="apidocSignatureSpan">(node, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream">
            function <span class="apidocSignatureSpan">codemirror.</span>StringStream
            <span class="apidocSignatureSpan">(string, tabSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.TernServer">
            function <span class="apidocSignatureSpan">codemirror.</span>TernServer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.autoLoadMode">
            function <span class="apidocSignatureSpan">codemirror.</span>autoLoadMode
            <span class="apidocSignatureSpan">(instance, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.colorize">
            function <span class="apidocSignatureSpan">codemirror.</span>colorize
            <span class="apidocSignatureSpan">(collection, defaultMode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.defineMIME">
            function <span class="apidocSignatureSpan">codemirror.</span>defineMIME
            <span class="apidocSignatureSpan">(mime, spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.defineMode">
            function <span class="apidocSignatureSpan">codemirror.</span>defineMode
            <span class="apidocSignatureSpan">(name, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.defineSimpleMode">
            function <span class="apidocSignatureSpan">codemirror.</span>defineSimpleMode
            <span class="apidocSignatureSpan">(name, states)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.extendMode">
            function <span class="apidocSignatureSpan">codemirror.</span>extendMode
            <span class="apidocSignatureSpan">(mode, properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.findEnclosingTag">
            function <span class="apidocSignatureSpan">codemirror.</span>findEnclosingTag
            <span class="apidocSignatureSpan">(cm, pos, range, tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.findMatchingTag">
            function <span class="apidocSignatureSpan">codemirror.</span>findMatchingTag
            <span class="apidocSignatureSpan">(cm, pos, range)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.findModeByExtension">
            function <span class="apidocSignatureSpan">codemirror.</span>findModeByExtension
            <span class="apidocSignatureSpan">(ext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.findModeByFileName">
            function <span class="apidocSignatureSpan">codemirror.</span>findModeByFileName
            <span class="apidocSignatureSpan">(filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.findModeByMIME">
            function <span class="apidocSignatureSpan">codemirror.</span>findModeByMIME
            <span class="apidocSignatureSpan">(mime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.findModeByName">
            function <span class="apidocSignatureSpan">codemirror.</span>findModeByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.getMode">
            function <span class="apidocSignatureSpan">codemirror.</span>getMode
            <span class="apidocSignatureSpan">(options, spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.multiplexingMode">
            function <span class="apidocSignatureSpan">codemirror.</span>multiplexingMode
            <span class="apidocSignatureSpan">(outer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.newFoldFunction">
            function <span class="apidocSignatureSpan">codemirror.</span>newFoldFunction
            <span class="apidocSignatureSpan">(rangeFinder, widget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.overlayMode">
            function <span class="apidocSignatureSpan">codemirror.</span>overlayMode
            <span class="apidocSignatureSpan">(base, overlay, combine)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.registerGlobalHelper">
            function <span class="apidocSignatureSpan">codemirror.</span>registerGlobalHelper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.registerHelper">
            function <span class="apidocSignatureSpan">codemirror.</span>registerHelper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.requireMode">
            function <span class="apidocSignatureSpan">codemirror.</span>requireMode
            <span class="apidocSignatureSpan">(mode, cont)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.resolveMode">
            function <span class="apidocSignatureSpan">codemirror.</span>resolveMode
            <span class="apidocSignatureSpan">(spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runMode">
            function <span class="apidocSignatureSpan">codemirror.</span>runMode
            <span class="apidocSignatureSpan">(string, modespec, callback, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.scanForClosingTag">
            function <span class="apidocSignatureSpan">codemirror.</span>scanForClosingTag
            <span class="apidocSignatureSpan">(cm, pos, name, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.showHint">
            function <span class="apidocSignatureSpan">codemirror.</span>showHint
            <span class="apidocSignatureSpan">(cm, getHints, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.simpleMode">
            function <span class="apidocSignatureSpan">codemirror.</span>simpleMode
            <span class="apidocSignatureSpan">(config, states)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.startState">
            function <span class="apidocSignatureSpan">codemirror.</span>startState
            <span class="apidocSignatureSpan">(mode, a1, a2)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.</span>MergeView.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.</span>StringStream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.</span>TernServer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.</span>emacs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.</span>htmlSchema</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.</span>mimeModes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.</span>modeExtensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.</span>modeInfo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.</span>modes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.</span>runmode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.</span>worker</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">codemirror.</span>modeURL</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.codemirror.MergeView">module codemirror.MergeView</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.MergeView.MergeView">
            function <span class="apidocSignatureSpan">codemirror.</span>MergeView
            <span class="apidocSignatureSpan">(node, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.codemirror.MergeView.prototype">module codemirror.MergeView.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.MergeView.prototype.constructor">
            function <span class="apidocSignatureSpan">codemirror.MergeView.prototype.</span>constructor
            <span class="apidocSignatureSpan">(node, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.MergeView.prototype.editor">
            function <span class="apidocSignatureSpan">codemirror.MergeView.prototype.</span>editor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.MergeView.prototype.leftChunks">
            function <span class="apidocSignatureSpan">codemirror.MergeView.prototype.</span>leftChunks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.MergeView.prototype.leftOriginal">
            function <span class="apidocSignatureSpan">codemirror.MergeView.prototype.</span>leftOriginal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.MergeView.prototype.rightChunks">
            function <span class="apidocSignatureSpan">codemirror.MergeView.prototype.</span>rightChunks
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.MergeView.prototype.rightOriginal">
            function <span class="apidocSignatureSpan">codemirror.MergeView.prototype.</span>rightOriginal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.MergeView.prototype.setShowDifferences">
            function <span class="apidocSignatureSpan">codemirror.MergeView.prototype.</span>setShowDifferences
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.codemirror.StringStream">module codemirror.StringStream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.StringStream">
            function <span class="apidocSignatureSpan">codemirror.</span>StringStream
            <span class="apidocSignatureSpan">(string, tabSize)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.codemirror.StringStream.prototype">module codemirror.StringStream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.prototype.backUp">
            function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>backUp
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.prototype.column">
            function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>column
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.prototype.current">
            function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>current
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.prototype.eat">
            function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>eat
            <span class="apidocSignatureSpan">(match)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.prototype.eatSpace">
            function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>eatSpace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.prototype.eatWhile">
            function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>eatWhile
            <span class="apidocSignatureSpan">(match)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.prototype.eol">
            function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>eol
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.prototype.hideFirstChars">
            function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>hideFirstChars
            <span class="apidocSignatureSpan">(n, inner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.prototype.indentation">
            function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>indentation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.prototype.match">
            function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>match
            <span class="apidocSignatureSpan">(pattern, consume, caseInsensitive)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.prototype.next">
            function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.prototype.peek">
            function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>peek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.prototype.skipTo">
            function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>skipTo
            <span class="apidocSignatureSpan">(ch)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.prototype.skipToEnd">
            function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>skipToEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.StringStream.prototype.sol">
            function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>sol
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.codemirror.TernServer">module codemirror.TernServer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.TernServer.TernServer">
            function <span class="apidocSignatureSpan">codemirror.</span>TernServer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.codemirror.TernServer.prototype">module codemirror.TernServer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.TernServer.prototype.addDoc">
            function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>addDoc
            <span class="apidocSignatureSpan">(name, doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.TernServer.prototype.complete">
            function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>complete
            <span class="apidocSignatureSpan">(cm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.TernServer.prototype.delDoc">
            function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>delDoc
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.TernServer.prototype.destroy">
            function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>destroy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.TernServer.prototype.hideDoc">
            function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>hideDoc
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.TernServer.prototype.jumpBack">
            function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>jumpBack
            <span class="apidocSignatureSpan">(cm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.TernServer.prototype.jumpToDef">
            function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>jumpToDef
            <span class="apidocSignatureSpan">(cm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.TernServer.prototype.rename">
            function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>rename
            <span class="apidocSignatureSpan">(cm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.TernServer.prototype.request">
            function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>request
            <span class="apidocSignatureSpan">(cm, query, c, pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.TernServer.prototype.selectName">
            function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>selectName
            <span class="apidocSignatureSpan">(cm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.TernServer.prototype.showDocs">
            function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>showDocs
            <span class="apidocSignatureSpan">(cm, pos, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.TernServer.prototype.showType">
            function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>showType
            <span class="apidocSignatureSpan">(cm, pos, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.TernServer.prototype.updateArgHints">
            function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>updateArgHints
            <span class="apidocSignatureSpan">(cm)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.codemirror.emacs">module codemirror.emacs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.emacs.kill">
            function <span class="apidocSignatureSpan">codemirror.emacs.</span>kill
            <span class="apidocSignatureSpan">(cm, from, to, mayGrow, text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.emacs.killRegion">
            function <span class="apidocSignatureSpan">codemirror.emacs.</span>killRegion
            <span class="apidocSignatureSpan">(cm)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.emacs.repeated">
            function <span class="apidocSignatureSpan">codemirror.emacs.</span>repeated
            <span class="apidocSignatureSpan">(cmd)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.codemirror.modes">module codemirror.modes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.apl">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>apl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.asciiarmor">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>asciiarmor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.asn.1">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>asn.1
            <span class="apidocSignatureSpan">(config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.asterisk">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>asterisk
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.brainfuck">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>brainfuck
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.clike">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>clike
            <span class="apidocSignatureSpan">(config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.clojure">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>clojure
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.cmake">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>cmake
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.cobol">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>cobol
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.coffeescript">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>coffeescript
            <span class="apidocSignatureSpan">(conf, parserConf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.commonlisp">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>commonlisp
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.crystal">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>crystal
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.css">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>css
            <span class="apidocSignatureSpan">(config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.cypher">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>cypher
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.d">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>d
            <span class="apidocSignatureSpan">(config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.dart">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>dart
            <span class="apidocSignatureSpan">(conf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.diff">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>diff
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.django">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>django
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.dockerfile">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>dockerfile
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.dtd">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>dtd
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.dylan">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>dylan
            <span class="apidocSignatureSpan">(_config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.ebnf">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>ebnf
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.ecl">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>ecl
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.eiffel">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>eiffel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.elm">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>elm
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.erlang">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>erlang
            <span class="apidocSignatureSpan">(cmCfg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.factor">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>factor
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.fcl">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>fcl
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.forth">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>forth
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.fortran">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>fortran
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.gas">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>gas
            <span class="apidocSignatureSpan">(_config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.gfm">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>gfm
            <span class="apidocSignatureSpan">(config, modeConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.gherkin">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>gherkin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.go">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>go
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.groovy">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>groovy
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.haml">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>haml
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.handlebars">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>handlebars
            <span class="apidocSignatureSpan">(config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.handlebars-tags">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>handlebars-tags
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.haskell">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>haskell
            <span class="apidocSignatureSpan">(_config, modeConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.haskell-literate">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>haskell-literate
            <span class="apidocSignatureSpan">(config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.haxe">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>haxe
            <span class="apidocSignatureSpan">(config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.htmlembedded">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>htmlembedded
            <span class="apidocSignatureSpan">(config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.htmlmixed">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>htmlmixed
            <span class="apidocSignatureSpan">(config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.http">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>http
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.hxml">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>hxml
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.idl">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>idl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.javascript">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>javascript
            <span class="apidocSignatureSpan">(config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.jinja2">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>jinja2
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.jsx">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>jsx
            <span class="apidocSignatureSpan">(config, modeConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.julia">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>julia
            <span class="apidocSignatureSpan">(config, parserConf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.livescript">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>livescript
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.lua">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>lua
            <span class="apidocSignatureSpan">(config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.markdown">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>markdown
            <span class="apidocSignatureSpan">(cmCfg, modeCfg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.mathematica">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>mathematica
            <span class="apidocSignatureSpan">(_config, _parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.mbox">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>mbox
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.mirc">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>mirc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.mllike">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>mllike
            <span class="apidocSignatureSpan">(_config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.modelica">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>modelica
            <span class="apidocSignatureSpan">(config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.mscgen">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>mscgen
            <span class="apidocSignatureSpan">(_, modeConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.mumps">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>mumps
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.nginx">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>nginx
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.nsis">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>nsis
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.ntriples">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>ntriples
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.null">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>null
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.octave">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>octave
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.oz">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>oz
            <span class="apidocSignatureSpan">(conf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.pascal">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>pascal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.pegjs">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>pegjs
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.perl">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>perl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.php">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>php
            <span class="apidocSignatureSpan">(config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.pig">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>pig
            <span class="apidocSignatureSpan">(_config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.powershell">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>powershell
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.properties">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>properties
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.protobuf">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>protobuf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.pug">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>pug
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.puppet">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>puppet
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.python">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>python
            <span class="apidocSignatureSpan">(conf, parserConf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.q">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>q
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.r">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>r
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.rpm-changes">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>rpm-changes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.rpm-spec">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>rpm-spec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.rst">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>rst
            <span class="apidocSignatureSpan">(config, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.rst-base">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>rst-base
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.ruby">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>ruby
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.rust">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>rust
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.sas">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>sas
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.sass">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>sass
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.scheme">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>scheme
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.shell">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>shell
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.sieve">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>sieve
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.slim">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>slim
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.smalltalk">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>smalltalk
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.smarty">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>smarty
            <span class="apidocSignatureSpan">(config, parserConf)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.solr">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>solr
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.soy">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>soy
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.sparql">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>sparql
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.spreadsheet">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>spreadsheet
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.sql">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>sql
            <span class="apidocSignatureSpan">(config, parserConfig)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.stex">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>stex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.stylus">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>stylus
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.swift">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>swift
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.tcl">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>tcl
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.textile">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>textile
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.modes.xml">
            function <span class="apidocSignatureSpan">codemirror.modes.</span>xml
            <span class="apidocSignatureSpan">(editorConf, config_)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.codemirror.runmode">module codemirror.runmode</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.MergeView">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>MergeView
            <span class="apidocSignatureSpan">(node, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.StringStream">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>StringStream
            <span class="apidocSignatureSpan">(string, tabSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.TernServer">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>TernServer
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.autoLoadMode">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>autoLoadMode
            <span class="apidocSignatureSpan">(instance, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.colorize">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>colorize
            <span class="apidocSignatureSpan">(collection, defaultMode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.defineMIME">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>defineMIME
            <span class="apidocSignatureSpan">(mime, spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.defineMode">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>defineMode
            <span class="apidocSignatureSpan">(name, mode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.defineSimpleMode">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>defineSimpleMode
            <span class="apidocSignatureSpan">(name, states)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.extendMode">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>extendMode
            <span class="apidocSignatureSpan">(mode, properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.findEnclosingTag">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>findEnclosingTag
            <span class="apidocSignatureSpan">(cm, pos, range, tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.findMatchingTag">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>findMatchingTag
            <span class="apidocSignatureSpan">(cm, pos, range)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.findModeByExtension">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>findModeByExtension
            <span class="apidocSignatureSpan">(ext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.findModeByFileName">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>findModeByFileName
            <span class="apidocSignatureSpan">(filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.findModeByMIME">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>findModeByMIME
            <span class="apidocSignatureSpan">(mime)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.findModeByName">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>findModeByName
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.getMode">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>getMode
            <span class="apidocSignatureSpan">(options, spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.multiplexingMode">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>multiplexingMode
            <span class="apidocSignatureSpan">(outer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.newFoldFunction">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>newFoldFunction
            <span class="apidocSignatureSpan">(rangeFinder, widget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.overlayMode">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>overlayMode
            <span class="apidocSignatureSpan">(base, overlay, combine)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.registerGlobalHelper">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>registerGlobalHelper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.registerHelper">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>registerHelper
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.requireMode">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>requireMode
            <span class="apidocSignatureSpan">(mode, cont)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.resolveMode">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>resolveMode
            <span class="apidocSignatureSpan">(spec)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.runMode">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>runMode
            <span class="apidocSignatureSpan">(string, modespec, callback, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.scanForClosingTag">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>scanForClosingTag
            <span class="apidocSignatureSpan">(cm, pos, name, end)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.showHint">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>showHint
            <span class="apidocSignatureSpan">(cm, getHints, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.simpleMode">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>simpleMode
            <span class="apidocSignatureSpan">(config, states)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.runmode.startState">
            function <span class="apidocSignatureSpan">codemirror.runmode.</span>startState
            <span class="apidocSignatureSpan">(mode, a1, a2)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.runmode.</span>emacs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.runmode.</span>htmlSchema</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.runmode.</span>mimeModes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.runmode.</span>modeExtensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.runmode.</span>modeInfo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.runmode.</span>modes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">codemirror.runmode.</span>modeURL</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.codemirror.worker">module codemirror.worker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.codemirror.worker.onmessage">
            function <span class="apidocSignatureSpan">codemirror.worker.</span>onmessage
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">codemirror.worker.</span>console</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.codemirror" id="apidoc.module.codemirror">module codemirror</a></h1>


    <h2>
        <a href="#apidoc.element.codemirror.MergeView" id="apidoc.element.codemirror.MergeView">
        function <span class="apidocSignatureSpan">codemirror.</span>MergeView
        <span class="apidocSignatureSpan">(node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MergeView = function (node, options) {
  if (!(this instanceof MergeView)) return new MergeView(node, options);

  this.options = options;
  var origLeft = options.origLeft, origRight = options.origRight == null ? options.orig : options.origRight;

  var hasLeft = origLeft != null, hasRight = origRight != null;
  var panes = 1 + (hasLeft ? 1 : 0) + (hasRight ? 1 : 0);
  var wrap = [], left = this.left = null, right = this.right = null;
  var self = this;

  if (hasLeft) {
    left = this.left = new DiffView(this, "left");
    var leftPane = elt("div", null, "CodeMirror-merge-pane CodeMirror-merge-left");
    wrap.push(leftPane);
    wrap.push(buildGap(left));
  }

  var editPane = elt("div", null, "CodeMirror-merge-pane CodeMirror-merge-editor");
  wrap.push(editPane);

  if (hasRight) {
    right = this.right = new DiffView(this, "right");
    wrap.push(buildGap(right));
    var rightPane = elt("div", null, "CodeMirror-merge-pane CodeMirror-merge-right");
    wrap.push(rightPane);
  }

  (hasRight ? rightPane : editPane).className += " CodeMirror-merge-pane-rightmost";

  wrap.push(elt("div", null, null, "height: 0; clear: both;"));

  var wrapElt = this.wrap = node.appendChild(elt("div", wrap, "CodeMirror-merge CodeMirror-merge-" + panes + "pane"));
  this.edit = CodeMirror(editPane, copyObj(options));

  if (left) left.init(leftPane, origLeft, options);
  if (right) right.init(rightPane, origRight, options);
  if (options.collapseIdentical)
    this.editor().operation(function() {
      collapseIdenticalStretches(self, options.collapseIdentical);
    });
  if (options.connect == "align") {
    this.aligners = [];
    alignChunks(this.left || this.right, true);
  }
  if (left) left.registerEvents(right)
  if (right) right.registerEvents(left)


  var onResize = function() {
    if (left) makeConnections(left);
    if (right) makeConnections(right);
  };
  CodeMirror.on(window, "resize", onResize);
  var resizeInterval = setInterval(function() {
    for (var p = wrapElt.parentNode; p &amp;&amp; p != document.body; p = p.parentNode) {}
    if (!p) { clearInterval(resizeInterval); CodeMirror.off(window, "resize", onResize); }
  }, 5000);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.StringStream" id="apidoc.element.codemirror.StringStream">
        function <span class="apidocSignatureSpan">codemirror.</span>StringStream
        <span class="apidocSignatureSpan">(string, tabSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StringStream(string, tabSize) {
  this.pos = this.start = 0;
  this.string = string;
  this.tabSize = tabSize || 8;
  this.lastColumnPos = this.lastColumnValue = 0;
  this.lineStart = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return out.join('');
}

// Unescape \ and / in the replace part, for PCRE mode.
var unescapes = {'\\/': '/', '\\\\': '\\', '\\n': '\n', '\\r'
;: '\r', '\\t': '\t'};
function unescapeRegexReplace(str) {
  var stream = new CodeMirror.<span class="apidocCodeKeywordSpan">StringStream</span>(str);
  var output = [];
  while (!stream.eol()) {
    // Search for \.
    while (stream.peek() &amp;&amp; stream.peek() != '\\') {
      output.push(stream.next());
    }
    var matched = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.TernServer" id="apidoc.element.codemirror.TernServer">
        function <span class="apidocSignatureSpan">codemirror.</span>TernServer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TernServer = function (options) {
  var self = this;
  this.options = options || {};
  var plugins = this.options.plugins || (this.options.plugins = {});
  if (!plugins.doc_comment) plugins.doc_comment = true;
  this.docs = Object.create(null);
  if (this.options.useWorker) {
    this.server = new WorkerServer(this);
  } else {
    this.server = new tern.Server({
      getFile: function(name, c) { return getFile(self, name, c); },
      async: true,
      defs: this.options.defs || [],
      plugins: plugins
    });
  }
  this.trackChange = function(doc, change) { trackChange(self, doc, change); };

  this.cachedArgHints = null;
  this.activeArgHints = null;
  this.jumpStack = [];

  this.getHint = function(cm, c) { return hint(self, cm, c); };
  this.getHint.async = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.autoLoadMode" id="apidoc.element.codemirror.autoLoadMode">
        function <span class="apidocSignatureSpan">codemirror.</span>autoLoadMode
        <span class="apidocSignatureSpan">(instance, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoLoadMode = function (instance, mode) {
  if (!CodeMirror.modes.hasOwnProperty(mode))
    CodeMirror.requireMode(mode, function() {
      instance.setOption("mode", instance.getOption("mode"));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.colorize" id="apidoc.element.codemirror.colorize">
        function <span class="apidocSignatureSpan">codemirror.</span>colorize
        <span class="apidocSignatureSpan">(collection, defaultMode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">colorize = function (collection, defaultMode) {
  if (!collection) collection = document.body.getElementsByTagName("pre");

  for (var i = 0; i &lt; collection.length; ++i) {
    var node = collection[i];
    var mode = node.getAttribute("data-lang") || defaultMode;
    if (!mode) continue;

    var text = [];
    textContent(node, text);
    node.innerHTML = "";
    CodeMirror.runMode(text.join(""), mode, node);

    node.className += " cm-s-default";
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.defineMIME" id="apidoc.element.codemirror.defineMIME">
        function <span class="apidocSignatureSpan">codemirror.</span>defineMIME
        <span class="apidocSignatureSpan">(mime, spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineMIME = function (mime, spec) { mimeModes[mime] = spec; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  defineMode.apply(this, arguments);
};

CodeMirror$1.defineMIME = defineMIME;

// Minimal default mode.
CodeMirror$1.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
CodeMirror$1.<span class="apidocCodeKeywordSpan">defineMIME</span>("text/plain", "null");

// EXTENSIONS

CodeMirror$1.defineExtension = function (name, func) {
  CodeMirror$1.prototype[name] = func;
};
CodeMirror$1.defineDocExtension = function (name, func) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.defineMode" id="apidoc.element.codemirror.defineMode">
        function <span class="apidocSignatureSpan">codemirror.</span>defineMode
        <span class="apidocSignatureSpan">(name, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineMode = function (name, mode) {
  if (arguments.length &gt; 2)
    mode.dependencies = Array.prototype.slice.call(arguments, 2);
  modes[name] = mode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!CodeMirror$1.defaults.mode &amp;&amp; name != "null") { CodeMirror$1.defaults.mode = name; }
  defineMode.apply(this, arguments);
};

CodeMirror$1.defineMIME = defineMIME;

// Minimal default mode.
CodeMirror$1.<span class="apidocCodeKeywordSpan">defineMode</span>("null", function () { return ({token: function (stream
) { return stream.skipToEnd(); }}); });
CodeMirror$1.defineMIME("text/plain", "null");

// EXTENSIONS

CodeMirror$1.defineExtension = function (name, func) {
  CodeMirror$1.prototype[name] = func;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.defineSimpleMode" id="apidoc.element.codemirror.defineSimpleMode">
        function <span class="apidocSignatureSpan">codemirror.</span>defineSimpleMode
        <span class="apidocSignatureSpan">(name, states)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineSimpleMode = function (name, states) {
  CodeMirror.defineMode(name, function(config) {
    return CodeMirror.simpleMode(config, states);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.extendMode" id="apidoc.element.codemirror.extendMode">
        function <span class="apidocSignatureSpan">codemirror.</span>extendMode
        <span class="apidocSignatureSpan">(mode, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendMode = function (mode, properties) {
  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
  copyObj(properties, exts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  define(["../../lib/codemirror"], mod);
else // Plain browser env
  mod(CodeMirror);
})(function(CodeMirror) {
var modes = ["clike", "css", "javascript"];

for (var i = 0; i &lt; modes.length; ++i)
  CodeMirror.<span class="apidocCodeKeywordSpan">extendMode</span>(modes[i], {blockCommentContinue: " * "});

function continueComment(cm) {
  if (cm.getOption("disableInput")) return CodeMirror.Pass;
  var ranges = cm.listSelections(), mode, inserts = [];
  for (var i = 0; i &lt; ranges.length; i++) {
    var pos = ranges[i].head, token = cm.getTokenAt(pos);
    if (token.type != "comment") return CodeMirror.Pass;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.findEnclosingTag" id="apidoc.element.codemirror.findEnclosingTag">
        function <span class="apidocSignatureSpan">codemirror.</span>findEnclosingTag
        <span class="apidocSignatureSpan">(cm, pos, range, tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findEnclosingTag = function (cm, pos, range, tag) {
  var iter = new Iter(cm, pos.line, pos.ch, range);
  for (;;) {
    var open = findMatchingOpen(iter, tag);
    if (!open) break;
    var forward = new Iter(cm, pos.line, pos.ch, range);
    var close = findMatchingClose(forward, open.tag);
    if (close) return {open: open, close: close};
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.findMatchingTag" id="apidoc.element.codemirror.findMatchingTag">
        function <span class="apidocSignatureSpan">codemirror.</span>findMatchingTag
        <span class="apidocSignatureSpan">(cm, pos, range)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findMatchingTag = function (cm, pos, range) {
  var iter = new Iter(cm, pos.line, pos.ch, range);
  if (iter.text.indexOf("&gt;") == -1 &amp;&amp; iter.text.indexOf("&lt;") == -1) return;
  var end = toTagEnd(iter), to = end &amp;&amp; Pos(iter.line, iter.ch);
  var start = end &amp;&amp; toTagStart(iter);
  if (!end || !start || cmp(iter, pos) &gt; 0) return;
  var here = {from: Pos(iter.line, iter.ch), to: to, tag: start[2]};
  if (end == "selfClose") return {open: here, close: null, at: "open"};

  if (start[1]) { // closing tag
    return {open: findMatchingOpen(iter, start[2]), close: here, at: "close"};
  } else { // opening tag
    iter = new Iter(cm, to.line, to.ch, range);
    return {open: here, close: findMatchingClose(iter, start[2]), at: "open"};
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function doMatchTags(cm) {
cm.state.failedTagMatch = false;
cm.operation(function() {
  clear(cm);
  if (cm.somethingSelected()) return;
  var cur = cm.getCursor(), range = cm.getViewport();
  range.from = Math.min(range.from, cur.line); range.to = Math.max(cur.line + 1, range.to);
  var match = CodeMirror.<span class="apidocCodeKeywordSpan">findMatchingTag</span>(cm, cur, range);
  if (!match) return;
  if (cm.state.matchBothTags) {
    var hit = match.at == "open" ? match.open : match.close;
    if (hit) cm.state.tagHit = cm.markText(hit.from, hit.to, {className: "CodeMirror-matchingtag"});
  }
  var other = match.at == "close" ? match.open : match.close;
  if (other)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.findModeByExtension" id="apidoc.element.codemirror.findModeByExtension">
        function <span class="apidocSignatureSpan">codemirror.</span>findModeByExtension
        <span class="apidocSignatureSpan">(ext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findModeByExtension = function (ext) {
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.ext) for (var j = 0; j &lt; info.ext.length; j++)
      if (info.ext[j] == ext) return info;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
CodeMirror.findModeByFileName = function(filename) {
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.file &amp;&amp; info.file.test(filename)) return info;
  }
  var dot = filename.lastIndexOf(".");
  var ext = dot &gt; -1 &amp;&amp; filename.substring(dot + 1, filename.length);
  if (ext) return CodeMirror.<span class="apidocCodeKeywordSpan">findModeByExtension</span>(ext);
};

CodeMirror.findModeByName = function(name) {
  name = name.toLowerCase();
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.name.toLowerCase() == name) return info;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.findModeByFileName" id="apidoc.element.codemirror.findModeByFileName">
        function <span class="apidocSignatureSpan">codemirror.</span>findModeByFileName
        <span class="apidocSignatureSpan">(filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findModeByFileName = function (filename) {
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.file &amp;&amp; info.file.test(filename)) return info;
  }
  var dot = filename.lastIndexOf(".");
  var ext = dot &gt; -1 &amp;&amp; filename.substring(dot + 1, filename.length);
  if (ext) return CodeMirror.findModeByExtension(ext);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.findModeByMIME" id="apidoc.element.codemirror.findModeByMIME">
        function <span class="apidocSignatureSpan">codemirror.</span>findModeByMIME
        <span class="apidocSignatureSpan">(mime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findModeByMIME = function (mime) {
  mime = mime.toLowerCase();
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.mime == mime) return info;
    if (info.mimes) for (var j = 0; j &lt; info.mimes.length; j++)
      if (info.mimes[j] == mime) return info;
  }
  if (/\+xml$/.test(mime)) return CodeMirror.findModeByMIME("application/xml")
  if (/\+json$/.test(mime)) return CodeMirror.findModeByMIME("application/json")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  mime = mime.toLowerCase();
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.mime == mime) return info;
    if (info.mimes) for (var j = 0; j &lt; info.mimes.length; j++)
      if (info.mimes[j] == mime) return info;
  }
  if (/\+xml$/.test(mime)) return CodeMirror.<span class="apidocCodeKeywordSpan">findModeByMIME</span>("application/xml"
;)
  if (/\+json$/.test(mime)) return CodeMirror.findModeByMIME("application/json")
};

CodeMirror.findModeByExtension = function(ext) {
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.ext) for (var j = 0; j &lt; info.ext.length; j++)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.findModeByName" id="apidoc.element.codemirror.findModeByName">
        function <span class="apidocSignatureSpan">codemirror.</span>findModeByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findModeByName = function (name) {
  name = name.toLowerCase();
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.name.toLowerCase() == name) return info;
    if (info.alias) for (var j = 0; j &lt; info.alias.length; j++)
      if (info.alias[j].toLowerCase() == name) return info;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.getMode" id="apidoc.element.codemirror.getMode">
        function <span class="apidocSignatureSpan">codemirror.</span>getMode
        <span class="apidocSignatureSpan">(options, spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMode = function (options, spec) {
  var spec = exports.resolveMode(spec);
  var mfactory = modes[spec.name];
  if (!mfactory) return exports.getMode(options, "text/plain");
  var modeObj = mfactory(options, spec);
  if (modeExtensions.hasOwnProperty(spec.name)) {
    var exts = modeExtensions[spec.name];
    for (var prop in exts) {
      if (!exts.hasOwnProperty(prop)) continue;
      if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
      modeObj[prop] = exts[prop];
    }
  }
  modeObj.name = spec.name;
  if (spec.helperType) modeObj.helperType = spec.helperType;
  if (spec.modeProps) for (var prop in spec.modeProps)
    modeObj[prop] = spec.modeProps[prop];

  return modeObj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    { if (maps[i] == map$$1 || maps[i].name == map$$1) {
      maps.splice(i, 1);
      return true
    } }
},

addOverlay: methodOp(function(spec, options) {
  var mode = spec.token ? spec : CodeMirror.<span class="apidocCodeKeywordSpan">getMode</span>(this.options, spec);
  if (mode.startState) { throw new Error("Overlays may not be stateful.") }
  insertSorted(this.state.overlays,
               {mode: mode, modeSpec: spec, opaque: options &amp;&amp; options.opaque,
                priority: (options &amp;&amp; options.priority) || 0},
               function (overlay) { return overlay.priority; });
  this.state.modeGen++;
  regChange(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.multiplexingMode" id="apidoc.element.codemirror.multiplexingMode">
        function <span class="apidocSignatureSpan">codemirror.</span>multiplexingMode
        <span class="apidocSignatureSpan">(outer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiplexingMode = function (outer) {
  // Others should be {open, close, mode [, delimStyle] [, innerStyle]} objects
  var others = Array.prototype.slice.call(arguments, 1);

  function indexOf(string, pattern, from, returnEnd) {
    if (typeof pattern == "string") {
      var found = string.indexOf(pattern, from);
      return returnEnd &amp;&amp; found &gt; -1 ? found + pattern.length : found;
    }
    var m = pattern.exec(from ? string.slice(from) : string);
    return m ? m.index + from + (returnEnd ? m[0].length : 0) : -1;
  }

  return {
    startState: function() {
      return {
        outer: CodeMirror.startState(outer),
        innerActive: null,
        inner: null
      };
    },

    copyState: function(state) {
      return {
        outer: CodeMirror.copyState(outer, state.outer),
        innerActive: state.innerActive,
        inner: state.innerActive &amp;&amp; CodeMirror.copyState(state.innerActive.mode, state.inner)
      };
    },

    token: function(stream, state) {
      if (!state.innerActive) {
        var cutOff = Infinity, oldContent = stream.string;
        for (var i = 0; i &lt; others.length; ++i) {
          var other = others[i];
          var found = indexOf(oldContent, other.open, stream.pos);
          if (found == stream.pos) {
            if (!other.parseDelimiters) stream.match(other.open);
            state.innerActive = other;
            state.inner = CodeMirror.startState(other.mode, outer.indent ? outer.indent(state.outer, "") : 0);
            return other.delimStyle &amp;&amp; (other.delimStyle + " " + other.delimStyle + "-open");
          } else if (found != -1 &amp;&amp; found &lt; cutOff) {
            cutOff = found;
          }
        }
        if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);
        var outerToken = outer.token(stream, state.outer);
        if (cutOff != Infinity) stream.string = oldContent;
        return outerToken;
      } else {
        var curInner = state.innerActive, oldContent = stream.string;
        if (!curInner.close &amp;&amp; stream.sol()) {
          state.innerActive = state.inner = null;
          return this.token(stream, state);
        }
        var found = curInner.close ? indexOf(oldContent, curInner.close, stream.pos, curInner.parseDelimiters) : -1;
        if (found == stream.pos &amp;&amp; !curInner.parseDelimiters) {
          stream.match(curInner.close);
          state.innerActive = state.inner = null;
          return curInner.delimStyle &amp;&amp; (curInner.delimStyle + " " + curInner.delimStyle + "-close");
        }
        if (found &gt; -1) stream.string = oldContent.slice(0, found);
        var innerToken = curInner.mode.token(stream, state.inner);
        if (found &gt; -1) stream.string = oldContent;

        if (found == stream.pos &amp;&amp; curInner.parseDelimiters)
          state.innerActive = state.inner = null;

        if (curInner.innerStyle) {
          if (innerToken) innerToken = innerToken + " " + curInner.innerStyle;
          else innerToken = curInner.innerStyle;
        }

        return innerToken;
      }
    },

    indent: function(state, textAfter) {
      var mode = state.innerActive ? state.innerActive.mode : outer;
      if (!mode.indent) return CodeMirror.Pass;
      return mode.indent(state.innerActive ? state.inner : state.outer, textAfter);
    },

    blankLine: function(state) {
      var mode = state.innerActive ? state.innerActive.mode : outer;
      if (mode.blankLine) {
        mode.blankLine(state.innerActive ? state.inner : state.outer);
      }
      if (!state.innerActive) {
        for (var i = 0; i &lt; others.length; ++i) {
          var other = others[i];
          if (other.open === "\n") {
            state.innerActive = other;
            state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, "") : 0);
          }
        }
      } else if (state.innerActive.close === "\n") {
        state.innerActive = state.inner = null;
      }
    },

    electricChars: outer.electricChars,

    innerMode: function(state) {
      return state.inner ? {state: state.inner, mode: state.innerActive.mode} : {state: sta ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.newFoldFunction" id="apidoc.element.codemirror.newFoldFunction">
        function <span class="apidocSignatureSpan">codemirror.</span>newFoldFunction
        <span class="apidocSignatureSpan">(rangeFinder, widget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newFoldFunction = function (rangeFinder, widget) {
  return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.overlayMode" id="apidoc.element.codemirror.overlayMode">
        function <span class="apidocSignatureSpan">codemirror.</span>overlayMode
        <span class="apidocSignatureSpan">(base, overlay, combine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">overlayMode = function (base, overlay, combine) {
  return {
    startState: function() {
      return {
        base: CodeMirror.startState(base),
        overlay: CodeMirror.startState(overlay),
        basePos: 0, baseCur: null,
        overlayPos: 0, overlayCur: null,
        streamSeen: null
      };
    },
    copyState: function(state) {
      return {
        base: CodeMirror.copyState(base, state.base),
        overlay: CodeMirror.copyState(overlay, state.overlay),
        basePos: state.basePos, baseCur: null,
        overlayPos: state.overlayPos, overlayCur: null
      };
    },

    token: function(stream, state) {
      if (stream != state.streamSeen ||
          Math.min(state.basePos, state.overlayPos) &lt; stream.start) {
        state.streamSeen = stream;
        state.basePos = state.overlayPos = stream.start;
      }

      if (stream.start == state.basePos) {
        state.baseCur = base.token(stream, state.base);
        state.basePos = stream.pos;
      }
      if (stream.start == state.overlayPos) {
        stream.pos = stream.start;
        state.overlayCur = overlay.token(stream, state.overlay);
        state.overlayPos = stream.pos;
      }
      stream.pos = Math.min(state.basePos, state.overlayPos);

      // state.overlay.combineTokens always takes precedence over combine,
      // unless set to null
      if (state.overlayCur == null) return state.baseCur;
      else if (state.baseCur != null &amp;&amp;
               state.overlay.combineTokens ||
               combine &amp;&amp; state.overlay.combineTokens == null)
        return state.baseCur + " " + state.overlayCur;
      else return state.overlayCur;
    },

    indent: base.indent &amp;&amp; function(state, textAfter) {
      return base.indent(state.base, textAfter);
    },
    electricChars: base.electricChars,

    innerMode: function(state) { return {state: state.base, mode: base}; },

    blankLine: function(state) {
      var baseToken, overlayToken;
      if (base.blankLine) baseToken = base.blankLine(state.base);
      if (overlay.blankLine) overlayToken = overlay.blankLine(state.overlay);

      return overlayToken == null ?
        baseToken :
        (combine &amp;&amp; baseToken != null ? baseToken + " " + overlayToken : overlayToken);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.registerGlobalHelper" id="apidoc.element.codemirror.registerGlobalHelper">
        function <span class="apidocSignatureSpan">codemirror.</span>registerGlobalHelper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function min() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else if (typeof define == "function" &amp;&amp; define.amd) // AMD
  define(["../../lib/codemirror"], mod);
else // Plain browser env
  mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.<span class="apidocCodeKeywordSpan">registerGlobalHelper</span>("fold", "comment", function(mode) {
return mode.blockCommentStart &amp;&amp; mode.blockCommentEnd;
}, function(cm, start) {
var mode = cm.getModeAt(start), startToken = mode.blockCommentStart, endToken = mode.blockCommentEnd;
if (!startToken || !endToken) return;
var line = start.line, lineText = cm.getLine(line);

var startCh;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.registerHelper" id="apidoc.element.codemirror.registerHelper">
        function <span class="apidocSignatureSpan">codemirror.</span>registerHelper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function min() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  eventMixin(CodeMirror);

  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.<span class="apidocCodeKeywordSpan">registerHelper</span>(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };
};

// Used for horizontal relative motion. Dir is -1 or 1 (left or
// right), unit can be "char", "column" (like char, but doesn't
// cross line boundaries), "word" (across next word), or "group" (to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.requireMode" id="apidoc.element.codemirror.requireMode">
        function <span class="apidocSignatureSpan">codemirror.</span>requireMode
        <span class="apidocSignatureSpan">(mode, cont)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requireMode = function (mode, cont) {
  if (typeof mode != "string") mode = mode.name;
  if (CodeMirror.modes.hasOwnProperty(mode)) return ensureDeps(mode, cont);
  if (loading.hasOwnProperty(mode)) return loading[mode].push(cont);

  var file = CodeMirror.modeURL.replace(/%N/g, mode);
  if (env == "plain") {
    var script = document.createElement("script");
    script.src = file;
    var others = document.getElementsByTagName("script")[0];
    var list = loading[mode] = [cont];
    CodeMirror.on(script, "load", function() {
      ensureDeps(mode, function() {
        for (var i = 0; i &lt; list.length; ++i) list[i]();
      });
    });
    others.parentNode.insertBefore(script, others);
  } else if (env == "cjs") {
    require(file);
    cont();
  } else if (env == "amd") {
    requirejs([file], cont);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.resolveMode" id="apidoc.element.codemirror.resolveMode">
        function <span class="apidocSignatureSpan">codemirror.</span>resolveMode
        <span class="apidocSignatureSpan">(spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveMode = function (spec) {
  if (typeof spec == "string" &amp;&amp; mimeModes.hasOwnProperty(spec)) {
    spec = mimeModes[spec];
  } else if (spec &amp;&amp; typeof spec.name == "string" &amp;&amp; mimeModes.hasOwnProperty(spec.name)) {
    spec = mimeModes[spec.name];
  }
  if (typeof spec == "string") return {name: spec};
  else return spec || {name: "null"};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          to: CodeMirror.Pos(cur.line, token.end)};

var start = token.start, end = cur.ch, word = token.string.slice(0, end - start);
if (/[^\w$_-]/.test(word)) {
  word = ""; start = end = cur.ch;
}

var spec = CodeMirror.<span class="apidocCodeKeywordSpan">resolveMode</span>("text/css");

var result = [];
function add(keywords) {
  for (var name in keywords)
    if (!word || name.lastIndexOf(word, 0) == 0)
      result.push(name);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runMode" id="apidoc.element.codemirror.runMode">
        function <span class="apidocSignatureSpan">codemirror.</span>runMode
        <span class="apidocSignatureSpan">(string, modespec, callback, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">runMode = function (string, modespec, callback, options) {
  var mode = exports.getMode({indentUnit: 2}, modespec);
  var lines = splitLines(string), state = (options &amp;&amp; options.state) || exports.startState(mode);
  for (var i = 0, e = lines.length; i &lt; e; ++i) {
    if (i) callback("\n");
    var stream = new exports.StringStream(lines[i]);
    if (!stream.string &amp;&amp; mode.blankLine) mode.blankLine(state);
    while (!stream.eol()) {
      var style = mode.token(stream, state);
      callback(stream.current(), style, i, stream.start, state);
      stream.start = stream.pos;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.scanForClosingTag" id="apidoc.element.codemirror.scanForClosingTag">
        function <span class="apidocSignatureSpan">codemirror.</span>scanForClosingTag
        <span class="apidocSignatureSpan">(cm, pos, name, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scanForClosingTag = function (cm, pos, name, end) {
  var iter = new Iter(cm, pos.line, pos.ch, end ? {from: 0, to: end} : null);
  return findMatchingClose(iter, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// If xml-fold is loaded, we use its functionality to try and verify
// whether a given tag is actually unclosed.
function closingTagExists(cm, tagName, pos, state, newTag) {
  if (!CodeMirror.scanForClosingTag) return false;
  var end = Math.min(cm.lastLine() + 1, pos.line + 500);
  var nextClose = CodeMirror.<span class="apidocCodeKeywordSpan">scanForClosingTag</span>(cm, pos, null, end);
  if (!nextClose || nextClose.tag != tagName) return false;
  var cx = state.context;
  // If the immediate wrapping context contains onCx instances of
  // the same tag, a closing tag only exists if there are at least
  // that many closing tags of that type following.
  for (var onCx = newTag ? 1 : 0; cx &amp;&amp; cx.tagName == tagName; cx = cx.prev) ++onCx;
  pos = nextClose.to;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.showHint" id="apidoc.element.codemirror.showHint">
        function <span class="apidocSignatureSpan">codemirror.</span>showHint
        <span class="apidocSignatureSpan">(cm, getHints, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">showHint = function (cm, getHints, options) {
  if (!getHints) return cm.showHint(options);
  if (options &amp;&amp; options.async) getHints.async = true;
  var newOpts = {hint: getHints};
  if (options) for (var prop in options) newOpts[prop] = options[prop];
  return cm.showHint(newOpts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var HINT_ELEMENT_CLASS        = "CodeMirror-hint";
var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

// This is the old interface, kept around for now to stay
// backwards-compatible.
CodeMirror.showHint = function(cm, getHints, options) {
  if (!getHints) return cm.<span class="apidocCodeKeywordSpan">showHint</span>(options);
  if (options &amp;&amp; options.async) getHints.async = true;
  var newOpts = {hint: getHints};
  if (options) for (var prop in options) newOpts[prop] = options[prop];
  return cm.showHint(newOpts);
};

CodeMirror.defineExtension("showHint", function(options) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.simpleMode" id="apidoc.element.codemirror.simpleMode">
        function <span class="apidocSignatureSpan">codemirror.</span>simpleMode
        <span class="apidocSignatureSpan">(config, states)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">simpleMode = function (config, states) {
  ensureState(states, "start");
  var states_ = {}, meta = states.meta || {}, hasIndentation = false;
  for (var state in states) if (state != meta &amp;&amp; states.hasOwnProperty(state)) {
    var list = states_[state] = [], orig = states[state];
    for (var i = 0; i &lt; orig.length; i++) {
      var data = orig[i];
      list.push(new Rule(data, states));
      if (data.indent || data.dedent) hasIndentation = true;
    }
  }
  var mode = {
    startState: function() {
      return {state: "start", pending: null,
              local: null, localState: null,
              indent: hasIndentation ? [] : null};
    },
    copyState: function(state) {
      var s = {state: state.state, pending: state.pending,
               local: state.local, localState: null,
               indent: state.indent &amp;&amp; state.indent.slice(0)};
      if (state.localState)
        s.localState = CodeMirror.copyState(state.local.mode, state.localState);
      if (state.stack)
        s.stack = state.stack.slice(0);
      for (var pers = state.persistentStates; pers; pers = pers.next)
        s.persistentStates = {mode: pers.mode,
                              spec: pers.spec,
                              state: pers.state == state.localState ? s.localState : CodeMirror.copyState(pers.mode, pers.state),
                              next: s.persistentStates};
      return s;
    },
    token: tokenFunction(states_, config),
    innerMode: function(state) { return state.local &amp;&amp; {mode: state.local.mode, state: state.localState}; },
    indent: indentFunction(states_, meta)
  };
  if (meta) for (var prop in meta) if (meta.hasOwnProperty(prop))
    mode[prop] = meta[prop];
  return mode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.startState" id="apidoc.element.codemirror.startState">
        function <span class="apidocSignatureSpan">codemirror.</span>startState
        <span class="apidocSignatureSpan">(mode, a1, a2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startState = function (mode, a1, a2) {
  return mode.startState ? mode.startState(a1, a2) : true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    state = info.state;
    mode = info.mode;
  }
  return info || {mode: mode, state: state}
}

function startState(mode, a1, a2) {
  return mode.startState ? mode.<span class="apidocCodeKeywordSpan">startState</span>(a1, a2) : true
}

// STRING STREAM

// Fed to the mode parsers, provides helper functions to make
// parsers more succinct.
...</pre></li>
    </ul>


























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.codemirror.MergeView" id="apidoc.module.codemirror.MergeView">module codemirror.MergeView</a></h1>


    <h2>
        <a href="#apidoc.element.codemirror.MergeView.MergeView" id="apidoc.element.codemirror.MergeView.MergeView">
        function <span class="apidocSignatureSpan">codemirror.</span>MergeView
        <span class="apidocSignatureSpan">(node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MergeView = function (node, options) {
  if (!(this instanceof MergeView)) return new MergeView(node, options);

  this.options = options;
  var origLeft = options.origLeft, origRight = options.origRight == null ? options.orig : options.origRight;

  var hasLeft = origLeft != null, hasRight = origRight != null;
  var panes = 1 + (hasLeft ? 1 : 0) + (hasRight ? 1 : 0);
  var wrap = [], left = this.left = null, right = this.right = null;
  var self = this;

  if (hasLeft) {
    left = this.left = new DiffView(this, "left");
    var leftPane = elt("div", null, "CodeMirror-merge-pane CodeMirror-merge-left");
    wrap.push(leftPane);
    wrap.push(buildGap(left));
  }

  var editPane = elt("div", null, "CodeMirror-merge-pane CodeMirror-merge-editor");
  wrap.push(editPane);

  if (hasRight) {
    right = this.right = new DiffView(this, "right");
    wrap.push(buildGap(right));
    var rightPane = elt("div", null, "CodeMirror-merge-pane CodeMirror-merge-right");
    wrap.push(rightPane);
  }

  (hasRight ? rightPane : editPane).className += " CodeMirror-merge-pane-rightmost";

  wrap.push(elt("div", null, null, "height: 0; clear: both;"));

  var wrapElt = this.wrap = node.appendChild(elt("div", wrap, "CodeMirror-merge CodeMirror-merge-" + panes + "pane"));
  this.edit = CodeMirror(editPane, copyObj(options));

  if (left) left.init(leftPane, origLeft, options);
  if (right) right.init(rightPane, origRight, options);
  if (options.collapseIdentical)
    this.editor().operation(function() {
      collapseIdenticalStretches(self, options.collapseIdentical);
    });
  if (options.connect == "align") {
    this.aligners = [];
    alignChunks(this.left || this.right, true);
  }
  if (left) left.registerEvents(right)
  if (right) right.registerEvents(left)


  var onResize = function() {
    if (left) makeConnections(left);
    if (right) makeConnections(right);
  };
  CodeMirror.on(window, "resize", onResize);
  var resizeInterval = setInterval(function() {
    for (var p = wrapElt.parentNode; p &amp;&amp; p != document.body; p = p.parentNode) {}
    if (!p) { clearInterval(resizeInterval); CodeMirror.off(window, "resize", onResize); }
  }, 5000);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.codemirror.MergeView.prototype" id="apidoc.module.codemirror.MergeView.prototype">module codemirror.MergeView.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.codemirror.MergeView.prototype.constructor" id="apidoc.element.codemirror.MergeView.prototype.constructor">
        function <span class="apidocSignatureSpan">codemirror.MergeView.prototype.</span>constructor
        <span class="apidocSignatureSpan">(node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (node, options) {
  if (!(this instanceof MergeView)) return new MergeView(node, options);

  this.options = options;
  var origLeft = options.origLeft, origRight = options.origRight == null ? options.orig : options.origRight;

  var hasLeft = origLeft != null, hasRight = origRight != null;
  var panes = 1 + (hasLeft ? 1 : 0) + (hasRight ? 1 : 0);
  var wrap = [], left = this.left = null, right = this.right = null;
  var self = this;

  if (hasLeft) {
    left = this.left = new DiffView(this, "left");
    var leftPane = elt("div", null, "CodeMirror-merge-pane CodeMirror-merge-left");
    wrap.push(leftPane);
    wrap.push(buildGap(left));
  }

  var editPane = elt("div", null, "CodeMirror-merge-pane CodeMirror-merge-editor");
  wrap.push(editPane);

  if (hasRight) {
    right = this.right = new DiffView(this, "right");
    wrap.push(buildGap(right));
    var rightPane = elt("div", null, "CodeMirror-merge-pane CodeMirror-merge-right");
    wrap.push(rightPane);
  }

  (hasRight ? rightPane : editPane).className += " CodeMirror-merge-pane-rightmost";

  wrap.push(elt("div", null, null, "height: 0; clear: both;"));

  var wrapElt = this.wrap = node.appendChild(elt("div", wrap, "CodeMirror-merge CodeMirror-merge-" + panes + "pane"));
  this.edit = CodeMirror(editPane, copyObj(options));

  if (left) left.init(leftPane, origLeft, options);
  if (right) right.init(rightPane, origRight, options);
  if (options.collapseIdentical)
    this.editor().operation(function() {
      collapseIdenticalStretches(self, options.collapseIdentical);
    });
  if (options.connect == "align") {
    this.aligners = [];
    alignChunks(this.left || this.right, true);
  }
  if (left) left.registerEvents(right)
  if (right) right.registerEvents(left)


  var onResize = function() {
    if (left) makeConnections(left);
    if (right) makeConnections(right);
  };
  CodeMirror.on(window, "resize", onResize);
  var resizeInterval = setInterval(function() {
    for (var p = wrapElt.parentNode; p &amp;&amp; p != document.body; p = p.parentNode) {}
    if (!p) { clearInterval(resizeInterval); CodeMirror.off(window, "resize", onResize); }
  }, 5000);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.MergeView.prototype.editor" id="apidoc.element.codemirror.MergeView.prototype.editor">
        function <span class="apidocSignatureSpan">codemirror.MergeView.prototype.</span>editor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">editor = function () { return this.edit; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.MergeView.prototype.leftChunks" id="apidoc.element.codemirror.MergeView.prototype.leftChunks">
        function <span class="apidocSignatureSpan">codemirror.MergeView.prototype.</span>leftChunks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leftChunks = function () {
  if (this.left) { ensureDiff(this.left); return this.left.chunks; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.MergeView.prototype.leftOriginal" id="apidoc.element.codemirror.MergeView.prototype.leftOriginal">
        function <span class="apidocSignatureSpan">codemirror.MergeView.prototype.</span>leftOriginal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leftOriginal = function () { return this.left &amp;&amp; this.left.orig; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.MergeView.prototype.rightChunks" id="apidoc.element.codemirror.MergeView.prototype.rightChunks">
        function <span class="apidocSignatureSpan">codemirror.MergeView.prototype.</span>rightChunks
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rightChunks = function () {
  if (this.right) { ensureDiff(this.right); return this.right.chunks; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.MergeView.prototype.rightOriginal" id="apidoc.element.codemirror.MergeView.prototype.rightOriginal">
        function <span class="apidocSignatureSpan">codemirror.MergeView.prototype.</span>rightOriginal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rightOriginal = function () { return this.right &amp;&amp; this.right.orig; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.MergeView.prototype.setShowDifferences" id="apidoc.element.codemirror.MergeView.prototype.setShowDifferences">
        function <span class="apidocSignatureSpan">codemirror.MergeView.prototype.</span>setShowDifferences
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setShowDifferences = function (val) {
  if (this.right) this.right.setShowDifferences(val);
  if (this.left) this.left.setShowDifferences(val);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.codemirror.StringStream" id="apidoc.module.codemirror.StringStream">module codemirror.StringStream</a></h1>


    <h2>
        <a href="#apidoc.element.codemirror.StringStream.StringStream" id="apidoc.element.codemirror.StringStream.StringStream">
        function <span class="apidocSignatureSpan">codemirror.</span>StringStream
        <span class="apidocSignatureSpan">(string, tabSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StringStream(string, tabSize) {
  this.pos = this.start = 0;
  this.string = string;
  this.tabSize = tabSize || 8;
  this.lastColumnPos = this.lastColumnValue = 0;
  this.lineStart = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return out.join('');
}

// Unescape \ and / in the replace part, for PCRE mode.
var unescapes = {'\\/': '/', '\\\\': '\\', '\\n': '\n', '\\r'
;: '\r', '\\t': '\t'};
function unescapeRegexReplace(str) {
  var stream = new CodeMirror.<span class="apidocCodeKeywordSpan">StringStream</span>(str);
  var output = [];
  while (!stream.eol()) {
    // Search for \.
    while (stream.peek() &amp;&amp; stream.peek() != '\\') {
      output.push(stream.next());
    }
    var matched = false;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.codemirror.StringStream.prototype" id="apidoc.module.codemirror.StringStream.prototype">module codemirror.StringStream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.codemirror.StringStream.prototype.backUp" id="apidoc.element.codemirror.StringStream.prototype.backUp">
        function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>backUp
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backUp = function (n) {this.pos -= n;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (match[0].length == 0) {
  // Matched empty string, skip to next.
  stream.next();
  return 'searching';
}
if (!stream.sol()) {
  // Backtrack 1 to match \b
  stream.<span class="apidocCodeKeywordSpan">backUp</span>(1);
  if (!query.exec(stream.next() + match[0])) {
    stream.next();
    return null;
  }
}
stream.match(query);
return 'searching';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.StringStream.prototype.column" id="apidoc.element.codemirror.StringStream.prototype.column">
        function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>column
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">column = function () {
  if (this.lastColumnPos &lt; this.start) {
    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
    this.lastColumnPos = this.start;
  }
  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.StringStream.prototype.current" id="apidoc.element.codemirror.StringStream.prototype.current">
        function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>current
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">current = function (){return this.string.slice(this.start, this.pos);}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
throw new Error("Mode " + mode.name + " failed to advance stream.")
}

// Utility for getTokenAt and getLineTokens
function takeToken(cm, pos, precise, asArray) {
var getObj = function (copy) { return ({
  start: stream.start, end: stream.pos,
  string: stream.<span class="apidocCodeKeywordSpan">current</span>(),
  type: style || null,
  state: copy ? copyState(doc.mode, state) : state
}); };

var doc = cm.doc, mode = doc.mode, style;
pos = clipPos(doc, pos);
var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.StringStream.prototype.eat" id="apidoc.element.codemirror.StringStream.prototype.eat">
        function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>eat
        <span class="apidocSignatureSpan">(match)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eat = function (match) {
  var ch = this.string.charAt(this.pos);
  if (typeof match == "string") var ok = ch == match;
  else var ok = ch &amp;&amp; (match.test ? match.test(ch) : match(ch));
  if (ok) {++this.pos; return ch;}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    showConfirm(cm, e);
    throw e;
  }
},
parseInput_: function(cm, inputStream, result) {
  inputStream.eatWhile(':');
  // Parse range.
  if (inputStream.<span class="apidocCodeKeywordSpan">eat</span>('%')) {
    result.line = cm.firstLine();
    result.lineEnd = cm.lastLine();
  } else {
    result.line = this.parseLineSpec_(cm, inputStream);
    if (result.line !== undefined &amp;&amp; inputStream.eat(',')) {
      result.lineEnd = this.parseLineSpec_(cm, inputStream);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.StringStream.prototype.eatSpace" id="apidoc.element.codemirror.StringStream.prototype.eatSpace">
        function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>eatSpace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eatSpace = function () {
  var start = this.pos;
  while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
  return this.pos &gt; start;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      sort: function(cm, params) {
var reverse, ignoreCase, unique, number, pattern;
function parseArgs() {
  if (params.argString) {
    var args = new CodeMirror.StringStream(params.argString);
    if (args.eat('!')) { reverse = true; }
    if (args.eol()) { return; }
    if (!args.<span class="apidocCodeKeywordSpan">eatSpace</span>()) { return 'Invalid arguments'; }
    var opts = args.match(/([dinuox]+)?\s*(\/.+\/)?\s*/);
    if (!opts &amp;&amp; !args.eol()) { return 'Invalid arguments'; }
    if (opts[1]) {
      ignoreCase = opts[1].indexOf('i') != -1;
      unique = opts[1].indexOf('u') != -1;
      var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 &amp;&amp; 1;
      var hex = opts[1].indexOf('x') != -1 &amp;&amp; 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.StringStream.prototype.eatWhile" id="apidoc.element.codemirror.StringStream.prototype.eatWhile">
        function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>eatWhile
        <span class="apidocSignatureSpan">(match)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eatWhile = function (match) {
  var start = this.pos;
  while (this.eat(match)){}
  return this.pos &gt; start;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  } catch(e) {
    showConfirm(cm, e);
    throw e;
  }
},
parseInput_: function(cm, inputStream, result) {
  inputStream.<span class="apidocCodeKeywordSpan">eatWhile</span>(':');
  // Parse range.
  if (inputStream.eat('%')) {
    result.line = cm.firstLine();
    result.lineEnd = cm.lastLine();
  } else {
    result.line = this.parseLineSpec_(cm, inputStream);
    if (result.line !== undefined &amp;&amp; inputStream.eat(',')) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.StringStream.prototype.eol" id="apidoc.element.codemirror.StringStream.prototype.eol">
        function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>eol
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eol = function () {return this.pos &gt;= this.string.length;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Unescape \ and / in the replace part, for PCRE mode.
var unescapes = {'\\/': '/', '\\\\': '\\', '\\n': '\n', '\\r'
;: '\r', '\\t': '\t'};
function unescapeRegexReplace(str) {
  var stream = new CodeMirror.StringStream(str);
  var output = [];
  while (!stream.<span class="apidocCodeKeywordSpan">eol</span>()) {
    // Search for \.
    while (stream.peek() &amp;&amp; stream.peek() != '\\') {
      output.push(stream.next());
    }
    var matched = false;
    for (var matcher in unescapes) {
      if (stream.match(matcher, true)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.StringStream.prototype.hideFirstChars" id="apidoc.element.codemirror.StringStream.prototype.hideFirstChars">
        function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>hideFirstChars
        <span class="apidocSignatureSpan">(n, inner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hideFirstChars = function (n, inner) {
  this.lineStart += n;
  try { return inner(); }
  finally { this.lineStart -= n; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.StringStream.prototype.indentation" id="apidoc.element.codemirror.StringStream.prototype.indentation">
        function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>indentation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indentation = function () {
  return countColumn(this.string, null, this.tabSize) -
    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.StringStream.prototype.match" id="apidoc.element.codemirror.StringStream.prototype.match">
        function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>match
        <span class="apidocSignatureSpan">(pattern, consume, caseInsensitive)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">match = function (pattern, consume, caseInsensitive) {
  if (typeof pattern == "string") {
    var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
    var substr = this.string.substr(this.pos, pattern.length);
    if (cased(substr) == cased(pattern)) {
      if (consume !== false) this.pos += pattern.length;
      return true;
    }
  } else {
    var match = this.string.slice(this.pos).match(pattern);
    if (match &amp;&amp; match.index &gt; 0) return null;
    if (match &amp;&amp; consume !== false) this.pos += match[0].length;
    return match;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// length that considers tabs and tabSize
var whitespaceLength = function(str) {
  var tabs = (str.split("\t").length - 1);
  var spaces = (str.split(" ").length - 1);
  return tabs * tabSize + spaces * 1;
};
var currentLine = cm.getLine(cm.getCursor().line);
var indent = whitespaceLength(currentLine.<span class="apidocCodeKeywordSpan">match</span>(/^\s*/)[0]);
// chomp last newline b/c don't want it to match /^\s*/gm
var chompedText = text.replace(/\n$/, '');
var wasChomped = text !== chompedText;
var firstIndent = whitespaceLength(text.match(/^\s*/)[0]);
var text = chompedText.replace(/^\s*/gm, function(wspace) {
  var newIndent = indent + (whitespaceLength(wspace) - firstIndent);
  if (newIndent &lt; 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.StringStream.prototype.next" id="apidoc.element.codemirror.StringStream.prototype.next">
        function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function () {
  if (this.pos &lt; this.string.length)
    return this.string.charAt(this.pos++);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var unescapes = {'\\/': '/', '\\\\': '\\', '\\n': '\n', '\\r'
;: '\r', '\\t': '\t'};
function unescapeRegexReplace(str) {
  var stream = new CodeMirror.StringStream(str);
  var output = [];
  while (!stream.eol()) {
    // Search for \.
    while (stream.peek() &amp;&amp; stream.peek() != '\\') {
      output.push(stream.<span class="apidocCodeKeywordSpan">next</span>());
    }
    var matched = false;
    for (var matcher in unescapes) {
      if (stream.match(matcher, true)) {
        matched = true;
        output.push(unescapes[matcher]);
        break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.StringStream.prototype.peek" id="apidoc.element.codemirror.StringStream.prototype.peek">
        function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>peek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function () {return this.string.charAt(this.pos) || undefined;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Unescape \ and / in the replace part, for PCRE mode.
var unescapes = {'\\/': '/', '\\\\': '\\', '\\n': '\n', '\\r'
;: '\r', '\\t': '\t'};
function unescapeRegexReplace(str) {
  var stream = new CodeMirror.StringStream(str);
  var output = [];
  while (!stream.eol()) {
    // Search for \.
    while (stream.<span class="apidocCodeKeywordSpan">peek</span>() &amp;&amp; stream.peek() != '\\') {
      output.push(stream.next());
    }
    var matched = false;
    for (var matcher in unescapes) {
      if (stream.match(matcher, true)) {
        matched = true;
        output.push(unescapes[matcher]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.StringStream.prototype.skipTo" id="apidoc.element.codemirror.StringStream.prototype.skipTo">
        function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>skipTo
        <span class="apidocSignatureSpan">(ch)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipTo = function (ch) {
  var found = this.string.indexOf(ch, this.pos);
  if (found &gt; -1) {this.pos = found; return true;}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.StringStream.prototype.skipToEnd" id="apidoc.element.codemirror.StringStream.prototype.skipToEnd">
        function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>skipToEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skipToEnd = function () {this.pos = this.string.length;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function searchOverlay(query) {
if (query.source.charAt(0) == '^') {
  var matchSol = true;
}
return {
  token: function(stream) {
    if (matchSol &amp;&amp; !stream.sol()) {
      stream.<span class="apidocCodeKeywordSpan">skipToEnd</span>();
      return;
    }
    var match = stream.match(query, false);
    if (match) {
      if (match[0].length == 0) {
        // Matched empty string, skip to next.
        stream.next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.StringStream.prototype.sol" id="apidoc.element.codemirror.StringStream.prototype.sol">
        function <span class="apidocSignatureSpan">codemirror.StringStream.prototype.</span>sol
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sol = function () {return this.pos == this.lineStart;}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
function searchOverlay(query) {
  if (query.source.charAt(0) == '^') {
    var matchSol = true;
  }
  return {
    token: function(stream) {
      if (matchSol &amp;&amp; !stream.<span class="apidocCodeKeywordSpan">sol</span>()) {
        stream.skipToEnd();
        return;
      }
      var match = stream.match(query, false);
      if (match) {
        if (match[0].length == 0) {
          // Matched empty string, skip to next.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.codemirror.TernServer" id="apidoc.module.codemirror.TernServer">module codemirror.TernServer</a></h1>


    <h2>
        <a href="#apidoc.element.codemirror.TernServer.TernServer" id="apidoc.element.codemirror.TernServer.TernServer">
        function <span class="apidocSignatureSpan">codemirror.</span>TernServer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TernServer = function (options) {
  var self = this;
  this.options = options || {};
  var plugins = this.options.plugins || (this.options.plugins = {});
  if (!plugins.doc_comment) plugins.doc_comment = true;
  this.docs = Object.create(null);
  if (this.options.useWorker) {
    this.server = new WorkerServer(this);
  } else {
    this.server = new tern.Server({
      getFile: function(name, c) { return getFile(self, name, c); },
      async: true,
      defs: this.options.defs || [],
      plugins: plugins
    });
  }
  this.trackChange = function(doc, change) { trackChange(self, doc, change); };

  this.cachedArgHints = null;
  this.activeArgHints = null;
  this.jumpStack = [];

  this.getHint = function(cm, c) { return hint(self, cm, c); };
  this.getHint.async = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.codemirror.TernServer.prototype" id="apidoc.module.codemirror.TernServer.prototype">module codemirror.TernServer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.codemirror.TernServer.prototype.addDoc" id="apidoc.element.codemirror.TernServer.prototype.addDoc">
        function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>addDoc
        <span class="apidocSignatureSpan">(name, doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addDoc = function (name, doc) {
  var data = {doc: doc, name: name, changed: null};
  this.server.addFile(name, docValue(this, data));
  CodeMirror.on(doc, "change", this.trackChange);
  return this.docs[name] = data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.TernServer.prototype.complete" id="apidoc.element.codemirror.TernServer.prototype.complete">
        function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>complete
        <span class="apidocSignatureSpan">(cm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">complete = function (cm) {
  cm.showHint({hint: this.getHint});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.TernServer.prototype.delDoc" id="apidoc.element.codemirror.TernServer.prototype.delDoc">
        function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>delDoc
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">delDoc = function (id) {
  var found = resolveDoc(this, id);
  if (!found) return;
  CodeMirror.off(found.doc, "change", this.trackChange);
  delete this.docs[found.name];
  this.server.delFile(found.name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.TernServer.prototype.destroy" id="apidoc.element.codemirror.TernServer.prototype.destroy">
        function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>destroy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function () {
  closeArgHints(this)
  if (this.worker) {
    this.worker.terminate();
    this.worker = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.TernServer.prototype.hideDoc" id="apidoc.element.codemirror.TernServer.prototype.hideDoc">
        function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>hideDoc
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hideDoc = function (id) {
  closeArgHints(this);
  var found = resolveDoc(this, id);
  if (found &amp;&amp; found.changed) sendDoc(this, found);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.TernServer.prototype.jumpBack" id="apidoc.element.codemirror.TernServer.prototype.jumpBack">
        function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>jumpBack
        <span class="apidocSignatureSpan">(cm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jumpBack = function (cm) { jumpBack(this, cm); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.TernServer.prototype.jumpToDef" id="apidoc.element.codemirror.TernServer.prototype.jumpToDef">
        function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>jumpToDef
        <span class="apidocSignatureSpan">(cm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jumpToDef = function (cm) { jumpToDef(this, cm); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.TernServer.prototype.rename" id="apidoc.element.codemirror.TernServer.prototype.rename">
        function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>rename
        <span class="apidocSignatureSpan">(cm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rename = function (cm) { rename(this, cm); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.TernServer.prototype.request" id="apidoc.element.codemirror.TernServer.prototype.request">
        function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>request
        <span class="apidocSignatureSpan">(cm, query, c, pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">request = function (cm, query, c, pos) {
  var self = this;
  var doc = findDoc(this, cm.getDoc());
  var request = buildRequest(this, doc, query, pos);
  var extraOptions = request.query &amp;&amp; this.options.queryOptions &amp;&amp; this.options.queryOptions[request.query.type]
  if (extraOptions) for (var prop in extraOptions) request.query[prop] = extraOptions[prop];

  this.server.request(request, function (error, data) {
    if (!error &amp;&amp; self.options.responseFilter)
      data = self.options.responseFilter(doc, query, request, error, data);
    c(error, data);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.TernServer.prototype.selectName" id="apidoc.element.codemirror.TernServer.prototype.selectName">
        function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>selectName
        <span class="apidocSignatureSpan">(cm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectName = function (cm) { selectName(this, cm); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.TernServer.prototype.showDocs" id="apidoc.element.codemirror.TernServer.prototype.showDocs">
        function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>showDocs
        <span class="apidocSignatureSpan">(cm, pos, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">showDocs = function (cm, pos, c) { showContextInfo(this, cm, pos, "documentation", c); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.TernServer.prototype.showType" id="apidoc.element.codemirror.TernServer.prototype.showType">
        function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>showType
        <span class="apidocSignatureSpan">(cm, pos, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">showType = function (cm, pos, c) { showContextInfo(this, cm, pos, "type", c); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.TernServer.prototype.updateArgHints" id="apidoc.element.codemirror.TernServer.prototype.updateArgHints">
        function <span class="apidocSignatureSpan">codemirror.TernServer.prototype.</span>updateArgHints
        <span class="apidocSignatureSpan">(cm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateArgHints = function (cm) { updateArgHints(this, cm); }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.codemirror.emacs" id="apidoc.module.codemirror.emacs">module codemirror.emacs</a></h1>


    <h2>
        <a href="#apidoc.element.codemirror.emacs.kill" id="apidoc.element.codemirror.emacs.kill">
        function <span class="apidocSignatureSpan">codemirror.emacs.</span>kill
        <span class="apidocSignatureSpan">(cm, from, to, mayGrow, text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kill(cm, from, to, mayGrow, text) {
  if (text == null) text = cm.getRange(from, to);

  if (mayGrow &amp;&amp; lastKill &amp;&amp; lastKill.cm == cm &amp;&amp; posEq(from, lastKill.pos) &amp;&amp; cm.isClean(lastKill.gen))
    growRingTop(text);
  else
    addToRing(text);
  cm.replaceRange("", from, to, "+delete");

  if (mayGrow) lastKill = {cm: cm, pos: from, gen: cm.changeGeneration()};
  else lastKill = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.emacs.killRegion" id="apidoc.element.codemirror.emacs.killRegion">
        function <span class="apidocSignatureSpan">codemirror.emacs.</span>killRegion
        <span class="apidocSignatureSpan">(cm)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function killRegion(cm) {
  if (cm.somethingSelected()) {
    var selections = cm.listSelections(), selection;
    var i = selections.length;
    while (i--) {
      selection = selections[i];
      kill(cm, selection.anchor, selection.head);
    }
    return true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.emacs.repeated" id="apidoc.element.codemirror.emacs.repeated">
        function <span class="apidocSignatureSpan">codemirror.emacs.</span>repeated
        <span class="apidocSignatureSpan">(cmd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function repeated(cmd) {
  var f = typeof cmd == "string" ? function(cm) { cm.execCommand(cmd); } : cmd;
  return function(cm) {
    var prefix = getPrefix(cm);
    f(cm);
    for (var i = 1; i &lt; prefix; ++i) f(cm);
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.codemirror.modes" id="apidoc.module.codemirror.modes">module codemirror.modes</a></h1>


    <h2>
        <a href="#apidoc.element.codemirror.modes.apl" id="apidoc.element.codemirror.modes.apl">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>apl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apl = function () {
  var builtInOps = {
    ".": "innerProduct",
    "\\": "scan",
    "/": "reduce",
    "âŒ¿": "reduce1Axis",
    "â€": "scan1Axis",
    "Â¨": "each",
    "â£": "power"
  };
  var builtInFuncs = {
    "+": ["conjugate", "add"],
    "âˆ’": ["negate", "subtract"],
    "Ã—": ["signOf", "multiply"],
    "Ã·": ["reciprocal", "divide"],
    "âŒˆ": ["ceiling", "greaterOf"],
    "âŒŠ": ["floor", "lesserOf"],
    "âˆ£": ["absolute", "residue"],
    "â³": ["indexGenerate", "indexOf"],
    "?": ["roll", "deal"],
    "â‹†": ["exponentiate", "toThePowerOf"],
    "âŸ": ["naturalLog", "logToTheBase"],
    "â—‹": ["piTimes", "circularFuncs"],
    "!": ["factorial", "binomial"],
    "âŒ¹": ["matrixInverse", "matrixDivide"],
    "&lt;": [null, "lessThan"],
    "â‰¤": [null, "lessThanOrEqual"],
    "=": [null, "equals"],
    "&gt;": [null, "greaterThan"],
    "â‰¥": [null, "greaterThanOrEqual"],
    "â‰&nbsp;": [null, "notEqual"],
    "â‰¡": ["depth", "match"],
    "â‰¢": [null, "notMatch"],
    "âˆˆ": ["enlist", "membership"],
    "â·": [null, "find"],
    "âˆª": ["unique", "union"],
    "âˆ©": [null, "intersection"],
    "âˆ¼": ["not", "without"],
    "âˆ¨": [null, "or"],
    "âˆ§": [null, "and"],
    "â±": [null, "nor"],
    "â²": [null, "nand"],
    "â´": ["shapeOf", "reshape"],
    ",": ["ravel", "catenate"],
    "âª": [null, "firstAxisCatenate"],
    "âŒ½": ["reverse", "rotate"],
    "âŠ–": ["axis1Reverse", "axis1Rotate"],
    "â‰": ["transpose", null],
    "â†‘": ["first", "take"],
    "â†“": [null, "drop"],
    "âŠ‚": ["enclose", "partitionWithAxis"],
    "âŠƒ": ["diclose", "pick"],
    "âŒ·": [null, "index"],
    "â‹": ["gradeUp", null],
    "â’": ["gradeDown", null],
    "âŠ¤": ["encode", null],
    "âŠ¥": ["decode", null],
    "â•": ["format", "formatByExample"],
    "âŽ": ["execute", null],
    "âŠ£": ["stop", "left"],
    "âŠ¢": ["pass", "right"]
  };

  var isOperator = /[\.\/âŒ¿â€Â¨â£]/;
  var isNiladic = /â¬/;
  var isFunction = /[\+âˆ’Ã—Ã·âŒˆâŒŠâˆ£â³\?â‹†âŸâ—‹!âŒ¹&lt;â‰¤=&gt;â‰¥â‰&nbsp;â‰¡â‰¢âˆˆâ·âˆªâˆ©âˆ¼âˆ¨âˆ§â±â²â´,âªâŒ½âŠ–â‰â†‘â†“âŠ‚âŠƒâŒ·â‹â’âŠ¤âŠ¥â•âŽâŠ£âŠ¢]/;
  var isArrow = /â†/;
  var isComment = /[â#].*$/;

  var stringEater = function(type) {
    var prev;
    prev = false;
    return function(c) {
      prev = c;
      if (c === type) {
        return prev === "\\";
      }
      return true;
    };
  };
  return {
    startState: function() {
      return {
        prev: false,
        func: false,
        op: false,
        string: false,
        escape: false
      };
    },
    token: function(stream, state) {
      var ch, funcName;
      if (stream.eatSpace()) {
        return null;
      }
      ch = stream.next();
      if (ch === '"' || ch === "'") {
        stream.eatWhile(stringEater(ch));
        stream.next();
        state.prev = true;
        return "string";
      }
      if (/[\[{\(]/.test(ch)) {
        state.prev = false;
        return null;
      }
      if (/[\]}\)]/.test(ch)) {
        state.prev = true;
        return null;
      }
      if (isNiladic.test(ch)) {
        state.prev = false;
        return "niladic";
      }
      if (/[Â¯\d]/.test(ch)) {
        if (state.func) {
          state.func = false;
          state.prev = false;
        } else {
          state.prev = true;
        }
        stream.eatWhile(/[\w\.]/);
        return "number";
      }
      if (isOperator.test(ch)) {
        return "operator apl-" + builtInOps[ch];
      }
      if (isArrow.test(ch)) {
        return "apl-arrow";
      }
      if (isFunction.test(ch)) {
        funcName = "apl-";
        if (builtInFuncs[ch] != null) {
          if (state.prev) {
            funcName += builtInFuncs[ch][1];
          } else {
            funcName += builtInFuncs[ch][0];
          }
        }
        state.func = true;
        state.prev = false;
        return "function " + funcName;
      }
      if (isComment.test(ch)) {
        stream.skipToEnd();
        return "comment";
      }
      if (ch === "âˆ˜" &amp;&amp; stream.peek() === ".") {
        stream.next();
        return "function jot-dot";
      }
      stream.eatWhile(/[\w\$_]/);
      state.prev = true;
      return "keyword";
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.asciiarmor" id="apidoc.element.codemirror.modes.asciiarmor">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>asciiarmor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asciiarmor = function () {
  return {
    token: function(stream, state) {
      var m;
      if (state.state == "top") {
        if (stream.sol() &amp;&amp; (m = stream.match(/^-----BEGIN (.*)?-----\s*$/))) {
          state.state = "headers";
          state.type = m[1];
          return "tag";
        }
        return errorIfNotEmpty(stream);
      } else if (state.state == "headers") {
        if (stream.sol() &amp;&amp; stream.match(/^\w+:/)) {
          state.state = "header";
          return "atom";
        } else {
          var result = errorIfNotEmpty(stream);
          if (result) state.state = "body";
          return result;
        }
      } else if (state.state == "header") {
        stream.skipToEnd();
        state.state = "headers";
        return "string";
      } else if (state.state == "body") {
        if (stream.sol() &amp;&amp; (m = stream.match(/^-----END (.*)?-----\s*$/))) {
          if (m[1] != state.type) return "error";
          state.state = "end";
          return "tag";
        } else {
          if (stream.eatWhile(/[A-Za-z0-9+\/=]/)) {
            return null;
          } else {
            stream.next();
            return "error";
          }
        }
      } else if (state.state == "end") {
        return errorIfNotEmpty(stream);
      }
    },
    blankLine: function(state) {
      if (state.state == "headers") state.state = "body";
    },
    startState: function() {
      return {state: "top", type: null};
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.asn.1" id="apidoc.element.codemirror.modes.asn.1">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>asn.1
        <span class="apidocSignatureSpan">(config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asn.1 = function (config, parserConfig) {
  var indentUnit = config.indentUnit,
      keywords = parserConfig.keywords || {},
      cmipVerbs = parserConfig.cmipVerbs || {},
      compareTypes = parserConfig.compareTypes || {},
      status = parserConfig.status || {},
      tags = parserConfig.tags || {},
      storage = parserConfig.storage || {},
      modifier = parserConfig.modifier || {},
      accessTypes = parserConfig.accessTypes|| {},
      multiLineStrings = parserConfig.multiLineStrings,
      indentStatements = parserConfig.indentStatements !== false;
  var isOperatorChar = /[\|\^]/;
  var curPunc;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (/[\[\]\(\){}:=,;]/.test(ch)) {
      curPunc = ch;
      return "punctuation";
    }
    if (ch == "-"){
      if (stream.eat("-")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }

    stream.eatWhile(/[\w\-]/);
    var cur = stream.current();
    if (keywords.propertyIsEnumerable(cur)) return "keyword";
    if (cmipVerbs.propertyIsEnumerable(cur)) return "variable cmipVerbs";
    if (compareTypes.propertyIsEnumerable(cur)) return "atom compareTypes";
    if (status.propertyIsEnumerable(cur)) return "comment status";
    if (tags.propertyIsEnumerable(cur)) return "variable-3 tags";
    if (storage.propertyIsEnumerable(cur)) return "builtin storage";
    if (modifier.propertyIsEnumerable(cur)) return "string-2 modifier";
    if (accessTypes.propertyIsEnumerable(cur)) return "atom accessTypes";

    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote &amp;&amp; !escaped){
          var afterNext = stream.peek();
          //look if the character if the quote is like the B in '10100010'B
          if (afterNext){
            afterNext = afterNext.toLowerCase();
            if(afterNext == "b" || afterNext == "h" || afterNext == "o")
              stream.next();
          }
          end = true; break;
        }
        escaped = !escaped &amp;&amp; next == "\\";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = null;
      return "string";
    };
  }

  function Context(indented, column, type, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.align = align;
    this.prev = prev;
  }
  function pushContext(state, col, type) {
    var indent = state.indented;
    if (state.context &amp;&amp; state.context.type == "statement")
      indent = state.context.indented;
    return state.context = new Context(indent, col, type, null, state.context);
  }
  function popContext(state) {
    var t = state.context.type;
    if (t == ")" || t == "]" || t == "}")
      state.indented = state.context.indented;
    return state.context = state.context.prev;
  }

  //Interface
  return {
    startState: function(basecolumn) {
      return {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
        indented: 0,
        startOfLine: true
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (stream.eatSpace()) return null;
      curPunc = null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment") return style;
      if (ctx.align == null) ctx.align = true;

      if ((curPunc == ";" || curPunc == ":" || curPunc == ",")
          &amp;&amp; ctx.type == "statement"){
        popContext(state);
      }
      else if (curPunc == "{") pushConte ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.asterisk" id="apidoc.element.codemirror.modes.asterisk">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>asterisk
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asterisk = function () {
  var atoms    = ["exten", "same", "include","ignorepat","switch"],
      dpcmd    = ["#include","#exec"],
      apps     = [
                  "addqueuemember","adsiprog","aelsub","agentlogin","agentmonitoroutgoing","agi",
                  "alarmreceiver","amd","answer","authenticate","background","backgrounddetect",
                  "bridge","busy","callcompletioncancel","callcompletionrequest","celgenuserevent",
                  "changemonitor","chanisavail","channelredirect","chanspy","clearhash","confbridge",
                  "congestion","continuewhile","controlplayback","dahdiacceptr2call","dahdibarge",
                  "dahdiras","dahdiscan","dahdisendcallreroutingfacility","dahdisendkeypadfacility",
                  "datetime","dbdel","dbdeltree","deadagi","dial","dictate","directory","disa",
                  "dumpchan","eagi","echo","endwhile","exec","execif","execiftime","exitwhile","extenspy",
                  "externalivr","festival","flash","followme","forkcdr","getcpeid","gosub","gosubif",
                  "goto","gotoif","gotoiftime","hangup","iax2provision","ices","importvar","incomplete",
                  "ivrdemo","jabberjoin","jabberleave","jabbersend","jabbersendgroup","jabberstatus",
                  "jack","log","macro","macroexclusive","macroexit","macroif","mailboxexists","meetme",
                  "meetmeadmin","meetmechanneladmin","meetmecount","milliwatt","minivmaccmess","minivmdelete",
                  "minivmgreet","minivmmwi","minivmnotify","minivmrecord","mixmonitor","monitor","morsecode",
                  "mp3player","mset","musiconhold","nbscat","nocdr","noop","odbc","odbc","odbcfinish",
                  "originate","ospauth","ospfinish","osplookup","ospnext","page","park","parkandannounce",
                  "parkedcall","pausemonitor","pausequeuemember","pickup","pickupchan","playback","playtones",
                  "privacymanager","proceeding","progress","queue","queuelog","raiseexception","read","readexten",
                  "readfile","receivefax","receivefax","receivefax","record","removequeuemember",
                  "resetcdr","retrydial","return","ringing","sayalpha","saycountedadj","saycountednoun",
                  "saycountpl","saydigits","saynumber","sayphonetic","sayunixtime","senddtmf","sendfax",
                  "sendfax","sendfax","sendimage","sendtext","sendurl","set","setamaflags",
                  "setcallerpres","setmusiconhold","sipaddheader","sipdtmfmode","sipremoveheader","skel",
                  "slastation","slatrunk","sms","softhangup","speechactivategrammar","speechbackground",
                  "speechcreate","speechdeactivategrammar","speechdestroy","speechloadgrammar","speechprocessingsound",
                  "speechstart","speechunloadgrammar","stackpop","startmusiconhold","stopmixmonitor","stopmonitor",
                  "stopmusiconhold","stopplaytones","system","testclient","testserver","transfer","tryexec",
                  "trysystem","unpausemonitor","unpausequeuemember","userevent","verbose","vmauthenticate",
                  "vmsayname","voicemail","voicemailmain","wait","waitexten","waitfornoise","waitforring",
                  "waitforsilence","waitmusiconhold","waituntil","while","zapateller"
                 ];

  function basicToken(stream,state){
    var cur = '';
    var ch = stream.next();
    // comment
    if(ch == ";") {
      stream.skipToEnd();
      return "comment";
    }
    // context
    if(ch == '[') {
      stream.skipTo(']');
      stream.eat(']');
      return "header";
    }
    // string
    if(ch == '"') {
      stream.skipTo('"');
      return "string";
    }
    if(ch == "'") {
      stream.skipTo("'");
      return "string-2";
    }
    // dialplan commands
    if(ch == '#') {
      stream.eatWhile(/\w/);
      cur = stream.current();
      if(dpcmd.indexOf(cur) !== -1) {
        stream.skipToEnd();
        return "strong";
      }
    }
    // application args
    if(ch == '$'){
      var ch1 = stream.peek();
      if(ch1 == '{'){
        stream.skipTo('}');
        stream.eat('}' ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.brainfuck" id="apidoc.element.codemirror.modes.brainfuck">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>brainfuck
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">brainfuck = function () {
  return {
    startState: function() {
      return {
        commentLine: false,
        left: 0,
        right: 0,
        commentLoop: false
      }
    },
    token: function(stream, state) {
      if (stream.eatSpace()) return null
      if(stream.sol()){
        state.commentLine = false;
      }
      var ch = stream.next().toString();
      if(reserve.indexOf(ch) !== -1){
        if(state.commentLine === true){
          if(stream.eol()){
            state.commentLine = false;
          }
          return "comment";
        }
        if(ch === "]" || ch === "["){
          if(ch === "["){
            state.left++;
          }
          else{
            state.right++;
          }
          return "bracket";
        }
        else if(ch === "+" || ch === "-"){
          return "keyword";
        }
        else if(ch === "&lt;" || ch === "&gt;"){
          return "atom";
        }
        else if(ch === "." || ch === ","){
          return "def";
        }
      }
      else{
        state.commentLine = true;
        if(stream.eol()){
          state.commentLine = false;
        }
        return "comment";
      }
      if(stream.eol()){
        state.commentLine = false;
      }
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.clike" id="apidoc.element.codemirror.modes.clike">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>clike
        <span class="apidocSignatureSpan">(config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clike = function (config, parserConfig) {
  var indentUnit = config.indentUnit,
      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
      dontAlignCalls = parserConfig.dontAlignCalls,
      keywords = parserConfig.keywords || {},
      types = parserConfig.types || {},
      builtin = parserConfig.builtin || {},
      blockKeywords = parserConfig.blockKeywords || {},
      defKeywords = parserConfig.defKeywords || {},
      atoms = parserConfig.atoms || {},
      hooks = parserConfig.hooks || {},
      multiLineStrings = parserConfig.multiLineStrings,
      indentStatements = parserConfig.indentStatements !== false,
      indentSwitch = parserConfig.indentSwitch !== false,
      namespaceSeparator = parserConfig.namespaceSeparator,
      isPunctuationChar = parserConfig.isPunctuationChar || /[\[\]{}\(\),;\:\.]/,
      numberStart = parserConfig.numberStart || /[\d\.]/,
      number = parserConfig.number || /^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,
      isOperatorChar = parserConfig.isOperatorChar || /[+\-*&amp;%=&lt;&gt;!?|\/]/,
      isIdentifierChar = parserConfig.isIdentifierChar || /[\w\$_\xa1-\uffff]/;

  var curPunc, isDefKeyword;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (isPunctuationChar.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (numberStart.test(ch)) {
      stream.backUp(1)
      if (stream.match(number)) return "number"
      stream.next()
    }
    if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      while (!stream.match(/^\/[\/*]/, false) &amp;&amp; stream.eat(isOperatorChar)) {}
      return "operator";
    }
    stream.eatWhile(isIdentifierChar);
    if (namespaceSeparator) while (stream.match(namespaceSeparator))
      stream.eatWhile(isIdentifierChar);

    var cur = stream.current();
    if (contains(keywords, cur)) {
      if (contains(blockKeywords, cur)) curPunc = "newstatement";
      if (contains(defKeywords, cur)) isDefKeyword = true;
      return "keyword";
    }
    if (contains(types, cur)) return "variable-3";
    if (contains(builtin, cur)) {
      if (contains(blockKeywords, cur)) curPunc = "newstatement";
      return "builtin";
    }
    if (contains(atoms, cur)) return "atom";
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote &amp;&amp; !escaped) {end = true; break;}
        escaped = !escaped &amp;&amp; next == "\\";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = null;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" &amp;&amp; maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function maybeEOL(stream, state) {
    if (parserConfig.typeFirstDefinitions &amp;&amp; stream.eol() &amp;&amp; isTopScope(state.context))
      state.typeAtEndOfLine = typeBefore(stream, state, stream.pos)
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", null, false),
        indented: 0,
        startOfLine: true,
        prevToken: null
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (stream.ea ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.clojure" id="apidoc.element.codemirror.modes.clojure">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>clojure
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clojure = function (options) {
    var BUILTIN = "builtin", COMMENT = "comment", STRING = "string", CHARACTER = "string-2",
        ATOM = "atom", NUMBER = "number", BRACKET = "bracket", KEYWORD = "keyword", VAR = "variable";
    var INDENT_WORD_SKIP = options.indentUnit || 2;
    var NORMAL_INDENT_UNIT = options.indentUnit || 2;

    function makeKeywords(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i &lt; words.length; ++i) obj[words[i]] = true;
        return obj;
    }

    var atoms = makeKeywords("true false nil");

    var keywords = makeKeywords(
      "defn defn- def def- defonce defmulti defmethod defmacro defstruct deftype defprotocol defrecord defproject deftest " +
      "slice defalias defhinted defmacro- defn-memo defnk defnk defonce- defunbound defunbound- defvar defvar- let letfn " +
      "do case cond condp for loop recur when when-not when-let when-first if if-let if-not . .. -&gt; -&gt;&gt; doto and or dosync " +
      "doseq dotimes dorun doall load import unimport ns in-ns refer try catch finally throw with-open with-local-vars " +
      "binding gen-class gen-and-load-class gen-and-save-class handler-case handle");

    var builtins = makeKeywords(
        "* *' *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* *command-line-args* *compile-files* " +
        "*compile-path* *compiler-options* *data-readers* *e *err* *file* *flush-on-newline* *fn-loader* *in* " +
        "*math-context* *ns* *out* *print-dup* *print-length* *print-level* *print-meta* *print-readably* *read-eval* " +
        "*source-path* *unchecked-math* *use-context-classloader* *verbose-defrecords* *warn-on-reflection* + +' - -' -&gt; " +
        "-&gt;&gt; -&gt;ArrayChunk -&gt;Vec -&gt;VecNode -&gt;VecSeq -cache-protocol-fn -reset-methods .. / &lt; &lt;= = == &gt; &gt;= EMPTY-NODE accessor " +
        "aclone add-classpath add-watch agent agent-error agent-errors aget alength alias all-ns alter alter-meta! " +
        "alter-var-root amap ancestors and apply areduce array-map aset aset-boolean aset-byte aset-char aset-double " +
        "aset-float aset-int aset-long aset-short assert assoc assoc! assoc-in associative? atom await await-for await1 " +
        "bases bean bigdec bigint biginteger binding bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set " +
        "bit-shift-left bit-shift-right bit-test bit-xor boolean boolean-array booleans bound-fn bound-fn* bound? butlast " +
        "byte byte-array bytes case cat cast char char-array char-escape-string char-name-string char? chars chunk chunk-append " +
        "chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? class class? clear-agent-errors " +
        "clojure-version coll? comment commute comp comparator compare compare-and-set! compile complement completing concat cond
 condp " +
        "conj conj! cons constantly construct-proxy contains? count counted? create-ns create-struct cycle dec dec' decimal? " +
        "declare dedupe default-data-readers definline definterface defmacro defmethod defmulti defn defn- defonce defprotocol " +
        "defrecord defstruct deftype delay delay? deliver denominator deref derive descendants destructure disj disj! dissoc " +
        "dissoc! distinct distinct? doall dorun doseq dosync dotimes doto double double-array doubles drop drop-last " +
        "drop-while eduction empty empty? ensure enumeration-seq error-handler error-mode eval even? every-pred every? ex-data ex
-info " +
        "extend extend-protocol extend-type extenders extends? false? ffirst file-seq filter filterv find find-keyword " +
        "find-ns find-protocol-impl find-protocol-method find-var first flatten float float-array float? floats flush fn fn? " +
        "fnext fnil for force format frequencies future future-call future-cancel future-cancelled? future-done? future? " +
        "gen-class gen-interface gensym get get-in get-method get-proxy-class get-thread-bindings get-validator group-by hash " +
        "hash-combine hash-map hash-set identical? identity if-let if-not ifn? import in-ns inc inc' init-proxy instance? " + ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.cmake" id="apidoc.element.codemirror.modes.cmake">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>cmake
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cmake = function () {
  var variable_regex = /({)?[a-zA-Z0-9_]+(})?/;

  function tokenString(stream, state) {
    var current, prev, found_var = false;
    while (!stream.eol() &amp;&amp; (current = stream.next()) != state.pending) {
      if (current === '$' &amp;&amp; prev != '\\' &amp;&amp; state.pending == '"') {
        found_var = true;
        break;
      }
      prev = current;
    }
    if (found_var) {
      stream.backUp(1);
    }
    if (current == state.pending) {
      state.continueString = false;
    } else {
      state.continueString = true;
    }
    return "string";
  }

  function tokenize(stream, state) {
    var ch = stream.next();

    // Have we found a variable?
    if (ch === '$') {
      if (stream.match(variable_regex)) {
        return 'variable-2';
      }
      return 'variable';
    }
    // Should we still be looking for the end of a string?
    if (state.continueString) {
      // If so, go through the loop again
      stream.backUp(1);
      return tokenString(stream, state);
    }
    // Do we just have a function on our hands?
    // In 'cmake_minimum_required (VERSION 2.8.8)', 'cmake_minimum_required' is matched
    if (stream.match(/(\s+)?\w+\(/) || stream.match(/(\s+)?\w+\ \(/)) {
      stream.backUp(1);
      return 'def';
    }
    if (ch == "#") {
      stream.skipToEnd();
      return "comment";
    }
    // Have we found a string?
    if (ch == "'" || ch == '"') {
      // Store the type (single or double)
      state.pending = ch;
      // Perform the looping function to find the end
      return tokenString(stream, state);
    }
    if (ch == '(' || ch == ')') {
      return 'bracket';
    }
    if (ch.match(/[0-9]/)) {
      return 'number';
    }
    stream.eatWhile(/[\w-]/);
    return null;
  }
  return {
    startState: function () {
      var state = {};
      state.inDefinition = false;
      state.inInclude = false;
      state.continueString = false;
      state.pending = false;
      return state;
    },
    token: function (stream, state) {
      if (stream.eatSpace()) return null;
      return tokenize(stream, state);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.cobol" id="apidoc.element.codemirror.modes.cobol">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>cobol
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cobol = function () {
  var BUILTIN = "builtin", COMMENT = "comment", STRING = "string",
      ATOM = "atom", NUMBER = "number", KEYWORD = "keyword", MODTAG = "header",
      COBOLLINENUM = "def", PERIOD = "link";
  function makeKeywords(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i &lt; words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var atoms = makeKeywords("TRUE FALSE ZEROES ZEROS ZERO SPACES SPACE LOW-VALUE LOW-VALUES ");
  var keywords = makeKeywords(
      "ACCEPT ACCESS ACQUIRE ADD ADDRESS " +
      "ADVANCING AFTER ALIAS ALL ALPHABET " +
      "ALPHABETIC ALPHABETIC-LOWER ALPHABETIC-UPPER ALPHANUMERIC ALPHANUMERIC-EDITED " +
      "ALSO ALTER ALTERNATE AND ANY " +
      "ARE AREA AREAS ARITHMETIC ASCENDING " +
      "ASSIGN AT ATTRIBUTE AUTHOR AUTO " +
      "AUTO-SKIP AUTOMATIC B-AND B-EXOR B-LESS " +
      "B-NOT B-OR BACKGROUND-COLOR BACKGROUND-COLOUR BEEP " +
      "BEFORE BELL BINARY BIT BITS " +
      "BLANK BLINK BLOCK BOOLEAN BOTTOM " +
      "BY CALL CANCEL CD CF " +
      "CH CHARACTER CHARACTERS CLASS CLOCK-UNITS " +
      "CLOSE COBOL CODE CODE-SET COL " +
      "COLLATING COLUMN COMMA COMMIT COMMITMENT " +
      "COMMON COMMUNICATION COMP COMP-0 COMP-1 " +
      "COMP-2 COMP-3 COMP-4 COMP-5 COMP-6 " +
      "COMP-7 COMP-8 COMP-9 COMPUTATIONAL COMPUTATIONAL-0 " +
      "COMPUTATIONAL-1 COMPUTATIONAL-2 COMPUTATIONAL-3 COMPUTATIONAL-4 COMPUTATIONAL-5 " +
      "COMPUTATIONAL-6 COMPUTATIONAL-7 COMPUTATIONAL-8 COMPUTATIONAL-9 COMPUTE " +
      "CONFIGURATION CONNECT CONSOLE CONTAINED CONTAINS " +
      "CONTENT CONTINUE CONTROL CONTROL-AREA CONTROLS " +
      "CONVERTING COPY CORR CORRESPONDING COUNT " +
      "CRT CRT-UNDER CURRENCY CURRENT CURSOR " +
      "DATA DATE DATE-COMPILED DATE-WRITTEN DAY " +
      "DAY-OF-WEEK DB DB-ACCESS-CONTROL-KEY DB-DATA-NAME DB-EXCEPTION " +
      "DB-FORMAT-NAME DB-RECORD-NAME DB-SET-NAME DB-STATUS DBCS " +
      "DBCS-EDITED DE DEBUG-CONTENTS DEBUG-ITEM DEBUG-LINE " +
      "DEBUG-NAME DEBUG-SUB-1 DEBUG-SUB-2 DEBUG-SUB-3 DEBUGGING " +
      "DECIMAL-POINT DECLARATIVES DEFAULT DELETE DELIMITED " +
      "DELIMITER DEPENDING DESCENDING DESCRIBED DESTINATION " +
      "DETAIL DISABLE DISCONNECT DISPLAY DISPLAY-1 " +
      "DISPLAY-2 DISPLAY-3 DISPLAY-4 DISPLAY-5 DISPLAY-6 " +
      "DISPLAY-7 DISPLAY-8 DISPLAY-9 DIVIDE DIVISION " +
      "DOWN DROP DUPLICATE DUPLICATES DYNAMIC " +
      "EBCDIC EGI EJECT ELSE EMI " +
      "EMPTY EMPTY-CHECK ENABLE END END. END-ACCEPT END-ACCEPT. " +
      "END-ADD END-CALL END-COMPUTE END-DELETE END-DISPLAY " +
      "END-DIVIDE END-EVALUATE END-IF END-INVOKE END-MULTIPLY " +
      "END-OF-PAGE END-PERFORM END-READ END-RECEIVE END-RETURN " +
      "END-REWRITE END-SEARCH END-START END-STRING END-SUBTRACT " +
      "END-UNSTRING END-WRITE END-XML ENTER ENTRY " +
      "ENVIRONMENT EOP EQUAL EQUALS ERASE " +
      "ERROR ESI EVALUATE EVERY EXCEEDS " +
      "EXCEPTION EXCLUSIVE EXIT EXTEND EXTERNAL " +
      "EXTERNALLY-DESCRIBED-KEY FD FETCH FILE FILE-CONTROL " +
      "FILE-STREAM FILES FILLER FINAL FIND " +
      "FINISH FIRST FOOTING FOR FOREGROUND-COLOR " +
      "FOREGROUND-COLOUR FORMAT FREE FROM FULL " +
      "FUNCTION GENERATE GET GIVING GLOBAL " +
      "GO GOBACK GREATER GROUP HEADING " +
      "HIGH-VALUE HIGH-VALUES HIGHLIGHT I-O I-O-CONTROL " +
      "ID IDENTIFICATION IF IN INDEX " +
      "INDEX-1 INDEX-2 INDEX-3 INDEX-4 INDEX-5 " +
      "INDEX-6 INDEX-7 INDEX-8 INDEX-9 INDEXED " +
      "INDIC INDICATE INDICATOR INDICATORS INITIAL " +
      "INITIALIZE INITIATE INPUT INPUT-OUTPUT INSPECT " +
      "INSTALLATION INTO INVALID INVOKE IS " +
      "JUST JUSTIFIED KANJI KEEP KEY " +
      "LABEL LAST LD LEADING LEFT " +
      "LEFT-JUSTIFY LENGTH LENGTH-CHECK LESS LIBRARY " +
      "LIKE LIMIT LIMITS LINAGE LINAGE-COUNTER " +
      "LINE LINE-COUNTER LINES LINKAGE LOCAL-STORAGE " +
      "LOCALE LOCALLY LOCK " +
      "MEMBER MEMORY MERGE MESSAGE METACLASS " +
      "MODE MODIFIED MODIFY MODULES MOVE " +
      "MULTIPLE MULTIPLY NATIONAL NATIVE NEGATIVE " +
      "NEXT NO NO-ECHO NONE NOT " + ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.coffeescript" id="apidoc.element.codemirror.modes.coffeescript">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>coffeescript
        <span class="apidocSignatureSpan">(conf, parserConf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coffeescript = function (conf, parserConf) {
  var ERRORCLASS = "error";

  function wordRegexp(words) {
    return new RegExp("^((" + words.join(")|(") + "))\\b");
  }

  var operators = /^(?:-&gt;|=&gt;|\+[+=]?|-[\-=]?|\*[\*=]?|\/[\/=]?|[=!]=|&lt;[&gt;&lt;]?=?|&gt;&gt;?=?|%=?|&amp;=?|\|=?|\^=?|\~|!|\?|(or|and|\|\||&amp;&amp;|\?)=)/;
  var delimiters = /^(?:[()\[\]{},:`=;]|\.\.?\.?)/;
  var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;
  var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;

  var wordOperators = wordRegexp(["and", "or", "not",
                                  "is", "isnt", "in",
                                  "instanceof", "typeof"]);
  var indentKeywords = ["for", "while", "loop", "if", "unless", "else",
                        "switch", "try", "catch", "finally", "class"];
  var commonKeywords = ["break", "by", "continue", "debugger", "delete",
                        "do", "in", "of", "new", "return", "then",
                        "this", "@", "throw", "when", "until", "extends"];

  var keywords = wordRegexp(indentKeywords.concat(commonKeywords));

  indentKeywords = wordRegexp(indentKeywords);


  var stringPrefixes = /^('{3}|\"{3}|['\"])/;
  var regexPrefixes = /^(\/{3}|\/)/;
  var commonConstants = ["Infinity", "NaN", "undefined", "null", "true", "false", "on", "off", "yes", "no"];
  var constants = wordRegexp(commonConstants);

  // Tokenizers
  function tokenBase(stream, state) {
    // Handle scope changes
    if (stream.sol()) {
      if (state.scope.align === null) state.scope.align = false;
      var scopeOffset = state.scope.offset;
      if (stream.eatSpace()) {
        var lineOffset = stream.indentation();
        if (lineOffset &gt; scopeOffset &amp;&amp; state.scope.type == "coffee") {
          return "indent";
        } else if (lineOffset &lt; scopeOffset) {
          return "dedent";
        }
        return null;
      } else {
        if (scopeOffset &gt; 0) {
          dedent(stream, state);
        }
      }
    }
    if (stream.eatSpace()) {
      return null;
    }

    var ch = stream.peek();

    // Handle docco title comment (single line)
    if (stream.match("####")) {
      stream.skipToEnd();
      return "comment";
    }

    // Handle multi line comments
    if (stream.match("###")) {
      state.tokenize = longComment;
      return state.tokenize(stream, state);
    }

    // Single line comment
    if (ch === "#") {
      stream.skipToEnd();
      return "comment";
    }

    // Handle number literals
    if (stream.match(/^-?[0-9\.]/, false)) {
      var floatLiteral = false;
      // Floats
      if (stream.match(/^-?\d*\.\d+(e[\+\-]?\d+)?/i)) {
        floatLiteral = true;
      }
      if (stream.match(/^-?\d+\.\d*/)) {
        floatLiteral = true;
      }
      if (stream.match(/^-?\.\d+/)) {
        floatLiteral = true;
      }

      if (floatLiteral) {
        // prevent from getting extra . on 1..
        if (stream.peek() == "."){
          stream.backUp(1);
        }
        return "number";
      }
      // Integers
      var intLiteral = false;
      // Hex
      if (stream.match(/^-?0x[0-9a-f]+/i)) {
        intLiteral = true;
      }
      // Decimal
      if (stream.match(/^-?[1-9]\d*(e[\+\-]?\d+)?/)) {
        intLiteral = true;
      }
      // Zero by itself with no other piece of number.
      if (stream.match(/^-?0(?![\dx])/i)) {
        intLiteral = true;
      }
      if (intLiteral) {
        return "number";
      }
    }

    // Handle strings
    if (stream.match(stringPrefixes)) {
      state.tokenize = tokenFactory(stream.current(), false, "string");
      return state.tokenize(stream, state);
    }
    // Handle regex literals
    if (stream.match(regexPrefixes)) {
      if (stream.current() != "/" || stream.match(/^.*\//, false)) { // prevent highlight of division
        state.tokenize = tokenFactory(stream.current(), true, "string-2");
        return state.tokenize(stream, state);
      } else {
        stream.backUp(1);
      }
    }



    // Handle operators and delimiters
    if (stream.match(operators) || stream.match(wordOperators)) {
      return "operator";
    }
    if (stream.match(delimiters) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.commonlisp" id="apidoc.element.codemirror.modes.commonlisp">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>commonlisp
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commonlisp = function (config) {
  var specialForm = /^(block|let*|return-from|catch|load-time-value|setq|eval-when|locally|symbol-macrolet|flet|macrolet|tagbody
|function|multiple-value-call|the|go|multiple-value-prog1|throw|if|progn|unwind-protect|labels|progv|let|quote)$/;
  var assumeBody = /^with|^def|^do|^prog|case$|^cond$|bind$|when$|unless$/;
  var numLiteral = /^(?:[+\-]?(?:\d+|\d*\.\d+)(?:[efd][+\-]?\d+)?|[+\-]?\d+(?:\/[+\-]?\d+)?|#b[+\-]?[01]+|#o[+\-]?[0-7]+|#x[+\-]?[\da-f]+)/;
  var symbol = /[^\s'`,@()\[\]";]/;
  var type;

  function readSym(stream) {
    var ch;
    while (ch = stream.next()) {
      if (ch == "\\") stream.next();
      else if (!symbol.test(ch)) { stream.backUp(1); break; }
    }
    return stream.current();
  }

  function base(stream, state) {
    if (stream.eatSpace()) {type = "ws"; return null;}
    if (stream.match(numLiteral)) return "number";
    var ch = stream.next();
    if (ch == "\\") ch = stream.next();

    if (ch == '"') return (state.tokenize = inString)(stream, state);
    else if (ch == "(") { type = "open"; return "bracket"; }
    else if (ch == ")" || ch == "]") { type = "close"; return "bracket"; }
    else if (ch == ";") { stream.skipToEnd(); type = "ws"; return "comment"; }
    else if (/['`,@]/.test(ch)) return null;
    else if (ch == "|") {
      if (stream.skipTo("|")) { stream.next(); return "symbol"; }
      else { stream.skipToEnd(); return "error"; }
    } else if (ch == "#") {
      var ch = stream.next();
      if (ch == "(") { type = "open"; return "bracket"; }
      else if (/[+\-=\.']/.test(ch)) return null;
      else if (/\d/.test(ch) &amp;&amp; stream.match(/^\d*#/)) return null;
      else if (ch == "|") return (state.tokenize = inComment)(stream, state);
      else if (ch == ":") { readSym(stream); return "meta"; }
      else if (ch == "\\") { stream.next(); readSym(stream); return "string-2" }
      else return "error";
    } else {
      var name = readSym(stream);
      if (name == ".") return null;
      type = "symbol";
      if (name == "nil" || name == "t" || name.charAt(0) == ":") return "atom";
      if (state.lastType == "open" &amp;&amp; (specialForm.test(name) || assumeBody.test(name))) return "keyword";
      if (name.charAt(0) == "&amp;") return "variable-2";
      return "variable";
    }
  }

  function inString(stream, state) {
    var escaped = false, next;
    while (next = stream.next()) {
      if (next == '"' &amp;&amp; !escaped) { state.tokenize = base; break; }
      escaped = !escaped &amp;&amp; next == "\\";
    }
    return "string";
  }

  function inComment(stream, state) {
    var next, last;
    while (next = stream.next()) {
      if (next == "#" &amp;&amp; last == "|") { state.tokenize = base; break; }
      last = next;
    }
    type = "ws";
    return "comment";
  }

  return {
    startState: function () {
      return {ctx: {prev: null, start: 0, indentTo: 0}, lastType: null, tokenize: base};
    },

    token: function (stream, state) {
      if (stream.sol() &amp;&amp; typeof state.ctx.indentTo != "number")
        state.ctx.indentTo = state.ctx.start + 1;

      type = null;
      var style = state.tokenize(stream, state);
      if (type != "ws") {
        if (state.ctx.indentTo == null) {
          if (type == "symbol" &amp;&amp; assumeBody.test(stream.current()))
            state.ctx.indentTo = state.ctx.start + config.indentUnit;
          else
            state.ctx.indentTo = "next";
        } else if (state.ctx.indentTo == "next") {
          state.ctx.indentTo = stream.column();
        }
        state.lastType = type;
      }
      if (type == "open") state.ctx = {prev: state.ctx, start: stream.column(), indentTo: null};
      else if (type == "close") state.ctx = state.ctx.prev || state.ctx;
      return style;
    },

    indent: function (state, _textAfter) {
      var i = state.ctx.indentTo;
      return typeof i == "number" ? i : state.ctx.start + 1;
    },

    closeBrackets: {pairs: "()[]{}\"\""},
    lineComment: ";;",
    blockCommentStart: "#|",
    blockCommentEnd: "|#"
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.crystal" id="apidoc.element.codemirror.modes.crystal">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>crystal
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">crystal = function (config) {
  function wordRegExp(words, end) {
    return new RegExp((end ? "" : "^") + "(?:" + words.join("|") + ")" + (end ? "$" : "\\b"));
  }

  function chain(tokenize, stream, state) {
    state.tokenize.push(tokenize);
    return tokenize(stream, state);
  }

  var operators = /^(?:[-+/%|&amp;^]|\*\*?|[&lt;&gt;]{2})/;
  var conditionalOperators = /^(?:[=!]~|===|&lt;=&gt;|[&lt;&gt;=!]=?|[|&amp;]{2}|~)/;
  var indexingOperators = /^(?:\[\][?=]?)/;
  var anotherOperators = /^(?:\.(?:\.{2})?|-&gt;|[?:])/;
  var idents = /^[a-z_\u009F-\uFFFF][a-zA-Z0-9_\u009F-\uFFFF]*/;
  var types = /^[A-Z_\u009F-\uFFFF][a-zA-Z0-9_\u009F-\uFFFF]*/;
  var keywords = wordRegExp([
    "abstract", "alias", "as", "asm", "begin", "break", "case", "class", "def", "do",
    "else", "elsif", "end", "ensure", "enum", "extend", "for", "fun", "if",
    "include", "instance_sizeof", "lib", "macro", "module", "next", "of", "out", "pointerof",
    "private", "protected", "rescue", "return", "require", "select", "sizeof", "struct",
    "super", "then", "type", "typeof", "uninitialized", "union", "unless", "until", "when", "while", "with",
    "yield", "__DIR__", "__END_LINE__", "__FILE__", "__LINE__"
  ]);
  var atomWords = wordRegExp(["true", "false", "nil", "self"]);
  var indentKeywordsArray = [
    "def", "fun", "macro",
    "class", "module", "struct", "lib", "enum", "union",
    "do", "for"
  ];
  var indentKeywords = wordRegExp(indentKeywordsArray);
  var indentExpressionKeywordsArray = ["if", "unless", "case", "while", "until", "begin", "then"];
  var indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);
  var dedentKeywordsArray = ["end", "else", "elsif", "rescue", "ensure"];
  var dedentKeywords = wordRegExp(dedentKeywordsArray);
  var dedentPunctualsArray = ["\\)", "\\}", "\\]"];
  var dedentPunctuals = new RegExp("^(?:" + dedentPunctualsArray.join("|") + ")$");
  var nextTokenizer = {
    "def": tokenFollowIdent, "fun": tokenFollowIdent, "macro": tokenMacroDef,
    "class": tokenFollowType, "module": tokenFollowType, "struct": tokenFollowType,
    "lib": tokenFollowType, "enum": tokenFollowType, "union": tokenFollowType
  };
  var matching = {"[": "]", "{": "}", "(": ")", "&lt;": "&gt;"};

  function tokenBase(stream, state) {
    if (stream.eatSpace()) {
      return null;
    }

    // Macros
    if (state.lastToken != "\\" &amp;&amp; stream.match("{%", false)) {
      return chain(tokenMacro("%", "%"), stream, state);
    }

    if (state.lastToken != "\\" &amp;&amp; stream.match("{{", false)) {
      return chain(tokenMacro("{", "}"), stream, state);
    }

    // Comments
    if (stream.peek() == "#") {
      stream.skipToEnd();
      return "comment";
    }

    // Variables and keywords
    var matched;
    if (stream.match(idents)) {
      stream.eat(/[?!]/);

      matched = stream.current();
      if (stream.eat(":")) {
        return "atom";
      } else if (state.lastToken == ".") {
        return "property";
      } else if (keywords.test(matched)) {
        if (indentKeywords.test(matched)) {
          if (!(matched == "fun" &amp;&amp; state.blocks.indexOf("lib") &gt;= 0) &amp;&amp; !(matched == "def" &amp;&amp; state.lastToken == "abstract")) {
            state.blocks.push(matched);
            state.currentIndent += 1;
          }
        } else if ((state.lastStyle == "operator" || !state.lastStyle) &amp;&amp; indentExpressionKeywords.test(matched)) {
          state.blocks.push(matched);
          state.currentIndent += 1;
        } else if (matched == "end") {
          state.blocks.pop();
          state.currentIndent -= 1;
        }

        if (nextTokenizer.hasOwnProperty(matched)) {
          state.tokenize.push(nextTokenizer[matched]);
        }

        return "keyword";
      } else if (atomWords.test(matched)) {
        return "atom";
      }

      return "variable";
    }

    // Class variables and instance variables
    // or attributes
    if (stream.eat("@")) {
      if (stream.peek() == "[") {
        return chain(tokenNest("[", "]", "meta"), stream, state);
      }

      stream.eat("@");
      stream.match(idents) || stream.match(types);
      return "variable- ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.css" id="apidoc.element.codemirror.modes.css">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>css
        <span class="apidocSignatureSpan">(config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">css = function (config, parserConfig) {
  var inline = parserConfig.inline
  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

  var indentUnit = config.indentUnit,
      tokenHooks = parserConfig.tokenHooks,
      documentTypes = parserConfig.documentTypes || {},
      mediaTypes = parserConfig.mediaTypes || {},
      mediaFeatures = parserConfig.mediaFeatures || {},
      mediaValueKeywords = parserConfig.mediaValueKeywords || {},
      propertyKeywords = parserConfig.propertyKeywords || {},
      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
      fontProperties = parserConfig.fontProperties || {},
      counterDescriptors = parserConfig.counterDescriptors || {},
      colorKeywords = parserConfig.colorKeywords || {},
      valueKeywords = parserConfig.valueKeywords || {},
      allowNested = parserConfig.allowNested,
      lineComment = parserConfig.lineComment,
      supportsAtComponent = parserConfig.supportsAtComponent === true;

  var type, override;
  function ret(style, tp) { type = tp; return style; }

  // Tokenizers

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (tokenHooks[ch]) {
      var result = tokenHooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == "@") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("def", stream.current());
    } else if (ch == "=" || (ch == "~" || ch == "|") &amp;&amp; stream.eat("=")) {
      return ret(null, "compare");
    } else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "#") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("atom", "hash");
    } else if (ch == "!") {
      stream.match(/^\s*\w*/);
      return ret("keyword", "important");
    } else if (/\d/.test(ch) || ch == "." &amp;&amp; stream.eat(/\d/)) {
      stream.eatWhile(/[\w.%]/);
      return ret("number", "unit");
    } else if (ch === "-") {
      if (/[\d.]/.test(stream.peek())) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (stream.match(/^-[\w\\\-]+/)) {
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ret("variable-2", "variable-definition");
        return ret("variable-2", "variable");
      } else if (stream.match(/^\w+-/)) {
        return ret("meta", "meta");
      }
    } else if (/[,+&gt;*\/]/.test(ch)) {
      return ret(null, "select-op");
    } else if (ch == "." &amp;&amp; stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
      return ret("qualifier", "qualifier");
    } else if (/[:;{}\[\]\(\)]/.test(ch)) {
      return ret(null, ch);
    } else if ((ch == "u" &amp;&amp; stream.match(/rl(-prefix)?\(/)) ||
               (ch == "d" &amp;&amp; stream.match("omain(")) ||
               (ch == "r" &amp;&amp; stream.match("egexp("))) {
      stream.backUp(1);
      state.tokenize = tokenParenthesized;
      return ret("property", "word");
    } else if (/[\w\\\-]/.test(ch)) {
      stream.eatWhile(/[\w\\\-]/);
      return ret("property", "word");
    } else {
      return ret(null, null);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote &amp;&amp; !escaped) {
          if (quote == ")") stream.backUp(1);
          break;
        }
        escaped = !escaped &amp;&amp; ch == "\\";
      }
      if (ch == quote || !escaped &amp;&amp; quote != ")") state.tokenize = null;
      return ret("string", "string");
    };
  }

  function tokenParenthesized(stream, state) {
    stream.next(); // Must be '('
    if (!stream.match(/\s*[\"\')]/, false))
      state.tokenize = tokenString(")");
    else
      state.tokenize = null;
    return ret(null, "(");
  }

  // Context management

  function Context(type, indent, prev) {
    this.type = type;
    this.indent = indent;
    this.prev = prev;
  }

  function pushContext(state, stream, type, indent) {
    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), s ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.cypher" id="apidoc.element.codemirror.modes.cypher">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>cypher
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cypher = function (config) {
  var tokenBase = function(stream/*, state*/) {
    var ch = stream.next();
    if (ch ==='"') {
      stream.match(/.*?"/);
      return "string";
    }
    if (ch === "'") {
      stream.match(/.*?'/);
      return "string";
    }
    if (/[{}\(\),\.;\[\]]/.test(ch)) {
      curPunc = ch;
      return "node";
    } else if (ch === "/" &amp;&amp; stream.eat("/")) {
      stream.skipToEnd();
      return "comment";
    } else if (operatorChars.test(ch)) {
      stream.eatWhile(operatorChars);
      return null;
    } else {
      stream.eatWhile(/[_\w\d]/);
      if (stream.eat(":")) {
        stream.eatWhile(/[\w\d_\-]/);
        return "atom";
      }
      var word = stream.current();
      if (funcs.test(word)) return "builtin";
      if (preds.test(word)) return "def";
      if (keywords.test(word)) return "keyword";
      return "variable";
    }
  };
  var pushContext = function(state, type, col) {
    return state.context = {
      prev: state.context,
      indent: state.indent,
      col: col,
      type: type
    };
  };
  var popContext = function(state) {
    state.indent = state.context.indent;
    return state.context = state.context.prev;
  };
  var indentUnit = config.indentUnit;
  var curPunc;
  var funcs = wordRegexp(["abs", "acos", "allShortestPaths", "asin", "atan", "atan2", "avg", "ceil", "coalesce", "collect", "cos
", "cot", "count", "degrees", "e", "endnode", "exp", "extract", "filter", "floor", "haversin", "head", "id", "keys", "labels", "
last", "left", "length", "log", "log10", "lower", "ltrim", "max", "min", "node", "nodes", "percentileCont", "percentileDisc", "pi
", "radians", "rand", "range", "reduce", "rel", "relationship", "relationships", "replace", "reverse", "right", "round", "rtrim", "
shortestPath", "sign", "sin", "size", "split", "sqrt", "startnode", "stdev", "stdevp", "str", "substring", "sum", "tail", "tan", "
timestamp", "toFloat", "toInt", "toString", "trim", "type", "upper"]);
  var preds = wordRegexp(["all", "and", "any", "contains", "exists", "has", "in", "none", "not", "or", "single", "xor"]);
  var keywords = wordRegexp(["as", "asc", "ascending", "assert", "by", "case", "commit", "constraint", "create", "csv", "cypher", "
delete", "desc", "descending", "detach", "distinct", "drop", "else", "end", "ends", "explain", "false", "fieldterminator", "foreach
", "from", "headers", "in", "index", "is", "join", "limit", "load", "match", "merge", "null", "on", "optional", "order", "periodic
", "profile", "remove", "return", "scan", "set", "skip", "start", "starts", "then", "true", "union", "unique", "unwind", "using", "
when", "where", "with", "call", "yield"]);
  var operatorChars = /[*+\-&lt;&gt;=&amp;|~%^]/;

  return {
    startState: function(/*base*/) {
      return {
        tokenize: tokenBase,
        context: null,
        indent: 0,
        col: 0
      };
    },
    token: function(stream, state) {
      if (stream.sol()) {
        if (state.context &amp;&amp; (state.context.align == null)) {
          state.context.align = false;
        }
        state.indent = stream.indentation();
      }
      if (stream.eatSpace()) {
        return null;
      }
      var style = state.tokenize(stream, state);
      if (style !== "comment" &amp;&amp; state.context &amp;&amp; (state.context.align == null) &amp;&amp; state.context.type !== "pattern") {
        state.context.align = true;
      }
      if (curPunc === "(") {
        pushContext(state, ")", stream.column());
      } else if (curPunc === "[") {
        pushContext(state, "]", stream.column());
      } else if (curPunc === "{") {
        pushContext(state, "}", stream.column());
      } else if (/[\]\}\)]/.test(curPunc)) {
        while (state.context &amp;&amp; state.context.type === "pattern") {
          popContext(state);
        }
        if (state.context &amp;&amp; curPunc === state.context.type) {
          popContext(state);
        }
      } else if (curPunc === "." &amp;&amp; state.context &amp;&amp; state.context.type === "pattern") {
        popContext(state);
      } else if (/atom|string|variable/.test(style) &amp;&amp; state.context) {
        if (/[\}\]]/.test(state.context.t ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.d" id="apidoc.element.codemirror.modes.d">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>d
        <span class="apidocSignatureSpan">(config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">d = function (config, parserConfig) {
  var indentUnit = config.indentUnit,
      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
      keywords = parserConfig.keywords || {},
      builtin = parserConfig.builtin || {},
      blockKeywords = parserConfig.blockKeywords || {},
      atoms = parserConfig.atoms || {},
      hooks = parserConfig.hooks || {},
      multiLineStrings = parserConfig.multiLineStrings;
  var isOperatorChar = /[+\-*&amp;%=&lt;&gt;!?|\/]/;

  var curPunc;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == '"' || ch == "'" || ch == "`") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    if (ch == "/") {
      if (stream.eat("+")) {
        state.tokenize = tokenComment;
        return tokenNestedComment(stream, state);
      }
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_\xa1-\uffff]/);
    var cur = stream.current();
    if (keywords.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "keyword";
    }
    if (builtin.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "builtin";
    }
    if (atoms.propertyIsEnumerable(cur)) return "atom";
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote &amp;&amp; !escaped) {end = true; break;}
        escaped = !escaped &amp;&amp; next == "\\";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = null;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" &amp;&amp; maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function tokenNestedComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" &amp;&amp; maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "+");
    }
    return "comment";
  }

  function Context(indented, column, type, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.align = align;
    this.prev = prev;
  }
  function pushContext(state, col, type) {
    var indent = state.indented;
    if (state.context &amp;&amp; state.context.type == "statement")
      indent = state.context.indented;
    return state.context = new Context(indent, col, type, null, state.context);
  }
  function popContext(state) {
    var t = state.context.type;
    if (t == ")" || t == "]" || t == "}")
      state.indented = state.context.indented;
    return state.context = state.context.prev;
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
        indented: 0,
        startOfLine: true
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (stream.eatSpace()) return null;
      curPunc = null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style = ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.dart" id="apidoc.element.codemirror.modes.dart">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>dart
        <span class="apidocSignatureSpan">(conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dart = function (conf) {
  return CodeMirror.getMode(conf, "application/dart");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.diff" id="apidoc.element.codemirror.modes.diff">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>diff
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">diff = function () {

  var TOKEN_NAMES = {
    '+': 'positive',
    '-': 'negative',
    '@': 'meta'
  };

  return {
    token: function(stream) {
      var tw_pos = stream.string.search(/[\t ]+?$/);

      if (!stream.sol() || tw_pos === 0) {
        stream.skipToEnd();
        return ("error " + (
          TOKEN_NAMES[stream.string.charAt(0)] || '')).replace(/ $/, '');
      }

      var token_name = TOKEN_NAMES[stream.peek()] || stream.skipToEnd();

      if (tw_pos === -1) {
        stream.skipToEnd();
      } else {
        stream.pos = tw_pos;
      }

      return token_name;
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.django" id="apidoc.element.codemirror.modes.django">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>django
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">django = function (config) {
  var htmlBase = CodeMirror.getMode(config, "text/html");
  var djangoInner = CodeMirror.getMode(config, "django:inner");
  return CodeMirror.overlayMode(htmlBase, djangoInner);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.dockerfile" id="apidoc.element.codemirror.modes.dockerfile">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>dockerfile
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dockerfile = function (config) {
  return CodeMirror.simpleMode(config, states);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.dtd" id="apidoc.element.codemirror.modes.dtd">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>dtd
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dtd = function (config) {
  var indentUnit = config.indentUnit, type;
  function ret(style, tp) {type = tp; return style;}

  function tokenBase(stream, state) {
    var ch = stream.next();

    if (ch == "&lt;" &amp;&amp; stream.eat("!") ) {
      if (stream.eatWhile(/[\-]/)) {
        state.tokenize = tokenSGMLComment;
        return tokenSGMLComment(stream, state);
      } else if (stream.eatWhile(/[\w]/)) return ret("keyword", "doindent");
    } else if (ch == "&lt;" &amp;&amp; stream.eat("?")) { //xml declaration
      state.tokenize = inBlock("meta", "?&gt;");
      return ret("meta", ch);
    } else if (ch == "#" &amp;&amp; stream.eatWhile(/[\w]/)) return ret("atom", "tag");
    else if (ch == "|") return ret("keyword", "seperator");
    else if (ch.match(/[\(\)\[\]\-\.,\+\?&gt;]/)) return ret(null, ch);//if(ch === "&gt;") return ret(null, "endtag"); else
    else if (ch.match(/[\[\]]/)) return ret("rule", ch);
    else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (stream.eatWhile(/[a-zA-Z\?\+\d]/)) {
      var sc = stream.current();
      if( sc.substr(sc.length-1,sc.length).match(/\?|\+/) !== null )stream.backUp(1);
      return ret("tag", "tag");
    } else if (ch == "%" || ch == "*" ) return ret("number", "number");
    else {
      stream.eatWhile(/[\w\\\-_%.{,]/);
      return ret(null, null);
    }
  }

  function tokenSGMLComment(stream, state) {
    var dashes = 0, ch;
    while ((ch = stream.next()) != null) {
      if (dashes &gt;= 2 &amp;&amp; ch == "&gt;") {
        state.tokenize = tokenBase;
        break;
      }
      dashes = (ch == "-") ? dashes + 1 : 0;
    }
    return ret("comment", "comment");
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote &amp;&amp; !escaped) {
          state.tokenize = tokenBase;
          break;
        }
        escaped = !escaped &amp;&amp; ch == "\\";
      }
      return ret("string", "tag");
    };
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = tokenBase;
          break;
        }
        stream.next();
      }
      return style;
    };
  }

  return {
    startState: function(base) {
      return {tokenize: tokenBase,
              baseIndent: base || 0,
              stack: []};
    },

    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);

      var context = state.stack[state.stack.length-1];
      if (stream.current() == "[" || type === "doindent" || type == "[") state.stack.push("rule");
      else if (type === "endtag") state.stack[state.stack.length-1] = "endtag";
      else if (stream.current() == "]" || type == "]" || (type == "&gt;" &amp;&amp; context == "rule")) state.stack.pop();
      else if (type == "[") state.stack.push("[");
      return style;
    },

    indent: function(state, textAfter) {
      var n = state.stack.length;

      if( textAfter.match(/\]\s+|\]/) )n=n-1;
      else if(textAfter.substr(textAfter.length-1, textAfter.length) === "&gt;"){
        if(textAfter.substr(0,1) === "&lt;") {}
        else if( type == "doindent" &amp;&amp; textAfter.length &gt; 1 ) {}
        else if( type == "doindent")n--;
        else if( type == "&gt;" &amp;&amp; textAfter.length &gt; 1) {}
        else if( type == "tag" &amp;&amp; textAfter !== "&gt;") {}
        else if( type == "tag" &amp;&amp; state.stack[state.stack.length-1] == "rule")n--;
        else if( type == "tag")n++;
        else if( textAfter === "&gt;" &amp;&amp; state.stack[state.stack.length-1] == "rule" &amp;&amp; type === "&gt;")n--;
        else if( textAfter === "&gt;" &amp;&amp; state.stack[state.stack.length-1] == "rule") {}
        else if( textAfter.substr(0,1) !== "&lt;" &amp;&amp; textAfter.substr(0,1) === "&gt;" )n=n-1;
        else if( textAfter === "&gt;") {}
        else n=n-1;
        //over rule them all
        if(type == null || type == "]")n--;
      }

      return state.baseIndent + n * indentUnit;
    },

    electricChars: "]&gt;"
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.dylan" id="apidoc.element.codemirror.modes.dylan">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>dylan
        <span class="apidocSignatureSpan">(_config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dylan = function (_config) {
  // Words
  var words = {
    // Words that introduce unnamed definitions like "define interface"
    unnamedDefinition: ["interface"],

    // Words that introduce simple named definitions like "define library"
    namedDefinition: ["module", "library", "macro",
                      "C-struct", "C-union",
                      "C-function", "C-callable-wrapper"
                     ],

    // Words that introduce type definitions like "define class".
    // These are also parameterized like "define method" and are
    // appended to otherParameterizedDefinitionWords
    typeParameterizedDefinition: ["class", "C-subtype", "C-mapped-subtype"],

    // Words that introduce trickier definitions like "define method".
    // These require special definitions to be added to startExpressions
    otherParameterizedDefinition: ["method", "function",
                                   "C-variable", "C-address"
                                  ],

    // Words that introduce module constant definitions.
    // These must also be simple definitions and are
    // appended to otherSimpleDefinitionWords
    constantSimpleDefinition: ["constant"],

    // Words that introduce module variable definitions.
    // These must also be simple definitions and are
    // appended to otherSimpleDefinitionWords
    variableSimpleDefinition: ["variable"],

    // Other words that introduce simple definitions
    // (without implicit bodies).
    otherSimpleDefinition: ["generic", "domain",
                            "C-pointer-type",
                            "table"
                           ],

    // Words that begin statements with implicit bodies.
    statement: ["if", "block", "begin", "method", "case",
                "for", "select", "when", "unless", "until",
                "while", "iterate", "profiling", "dynamic-bind"
               ],

    // Patterns that act as separators in compound statements.
    // This may include any general pattern that must be indented
    // specially.
    separator: ["finally", "exception", "cleanup", "else",
                "elseif", "afterwards"
               ],

    // Keywords that do not require special indentation handling,
    // but which should be highlighted
    other: ["above", "below", "by", "from", "handler", "in",
            "instance", "let", "local", "otherwise", "slot",
            "subclass", "then", "to", "keyed-by", "virtual"
           ],

    // Condition signaling function calls
    signalingCalls: ["signal", "error", "cerror",
                     "break", "check-type", "abort"
                    ]
  };

  words["otherDefinition"] =
    words["unnamedDefinition"]
    .concat(words["namedDefinition"])
    .concat(words["otherParameterizedDefinition"]);

  words["definition"] =
    words["typeParameterizedDefinition"]
    .concat(words["otherDefinition"]);

  words["parameterizedDefinition"] =
    words["typeParameterizedDefinition"]
    .concat(words["otherParameterizedDefinition"]);

  words["simpleDefinition"] =
    words["constantSimpleDefinition"]
    .concat(words["variableSimpleDefinition"])
    .concat(words["otherSimpleDefinition"]);

  words["keyword"] =
    words["statement"]
    .concat(words["separator"])
    .concat(words["other"]);

  // Patterns
  var symbolPattern = "[-_a-zA-Z?!*@&lt;&gt;$%]+";
  var symbol = new RegExp("^" + symbolPattern);
  var patterns = {
    // Symbols with special syntax
    symbolKeyword: symbolPattern + ":",
    symbolClass: "&lt;" + symbolPattern + "&gt;",
    symbolGlobal: "\\*" + symbolPattern + "\\*",
    symbolConstant: "\\$" + symbolPattern
  };
  var patternStyles = {
    symbolKeyword: "atom",
    symbolClass: "tag",
    symbolGlobal: "variable-2",
    symbolConstant: "variable-3"
  };

  // Compile all patterns to regular expressions
  for (var patternName in patterns)
    if (patterns.hasOwnProperty(patternName))
      patterns[patternName] = new RegExp("^" + patterns[patternName]);

  // Names beginning "with-" and "without-" are commonly
  // used as statement macro
  patterns["keyword"] = [/^with(?:out)?-[-_a ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.ebnf" id="apidoc.element.codemirror.modes.ebnf">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>ebnf
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ebnf = function (config) {
  var commentType = {slash: 0, parenthesis: 1};
  var stateType = {comment: 0, _string: 1, characterClass: 2};
  var bracesMode = null;

  if (config.bracesMode)
    bracesMode = CodeMirror.getMode(config, config.bracesMode);

  return {
    startState: function () {
      return {
        stringType: null,
        commentType: null,
        braced: 0,
        lhs: true,
        localState: null,
        stack: [],
        inDefinition: false
      };
    },
    token: function (stream, state) {
      if (!stream) return;

      //check for state changes
      if (state.stack.length === 0) {
        //strings
        if ((stream.peek() == '"') || (stream.peek() == "'")) {
          state.stringType = stream.peek();
          stream.next(); // Skip quote
          state.stack.unshift(stateType._string);
        } else if (stream.match(/^\/\*/)) { //comments starting with /*
          state.stack.unshift(stateType.comment);
          state.commentType = commentType.slash;
        } else if (stream.match(/^\(\*/)) { //comments starting with (*
          state.stack.unshift(stateType.comment);
          state.commentType = commentType.parenthesis;
        }
      }

      //return state
      //stack has
      switch (state.stack[0]) {
      case stateType._string:
        while (state.stack[0] === stateType._string &amp;&amp; !stream.eol()) {
          if (stream.peek() === state.stringType) {
            stream.next(); // Skip quote
            state.stack.shift(); // Clear flag
          } else if (stream.peek() === "\\") {
            stream.next();
            stream.next();
          } else {
            stream.match(/^.[^\\\"\']*/);
          }
        }
        return state.lhs ? "property string" : "string"; // Token style

      case stateType.comment:
        while (state.stack[0] === stateType.comment &amp;&amp; !stream.eol()) {
          if (state.commentType === commentType.slash &amp;&amp; stream.match(/\*\//)) {
            state.stack.shift(); // Clear flag
            state.commentType = null;
          } else if (state.commentType === commentType.parenthesis &amp;&amp; stream.match(/\*\)/)) {
            state.stack.shift(); // Clear flag
            state.commentType = null;
          } else {
            stream.match(/^.[^\*]*/);
          }
        }
        return "comment";

      case stateType.characterClass:
        while (state.stack[0] === stateType.characterClass &amp;&amp; !stream.eol()) {
          if (!(stream.match(/^[^\]\\]+/) || stream.match(/^\\./))) {
            state.stack.shift();
          }
        }
        return "operator";
      }

      var peek = stream.peek();

      if (bracesMode !== null &amp;&amp; (state.braced || peek === "{")) {
        if (state.localState === null)
          state.localState = CodeMirror.startState(bracesMode);

        var token = bracesMode.token(stream, state.localState),
        text = stream.current();

        if (!token) {
          for (var i = 0; i &lt; text.length; i++) {
            if (text[i] === "{") {
              if (state.braced === 0) {
                token = "matchingbracket";
              }
              state.braced++;
            } else if (text[i] === "}") {
              state.braced--;
              if (state.braced === 0) {
                token = "matchingbracket";
              }
            }
          }
        }
        return token;
      }

      //no stack
      switch (peek) {
      case "[":
        stream.next();
        state.stack.unshift(stateType.characterClass);
        return "bracket";
      case ":":
      case "|":
      case ";":
        stream.next();
        return "operator";
      case "%":
        if (stream.match("%%")) {
          return "header";
        } else if (stream.match(/[%][A-Za-z]+/)) {
          return "keyword";
        } else if (stream.match(/[%][}]/)) {
          return "matchingbracket";
        }
        break;
      case "/":
        if (stream.match(/[\/][A-Za-z]+/)) {
        return "keyword";
      }
      case "\\":
        if (stream.match(/[\][a-z]+/)) {
          return "string-2";
        }
      ca ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.ecl" id="apidoc.element.codemirror.modes.ecl">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>ecl
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ecl = function (config) {

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i &lt; words.length; ++i) obj[words[i]] = true;
    return obj;
  }

  function metaHook(stream, state) {
    if (!state.startOfLine) return false;
    stream.skipToEnd();
    return "meta";
  }

  var indentUnit = config.indentUnit;
  var keyword = words("abs acos allnodes ascii asin asstring atan atan2 ave case choose choosen choosesets clustersize combine correlation
 cos cosh count covariance cron dataset dedup define denormalize distribute distributed distribution ebcdic enth error evaluate
event eventextra eventname exists exp failcode failmessage fetch fromunicode getisvalid global graph group hash hash32 hash64 hashcrc
 hashmd5 having if index intformat isvalid iterate join keyunicode length library limit ln local log loop map matched matchlength
 matchposition matchtext matchunicode max merge mergejoin min nolocal nonempty normalize parse pipe power preload process project
 pull random range rank ranked realformat recordof regexfind regexreplace regroup rejected rollup round roundup row rowdiff sample
 set sin sinh sizeof soapcall sort sorted sqrt stepped stored sum table tan tanh thisnode topn tounicode transfer trim truncate
typeof ungroup unicodeorder variance which workunit xmldecode xmlencode xmltext xmlunicode");
  var variable = words("apply assert build buildindex evaluate fail keydiff keypatch loadxml nothor notify output parallel sequential
 soapcall wait");
  var variable_2 = words("__compressed__ all and any as atmost before beginc++ best between case const counter csv descend encrypt
 end endc++ endmacro except exclusive expire export extend false few first flat from full function group header heading hole ifblock
 import in interface joined keep keyed last left limit load local locale lookup macro many maxcount maxlength min skew module named
 nocase noroot noscan nosort not of only opt or outer overwrite packed partition penalty physicallength pipe quote record relationship
 repeat return right scan self separator service shared skew skip sql store terminator thor threshold token transform trim true
type unicodeorder unsorted validate virtual whole wild within xml xpath");
  var variable_3 = words("ascii big_endian boolean data decimal ebcdic integer pattern qstring real record rule set of string token
 udecimal unicode unsigned varstring varunicode");
  var builtin = words("checkpoint deprecated failcode failmessage failure global independent onwarning persist priority recovery
 stored success wait when");
  var blockKeywords = words("catch class do else finally for if switch try while");
  var atoms = words("true false null");
  var hooks = {"#": metaHook};
  var isOperatorChar = /[+\-*&amp;%=&lt;&gt;!?|\/]/;

  var curPunc;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (hooks[ch]) {
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_]/);
    var cur = stream.current().toLowerCase();
    if (keyword.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "keyword";
    } else if (variable.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      return "variable";
    } else if (variable_2.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.eiffel" id="apidoc.element.codemirror.modes.eiffel">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>eiffel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eiffel = function () {
  function wordObj(words) {
    var o = {};
    for (var i = 0, e = words.length; i &lt; e; ++i) o[words[i]] = true;
    return o;
  }
  var keywords = wordObj([
    'note',
    'across',
    'when',
    'variant',
    'until',
    'unique',
    'undefine',
    'then',
    'strip',
    'select',
    'retry',
    'rescue',
    'require',
    'rename',
    'reference',
    'redefine',
    'prefix',
    'once',
    'old',
    'obsolete',
    'loop',
    'local',
    'like',
    'is',
    'inspect',
    'infix',
    'include',
    'if',
    'frozen',
    'from',
    'external',
    'export',
    'ensure',
    'end',
    'elseif',
    'else',
    'do',
    'creation',
    'create',
    'check',
    'alias',
    'agent',
    'separate',
    'invariant',
    'inherit',
    'indexing',
    'feature',
    'expanded',
    'deferred',
    'class',
    'Void',
    'True',
    'Result',
    'Precursor',
    'False',
    'Current',
    'create',
    'attached',
    'detachable',
    'as',
    'and',
    'implies',
    'not',
    'or'
  ]);
  var operators = wordObj([":=", "and then","and", "or","&lt;&lt;","&gt;&gt;"]);

  function chain(newtok, stream, state) {
    state.tokenize.push(newtok);
    return newtok(stream, state);
  }

  function tokenBase(stream, state) {
    if (stream.eatSpace()) return null;
    var ch = stream.next();
    if (ch == '"'||ch == "'") {
      return chain(readQuoted(ch, "string"), stream, state);
    } else if (ch == "-"&amp;&amp;stream.eat("-")) {
      stream.skipToEnd();
      return "comment";
    } else if (ch == ":"&amp;&amp;stream.eat("=")) {
      return "operator";
    } else if (/[0-9]/.test(ch)) {
      stream.eatWhile(/[xXbBCc0-9\.]/);
      stream.eat(/[\?\!]/);
      return "ident";
    } else if (/[a-zA-Z_0-9]/.test(ch)) {
      stream.eatWhile(/[a-zA-Z_0-9]/);
      stream.eat(/[\?\!]/);
      return "ident";
    } else if (/[=+\-\/*^%&lt;&gt;~]/.test(ch)) {
      stream.eatWhile(/[=+\-\/*^%&lt;&gt;~]/);
      return "operator";
    } else {
      return null;
    }
  }

  function readQuoted(quote, style,  unescaped) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote &amp;&amp; (unescaped || !escaped)) {
          state.tokenize.pop();
          break;
        }
        escaped = !escaped &amp;&amp; ch == "%";
      }
      return style;
    };
  }

  return {
    startState: function() {
      return {tokenize: [tokenBase]};
    },

    token: function(stream, state) {
      var style = state.tokenize[state.tokenize.length-1](stream, state);
      if (style == "ident") {
        var word = stream.current();
        style = keywords.propertyIsEnumerable(stream.current()) ? "keyword"
          : operators.propertyIsEnumerable(stream.current()) ? "operator"
          : /^[A-Z][A-Z_0-9]*$/g.test(word) ? "tag"
          : /^0[bB][0-1]+$/g.test(word) ? "number"
          : /^0[cC][0-7]+$/g.test(word) ? "number"
          : /^0[xX][a-fA-F0-9]+$/g.test(word) ? "number"
          : /^([0-9]+\.[0-9]*)|([0-9]*\.[0-9]+)$/g.test(word) ? "number"
          : /^[0-9]+$/g.test(word) ? "number"
          : "variable";
      }
      return style;
    },
    lineComment: "--"
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.elm" id="apidoc.element.codemirror.modes.elm">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>elm
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">elm = function () {

  function switchState(source, setState, f) {
    setState(f);
    return f(source, setState);
  }

  // These should all be Unicode extended, as per the Haskell 2010 report
  var smallRE = /[a-z_]/;
  var largeRE = /[A-Z]/;
  var digitRE = /[0-9]/;
  var hexitRE = /[0-9A-Fa-f]/;
  var octitRE = /[0-7]/;
  var idRE = /[a-z_A-Z0-9\']/;
  var symbolRE = /[-!#$%&amp;*+.\/&lt;=&gt;?@\\^|~:\u03BB\u2192]/;
  var specialRE = /[(),;[\]`{}]/;
  var whiteCharRE = /[ \t\v\f]/; // newlines are handled in tokenizer

  function normal() {
    return function (source, setState) {
      if (source.eatWhile(whiteCharRE)) {
        return null;
      }

      var ch = source.next();
      if (specialRE.test(ch)) {
        if (ch == '{' &amp;&amp; source.eat('-')) {
          var t = "comment";
          if (source.eat('#')) t = "meta";
          return switchState(source, setState, ncomment(t, 1));
        }
        return null;
      }

      if (ch == '\'') {
        if (source.eat('\\'))
          source.next();  // should handle other escapes here
        else
          source.next();

        if (source.eat('\''))
          return "string";
        return "error";
      }

      if (ch == '"') {
        return switchState(source, setState, stringLiteral);
      }

      if (largeRE.test(ch)) {
        source.eatWhile(idRE);
        if (source.eat('.'))
          return "qualifier";
        return "variable-2";
      }

      if (smallRE.test(ch)) {
        var isDef = source.pos === 1;
        source.eatWhile(idRE);
        return isDef ? "variable-3" : "variable";
      }

      if (digitRE.test(ch)) {
        if (ch == '0') {
          if (source.eat(/[xX]/)) {
            source.eatWhile(hexitRE); // should require at least 1
            return "integer";
          }
          if (source.eat(/[oO]/)) {
            source.eatWhile(octitRE); // should require at least 1
            return "number";
          }
        }
        source.eatWhile(digitRE);
        var t = "number";
        if (source.eat('.')) {
          t = "number";
          source.eatWhile(digitRE); // should require at least 1
        }
        if (source.eat(/[eE]/)) {
          t = "number";
          source.eat(/[-+]/);
          source.eatWhile(digitRE); // should require at least 1
        }
        return t;
      }

      if (symbolRE.test(ch)) {
        if (ch == '-' &amp;&amp; source.eat(/-/)) {
          source.eatWhile(/-/);
          if (!source.eat(symbolRE)) {
            source.skipToEnd();
            return "comment";
          }
        }
        source.eatWhile(symbolRE);
        return "builtin";
      }

      return "error";
    }
  }

  function ncomment(type, nest) {
    if (nest == 0) {
      return normal();
    }
    return function(source, setState) {
      var currNest = nest;
      while (!source.eol()) {
        var ch = source.next();
        if (ch == '{' &amp;&amp; source.eat('-')) {
          ++currNest;
        } else if (ch == '-' &amp;&amp; source.eat('}')) {
          --currNest;
          if (currNest == 0) {
            setState(normal());
            return type;
          }
        }
      }
      setState(ncomment(type, currNest));
      return type;
    }
  }

  function stringLiteral(source, setState) {
    while (!source.eol()) {
      var ch = source.next();
      if (ch == '"') {
        setState(normal());
        return "string";
      }
      if (ch == '\\') {
        if (source.eol() || source.eat(whiteCharRE)) {
          setState(stringGap);
          return "string";
        }
        if (!source.eat('&amp;')) source.next(); // should handle other escapes here
      }
    }
    setState(normal());
    return "error";
  }

  function stringGap(source, setState) {
    if (source.eat('\\')) {
      return switchState(source, setState, stringLiteral);
    }
    source.next();
    setState(normal());
    return "error";
  }


  var wellKnownWords = (function() {
    var wkw = {};

    var keywords = [
      "case", "of", "as",
      "if", "then", "else",
      "let", "in",
      "infix", "infixl", "infixr",
      "type", "alias",
      "input" ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.erlang" id="apidoc.element.codemirror.modes.erlang">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>erlang
        <span class="apidocSignatureSpan">(cmCfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">erlang = function (cmCfg) {
  "use strict";

/////////////////////////////////////////////////////////////////////////////
// constants

  var typeWords = [
    "-type", "-spec", "-export_type", "-opaque"];

  var keywordWords = [
    "after","begin","catch","case","cond","end","fun","if",
    "let","of","query","receive","try","when"];

  var separatorRE    = /[\-&gt;,;]/;
  var separatorWords = [
    "-&gt;",";",","];

  var operatorAtomWords = [
    "and","andalso","band","bnot","bor","bsl","bsr","bxor",
    "div","not","or","orelse","rem","xor"];

  var operatorSymbolRE    = /[\+\-\*\/&lt;&gt;=\|:!]/;
  var operatorSymbolWords = [
    "=","+","-","*","/","&gt;","&gt;=","&lt;","=&lt;","=:=","==","=/=","/=","||","&lt;-","!"];

  var openParenRE    = /[&lt;\(\[\{]/;
  var openParenWords = [
    "&lt;&lt;","(","[","{"];

  var closeParenRE    = /[&gt;\)\]\}]/;
  var closeParenWords = [
    "}","]",")","&gt;&gt;"];

  var guardWords = [
    "is_atom","is_binary","is_bitstring","is_boolean","is_float",
    "is_function","is_integer","is_list","is_number","is_pid",
    "is_port","is_record","is_reference","is_tuple",
    "atom","binary","bitstring","boolean","function","integer","list",
    "number","pid","port","record","reference","tuple"];

  var bifWords = [
    "abs","adler32","adler32_combine","alive","apply","atom_to_binary",
    "atom_to_list","binary_to_atom","binary_to_existing_atom",
    "binary_to_list","binary_to_term","bit_size","bitstring_to_list",
    "byte_size","check_process_code","contact_binary","crc32",
    "crc32_combine","date","decode_packet","delete_module",
    "disconnect_node","element","erase","exit","float","float_to_list",
    "garbage_collect","get","get_keys","group_leader","halt","hd",
    "integer_to_list","internal_bif","iolist_size","iolist_to_binary",
    "is_alive","is_atom","is_binary","is_bitstring","is_boolean",
    "is_float","is_function","is_integer","is_list","is_number","is_pid",
    "is_port","is_process_alive","is_record","is_reference","is_tuple",
    "length","link","list_to_atom","list_to_binary","list_to_bitstring",
    "list_to_existing_atom","list_to_float","list_to_integer",
    "list_to_pid","list_to_tuple","load_module","make_ref","module_loaded",
    "monitor_node","node","node_link","node_unlink","nodes","notalive",
    "now","open_port","pid_to_list","port_close","port_command",
    "port_connect","port_control","pre_loaded","process_flag",
    "process_info","processes","purge_module","put","register",
    "registered","round","self","setelement","size","spawn","spawn_link",
    "spawn_monitor","spawn_opt","split_binary","statistics",
    "term_to_binary","time","throw","tl","trunc","tuple_size",
    "tuple_to_list","unlink","unregister","whereis"];

// upper case: [A-Z] [Ã˜-Ãž] [Ã€-Ã–]
// lower case: [a-z] [ÃŸ-Ã¶] [Ã¸-Ã¿]
  var anumRE       = /[\w@Ã˜-ÃžÃ€-Ã–ÃŸ-Ã¶Ã¸-Ã¿]/;
  var escapesRE    =
    /[0-7]{1,3}|[bdefnrstv\\"']|\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/;

/////////////////////////////////////////////////////////////////////////////
// tokenizer

  function tokenizer(stream,state) {
    // in multi-line string
    if (state.in_string) {
      state.in_string = (!doubleQuote(stream));
      return rval(state,stream,"string");
    }

    // in multi-line atom
    if (state.in_atom) {
      state.in_atom = (!singleQuote(stream));
      return rval(state,stream,"atom");
    }

    // whitespace
    if (stream.eatSpace()) {
      return rval(state,stream,"whitespace");
    }

    // attributes and type specs
    if (!peekToken(state) &amp;&amp;
        stream.match(/-\s*[a-zÃŸ-Ã¶Ã¸-Ã¿][\wÃ˜-ÃžÃ€-Ã–ÃŸ-Ã¶Ã¸-Ã¿]*/)) {
      if (is_member(stream.current(),typeWords)) {
        return rval(state,stream,"type");
      }else{
        return rval(state,stream,"attribute");
      }
    }

    var ch = stream.next();

    // comment
    if (ch == '%') {
      stream.skipToEnd();
      return rval(state,stream,"comment");
    }

    // colon
    if (ch == ":") {
      return rval(state,stream,"colon");
    }

    // macro
    if (ch == '?') {
      stream.eatSpace();
      stream.eatWhile(anumRE);
      return rval(state,stream,"macro");
    }

    // r ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.factor" id="apidoc.element.codemirror.modes.factor">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>factor
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factor = function (config) {
  return CodeMirror.simpleMode(config, states);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.fcl" id="apidoc.element.codemirror.modes.fcl">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>fcl
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fcl = function (config) {
  var indentUnit = config.indentUnit;

  var keywords = {
      "term": true,
      "method": true, "accu": true,
      "rule": true, "then": true, "is": true, "and": true, "or": true,
      "if": true, "default": true
  };

  var start_blocks = {
      "var_input": true,
      "var_output": true,
      "fuzzify": true,
      "defuzzify": true,
      "function_block": true,
      "ruleblock": true
  };

  var end_blocks = {
      "end_ruleblock": true,
      "end_defuzzify": true,
      "end_function_block": true,
      "end_fuzzify": true,
      "end_var": true
  };

  var atoms = {
      "true": true, "false": true, "nan": true,
      "real": true, "min": true, "max": true, "cog": true, "cogs": true
  };

  var isOperatorChar = /[+\-*&amp;^%:=&lt;&gt;!|\/]/;

  function tokenBase(stream, state) {
    var ch = stream.next();

    if (/[\d\.]/.test(ch)) {
      if (ch == ".") {
        stream.match(/^[0-9]+([eE][\-+]?[0-9]+)?/);
      } else if (ch == "0") {
        stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);
      } else {
        stream.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/);
      }
      return "number";
    }

    if (ch == "/" || ch == "(") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_\xa1-\uffff]/);

    var cur = stream.current().toLowerCase();
    if (keywords.propertyIsEnumerable(cur) ||
        start_blocks.propertyIsEnumerable(cur) ||
        end_blocks.propertyIsEnumerable(cur)) {
      return "keyword";
    }
    if (atoms.propertyIsEnumerable(cur)) return "atom";
    return "variable";
  }


  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if ((ch == "/" || ch == ")") &amp;&amp; maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function Context(indented, column, type, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.align = align;
    this.prev = prev;
  }

  function pushContext(state, col, type) {
    return state.context = new Context(state.indented, col, type, null, state.context);
  }

  function popContext(state) {
    if (!state.context.prev) return;
    var t = state.context.type;
    if (t == "end_block")
      state.indented = state.context.indented;
    return state.context = state.context.prev;
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
        indented: 0,
        startOfLine: true
      };
    },

    token: function(stream, state) {
        var ctx = state.context;
        if (stream.sol()) {
            if (ctx.align == null) ctx.align = false;
            state.indented = stream.indentation();
            state.startOfLine = true;
        }
        if (stream.eatSpace()) return null;

        var style = (state.tokenize || tokenBase)(stream, state);
        if (style == "comment") return style;
        if (ctx.align == null) ctx.align = true;

        var cur = stream.current().toLowerCase();

        if (start_blocks.propertyIsEnumerable(cur)) pushContext(state, stream.column(), "end_block");
        else if (end_blocks.propertyIsEnumerable(cur))  popContext(state);

        state.startOfLine = false;
        return style;
    },

    indent: function(state, textAfter) {
      if (state.tokenize != tokenBase &amp;&amp; state.tokenize != null) return 0;
      var ctx = state.context;

      var closing = end_blocks.propertyIsEnumerable(textAfter);
      if (ctx.align) return ctx.column + (closing ? 0 : 1);
      else return ctx.indented + (closing ? 0 : indentUnit);
    },

    electricChars: "ryk",
    fold: "brace",
    blockComm ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.forth" id="apidoc.element.codemirror.modes.forth">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>forth
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forth = function () {
  function searchWordList (wordList, word) {
    var i;
    for (i = wordList.length - 1; i &gt;= 0; i--) {
      if (wordList[i].name === word.toUpperCase()) {
        return wordList[i];
      }
    }
    return undefined;
  }
return {
  startState: function() {
    return {
      state: '',
      base: 10,
      coreWordList: coreWordList,
      immediateWordList: immediateWordList,
      wordList: []
    };
  },
  token: function (stream, stt) {
    var mat;
    if (stream.eatSpace()) {
      return null;
    }
    if (stt.state === '') { // interpretation
      if (stream.match(/^(\]|:NONAME)(\s|$)/i)) {
        stt.state = ' compilation';
        return 'builtin compilation';
      }
      mat = stream.match(/^(\:)\s+(\S+)(\s|$)+/);
      if (mat) {
        stt.wordList.push({name: mat[2].toUpperCase()});
        stt.state = ' compilation';
        return 'def' + stt.state;
      }
      mat = stream.match(/^(VARIABLE|2VARIABLE|CONSTANT|2CONSTANT|CREATE|POSTPONE|VALUE|WORD)\s+(\S+)(\s|$)+/i);
      if (mat) {
        stt.wordList.push({name: mat[2].toUpperCase()});
        return 'def' + stt.state;
      }
      mat = stream.match(/^(\'|\[\'\])\s+(\S+)(\s|$)+/);
      if (mat) {
        return 'builtin' + stt.state;
      }
      } else { // compilation
      // ; [
      if (stream.match(/^(\;|\[)(\s)/)) {
        stt.state = '';
        stream.backUp(1);
        return 'builtin compilation';
      }
      if (stream.match(/^(\;|\[)($)/)) {
        stt.state = '';
        return 'builtin compilation';
      }
      if (stream.match(/^(POSTPONE)\s+\S+(\s|$)+/)) {
        return 'builtin';
      }
    }

    // dynamic wordlist
    mat = stream.match(/^(\S+)(\s+|$)/);
    if (mat) {
      if (searchWordList(stt.wordList, mat[1]) !== undefined) {
        return 'variable' + stt.state;
      }

      // comments
      if (mat[1] === '\\') {
        stream.skipToEnd();
          return 'comment' + stt.state;
        }

        // core words
        if (searchWordList(stt.coreWordList, mat[1]) !== undefined) {
          return 'builtin' + stt.state;
        }
        if (searchWordList(stt.immediateWordList, mat[1]) !== undefined) {
          return 'keyword' + stt.state;
        }

        if (mat[1] === '(') {
          stream.eatWhile(function (s) { return s !== ')'; });
          stream.eat(')');
          return 'comment' + stt.state;
        }

        // // strings
        if (mat[1] === '.(') {
          stream.eatWhile(function (s) { return s !== ')'; });
          stream.eat(')');
          return 'string' + stt.state;
        }
        if (mat[1] === 'S"' || mat[1] === '."' || mat[1] === 'C"') {
          stream.eatWhile(function (s) { return s !== '"'; });
          stream.eat('"');
          return 'string' + stt.state;
        }

        // numbers
        if (mat[1] - 0xfffffffff) {
          return 'number' + stt.state;
        }
        // if (mat[1].match(/^[-+]?[0-9]+\.[0-9]*/)) {
        //     return 'number' + stt.state;
        // }

        return 'atom' + stt.state;
      }
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.fortran" id="apidoc.element.codemirror.modes.fortran">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>fortran
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fortran = function () {
  function words(array) {
    var keys = {};
    for (var i = 0; i &lt; array.length; ++i) {
      keys[array[i]] = true;
    }
    return keys;
  }

  var keywords = words([
                  "abstract", "accept", "allocatable", "allocate",
                  "array", "assign", "asynchronous", "backspace",
                  "bind", "block", "byte", "call", "case",
                  "class", "close", "common", "contains",
                  "continue", "cycle", "data", "deallocate",
                  "decode", "deferred", "dimension", "do",
                  "elemental", "else", "encode", "end",
                  "endif", "entry", "enumerator", "equivalence",
                  "exit", "external", "extrinsic", "final",
                  "forall", "format", "function", "generic",
                  "go", "goto", "if", "implicit", "import", "include",
                  "inquire", "intent", "interface", "intrinsic",
                  "module", "namelist", "non_intrinsic",
                  "non_overridable", "none", "nopass",
                  "nullify", "open", "optional", "options",
                  "parameter", "pass", "pause", "pointer",
                  "print", "private", "program", "protected",
                  "public", "pure", "read", "recursive", "result",
                  "return", "rewind", "save", "select", "sequence",
                  "stop", "subroutine", "target", "then", "to", "type",
                  "use", "value", "volatile", "where", "while",
                  "write"]);
  var builtins = words(["abort", "abs", "access", "achar", "acos",
                          "adjustl", "adjustr", "aimag", "aint", "alarm",
                          "all", "allocated", "alog", "amax", "amin",
                          "amod", "and", "anint", "any", "asin",
                          "associated", "atan", "besj", "besjn", "besy",
                          "besyn", "bit_size", "btest", "cabs", "ccos",
                          "ceiling", "cexp", "char", "chdir", "chmod",
                          "clog", "cmplx", "command_argument_count",
                          "complex", "conjg", "cos", "cosh", "count",
                          "cpu_time", "cshift", "csin", "csqrt", "ctime",
                          "c_funloc", "c_loc", "c_associated", "c_null_ptr",
                          "c_null_funptr", "c_f_pointer", "c_null_char",
                          "c_alert", "c_backspace", "c_form_feed",
                          "c_new_line", "c_carriage_return",
                          "c_horizontal_tab", "c_vertical_tab", "dabs",
                          "dacos", "dasin", "datan", "date_and_time",
                          "dbesj", "dbesj", "dbesjn", "dbesy", "dbesy",
                          "dbesyn", "dble", "dcos", "dcosh", "ddim", "derf",
                          "derfc", "dexp", "digits", "dim", "dint", "dlog",
                          "dlog", "dmax", "dmin", "dmod", "dnint",
                          "dot_product", "dprod", "dsign", "dsinh",
                          "dsin", "dsqrt", "dtanh", "dtan", "dtime",
                          "eoshift", "epsilon", "erf", "erfc", "etime",
                          "exit", "exp", "exponent", "extends_type_of",
                          "fdate", "fget", "fgetc", "float", "floor",
                          "flush", "fnum", "fputc", "fput", "fraction",
                          "fseek", "fstat", "ftell", "gerror", "getarg",
                          "get_command", "get_command_argument",
                          "get_environment_variable", "getcwd",
                          "getenv", "getgid", "getlog", "getpid",
                          "getuid", "gmtime", "hostnm", "huge", "iabs",
                          "iachar", "iand", "iargc", "ibclr", "ibits",
                          "ibset", "ichar", "idate", "idim", "idint",
                          "idnint", "ieor", "ierrno", "ifix", "imag",
                          "imagpart", "index", "int", "ior", "irand",
                          "isatty", "ishft", "ishftc", "isign",
                          "iso_c_binding", " ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.gas" id="apidoc.element.codemirror.modes.gas">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>gas
        <span class="apidocSignatureSpan">(_config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gas = function (_config, parserConfig) {
  'use strict';

  // If an architecture is specified, its initialization function may
  // populate this array with custom parsing functions which will be
  // tried in the event that the standard functions do not find a match.
  var custom = [];

  // The symbol used to start a line comment changes based on the target
  // architecture.
  // If no architecture is pased in "parserConfig" then only multiline
  // comments will have syntax support.
  var lineCommentStartSymbol = "";

  // These directives are architecture independent.
  // Machine specific directives should go in their respective
  // architecture initialization function.
  // Reference:
  // http://sourceware.org/binutils/docs/as/Pseudo-Ops.html#Pseudo-Ops
  var directives = {
    ".abort" : "builtin",
    ".align" : "builtin",
    ".altmacro" : "builtin",
    ".ascii" : "builtin",
    ".asciz" : "builtin",
    ".balign" : "builtin",
    ".balignw" : "builtin",
    ".balignl" : "builtin",
    ".bundle_align_mode" : "builtin",
    ".bundle_lock" : "builtin",
    ".bundle_unlock" : "builtin",
    ".byte" : "builtin",
    ".cfi_startproc" : "builtin",
    ".comm" : "builtin",
    ".data" : "builtin",
    ".def" : "builtin",
    ".desc" : "builtin",
    ".dim" : "builtin",
    ".double" : "builtin",
    ".eject" : "builtin",
    ".else" : "builtin",
    ".elseif" : "builtin",
    ".end" : "builtin",
    ".endef" : "builtin",
    ".endfunc" : "builtin",
    ".endif" : "builtin",
    ".equ" : "builtin",
    ".equiv" : "builtin",
    ".eqv" : "builtin",
    ".err" : "builtin",
    ".error" : "builtin",
    ".exitm" : "builtin",
    ".extern" : "builtin",
    ".fail" : "builtin",
    ".file" : "builtin",
    ".fill" : "builtin",
    ".float" : "builtin",
    ".func" : "builtin",
    ".global" : "builtin",
    ".gnu_attribute" : "builtin",
    ".hidden" : "builtin",
    ".hword" : "builtin",
    ".ident" : "builtin",
    ".if" : "builtin",
    ".incbin" : "builtin",
    ".include" : "builtin",
    ".int" : "builtin",
    ".internal" : "builtin",
    ".irp" : "builtin",
    ".irpc" : "builtin",
    ".lcomm" : "builtin",
    ".lflags" : "builtin",
    ".line" : "builtin",
    ".linkonce" : "builtin",
    ".list" : "builtin",
    ".ln" : "builtin",
    ".loc" : "builtin",
    ".loc_mark_labels" : "builtin",
    ".local" : "builtin",
    ".long" : "builtin",
    ".macro" : "builtin",
    ".mri" : "builtin",
    ".noaltmacro" : "builtin",
    ".nolist" : "builtin",
    ".octa" : "builtin",
    ".offset" : "builtin",
    ".org" : "builtin",
    ".p2align" : "builtin",
    ".popsection" : "builtin",
    ".previous" : "builtin",
    ".print" : "builtin",
    ".protected" : "builtin",
    ".psize" : "builtin",
    ".purgem" : "builtin",
    ".pushsection" : "builtin",
    ".quad" : "builtin",
    ".reloc" : "builtin",
    ".rept" : "builtin",
    ".sbttl" : "builtin",
    ".scl" : "builtin",
    ".section" : "builtin",
    ".set" : "builtin",
    ".short" : "builtin",
    ".single" : "builtin",
    ".size" : "builtin",
    ".skip" : "builtin",
    ".sleb128" : "builtin",
    ".space" : "builtin",
    ".stab" : "builtin",
    ".string" : "builtin",
    ".struct" : "builtin",
    ".subsection" : "builtin",
    ".symver" : "builtin",
    ".tag" : "builtin",
    ".text" : "builtin",
    ".title" : "builtin",
    ".type" : "builtin",
    ".uleb128" : "builtin",
    ".val" : "builtin",
    ".version" : "builtin",
    ".vtable_entry" : "builtin",
    ".vtable_inherit" : "builtin",
    ".warning" : "builtin",
    ".weak" : "builtin",
    ".weakref" : "builtin",
    ".word" : "builtin"
  };

  var registers = {};

  function x86(_parserConfig) {
    lineCommentStartSymbol = "#";

    registers.ax  = "variable";
    registers.eax = "variable-2";
    registers.rax = "variable-3";

    registers.bx  = "variable";
    registers.ebx = "variable-2";
    registers.rbx = "variable-3";

    registers.cx  = "variable";
    registers.ecx = "variable-2";
    registers.rcx = "variable-3";

    registers.dx  = "variable";
    registers.edx = "variable-2"; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.gfm" id="apidoc.element.codemirror.modes.gfm">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>gfm
        <span class="apidocSignatureSpan">(config, modeConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gfm = function (config, modeConfig) {
  var codeDepth = 0;
  function blankLine(state) {
    state.code = false;
    return null;
  }
  var gfmOverlay = {
    startState: function() {
      return {
        code: false,
        codeBlock: false,
        ateSpace: false
      };
    },
    copyState: function(s) {
      return {
        code: s.code,
        codeBlock: s.codeBlock,
        ateSpace: s.ateSpace
      };
    },
    token: function(stream, state) {
      state.combineTokens = null;

      // Hack to prevent formatting override inside code blocks (block and inline)
      if (state.codeBlock) {
        if (stream.match(/^```+/)) {
          state.codeBlock = false;
          return null;
        }
        stream.skipToEnd();
        return null;
      }
      if (stream.sol()) {
        state.code = false;
      }
      if (stream.sol() &amp;&amp; stream.match(/^```+/)) {
        stream.skipToEnd();
        state.codeBlock = true;
        return null;
      }
      // If this block is changed, it may need to be updated in Markdown mode
      if (stream.peek() === '`') {
        stream.next();
        var before = stream.pos;
        stream.eatWhile('`');
        var difference = 1 + stream.pos - before;
        if (!state.code) {
          codeDepth = difference;
          state.code = true;
        } else {
          if (difference === codeDepth) { // Must be exact
            state.code = false;
          }
        }
        return null;
      } else if (state.code) {
        stream.next();
        return null;
      }
      // Check if space. If so, links can be formatted later on
      if (stream.eatSpace()) {
        state.ateSpace = true;
        return null;
      }
      if (stream.sol() || state.ateSpace) {
        state.ateSpace = false;
        if (modeConfig.gitHubSpice !== false) {
          if(stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?:[a-f0-9]{7,40}\b)/)) {
            // User/Project@SHA
            // User@SHA
            // SHA
            state.combineTokens = true;
            return "link";
          } else if (stream.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/)) {
            // User/Project#Num
            // User#Num
            // #Num
            state.combineTokens = true;
            return "link";
          }
        }
      }
      if (stream.match(urlRE) &amp;&amp;
          stream.string.slice(stream.start - 2, stream.start) != "](" &amp;&amp;
          (stream.start == 0 || /\W/.test(stream.string.charAt(stream.start - 1)))) {
        // URLs
        // Taken from http://daringfireball.net/2010/07/improved_regex_for_matching_urls
        // And then (issue #1160) simplified to make it not crash the Chrome Regexp engine
        // And then limited url schemes to the CommonMark list, so foo:bar isn't matched as a URL
        state.combineTokens = true;
        return "link";
      }
      stream.next();
      return null;
    },
    blankLine: blankLine
  };

  var markdownConfig = {
    taskLists: true,
    fencedCodeBlocks: '```',
    strikethrough: true
  };
  for (var attr in modeConfig) {
    markdownConfig[attr] = modeConfig[attr];
  }
  markdownConfig.name = "markdown";
  return CodeMirror.overlayMode(CodeMirror.getMode(config, markdownConfig), gfmOverlay);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.gherkin" id="apidoc.element.codemirror.modes.gherkin">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>gherkin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">gherkin = function () {
  return {
    startState: function () {
      return {
        lineNumber: 0,
        tableHeaderLine: false,
        allowFeature: true,
        allowBackground: false,
        allowScenario: false,
        allowSteps: false,
        allowPlaceholders: false,
        allowMultilineArgument: false,
        inMultilineString: false,
        inMultilineTable: false,
        inKeywordLine: false
      };
    },
    token: function (stream, state) {
      if (stream.sol()) {
        state.lineNumber++;
        state.inKeywordLine = false;
        if (state.inMultilineTable) {
            state.tableHeaderLine = false;
            if (!stream.match(/\s*\|/, false)) {
              state.allowMultilineArgument = false;
              state.inMultilineTable = false;
            }
        }
      }

      stream.eatSpace();

      if (state.allowMultilineArgument) {

        // STRING
        if (state.inMultilineString) {
          if (stream.match('"""')) {
            state.inMultilineString = false;
            state.allowMultilineArgument = false;
          } else {
            stream.match(/.*/);
          }
          return "string";
        }

        // TABLE
        if (state.inMultilineTable) {
          if (stream.match(/\|\s*/)) {
            return "bracket";
          } else {
            stream.match(/[^\|]*/);
            return state.tableHeaderLine ? "header" : "string";
          }
        }

        // DETECT START
        if (stream.match('"""')) {
          // String
          state.inMultilineString = true;
          return "string";
        } else if (stream.match("|")) {
          // Table
          state.inMultilineTable = true;
          state.tableHeaderLine = true;
          return "bracket";
        }

      }

      // LINE COMMENT
      if (stream.match(/#.*/)) {
        return "comment";

      // TAG
      } else if (!state.inKeywordLine &amp;&amp; stream.match(/@\S+/)) {
        return "tag";

      // FEATURE
      } else if (!state.inKeywordLine &amp;&amp; state.allowFeature &amp;&amp; stream.match(/(æ©Ÿèƒ½|åŠŸèƒ½|ãƒ•ã‚£ãƒ¼ãƒãƒ£|ê¸°ëŠ¥|à¹‚à¸„à¸£à¸‡à¸«à¸¥à¸±à¸|à¸„à¸§à¸²à¸¡à¸ªà¸²à¸¡à¸²à¸£à¸–|à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸—à¸²à¸‡à¸˜à¸¸à¸£à¸à¸´à¸ˆ|à²¹à³†à²šà³à²šà²³|à°—à±à°£à°®à±|à¨®à©à¨¹à¨¾à¨‚à¨¦à¨°à¨¾|à¨¨à¨•à¨¶ à¨¨à©à¨¹à¨¾à¨°|à¨–à¨¾à¨¸à©€à¨…à¨¤|à¤°à¥‚à¤ª à¤²à¥‡à¤–|ÙˆÙÛŒÚ˜Ú¯ÛŒ|Ø®Ø§ØµÙŠØ©|×ª×›×•×&nbsp;×”|Ð¤ÑƒÐ½ÐºÑ†Ñ–Ð¾Ð½Ð°Ð»|Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ|Ð¤ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð»Ð½Ð¾ÑÑ‚|Ð¤ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð»|Ò®Ð·ÐµÐ½Ñ‡Ó™Ð»ÐµÐºÐ»ÐµÐ»ÐµÐº|Ð¡Ð²Ð¾Ð¹ÑÑ‚Ð²Ð¾|ÐžÑÐ¾Ð±Ð¸Ð½Ð°|ÐœÓ©Ð¼ÐºÐ¸Ð½Ð»ÐµÐº|ÐœÐ¾Ð³ÑƒÑ›Ð½Ð¾ÑÑ‚|Î›ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î±|Î”Ï…Î½Î±Ï„ÏŒÏ„Î·Ï„Î±|
WÅ‚aÅ›ciwoÅ›Ä‡|VlastnosÅ¥|Trajto|TÃ­nh nÄƒng|SavybÄ—|Pretty much|PoÅ¾iadavka|PoÅ¾adavek|Potrzeba biznesowa|Ã–zellik|Osobina|Ominaisuus|Omadus
|OH HAI|MoguÄ‡nost|Mogucnost|JellemzÅ‘|HwÃ¦t|Hwaet|FunzionalitÃ&nbsp;|FunktionalitÃ©it|FunktionalitÃ¤t|Funkcja|Funkcionalnost|FunkcionalitÄ
te|Funkcia|Fungsi|Functionaliteit|FuncÈ›ionalitate|FuncÅ£ionalitate|Functionalitate|Funcionalitat|Funcionalidade|FonctionnalitÃ©|Fitur
|FÄ«Äa|Feature|Eiginleiki|Egenskap|Egenskab|CaracterÃ­stica|Caracteristica|Business Need|Aspekt|Arwedd|Ahoy matey!|Ability):/)) {
        state.allowScenario = true;
        state.allowBackground = true;
        state.allowPlaceholders = false;
        state.allowSteps = false;
        state.allowMultilineArgument = false;
        state.inKeywordLine = true;
        return "keyword";

      // BACKGROUND
      } else if (!state.inKeywordLine &amp;&amp; state.allowBackground &amp;&amp; stream.match(/(èƒŒæ™¯|ë°°ê²½|à¹à¸™à¸§à¸„à¸´à¸”|à²¹à²¿à²¨à³à²¨à³†à²²à³†|à°¨à±‡à°ªà°¥à±à°¯à°‚|à¨ªà¨¿à¨›à©‹à¨•à©œ|à¤ªà¥ƒà¤·à¥à¤&nbsp;à¤­à¥‚à¤®à¤¿|Ø²Ù…ÛŒÙ†Ù‡|Ø§Ù„Ø®Ù„ÙÙŠØ©|×¨×§×¢|Ð¢Ð°Ñ€Ð¸Ñ…|ÐŸÑ€ÐµÐ´Ñ‹ÑÑ‚Ð¾Ñ€Ð¸Ñ|ÐŸÑ€ÐµÐ´Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ñ|ÐŸÐ¾Ð·Ð°Ð´Ð¸Ð½Ð°|ÐŸÐµÑ€ÐµÐ´ÑƒÐ¼Ð¾Ð²Ð°|ÐžÑÐ½Ð¾Ð²Ð°|ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚|ÐšÐµÑ€ÐµÑˆ|Î¥Ï€ÏŒÎ²Î±Î¸ÏÎ¿|
ZaÅ‚oÅ¼enia|Yo\-ho\-ho|Tausta|Taust|SituÄcija|Rerefons|Pozadina|Pozadie|PozadÃ­|Osnova|Latar Belakang|Kontext|Konteksts|Kontekstas|Kontekst|HÃ¡ttÃ©r|Hannergrond|Grundlage|GeÃ§miÅŸ|Fundo|Fono|First off|Dis is what went down|Dasar|Contexto|Contexte|Context|Contesto|CenÃ¡rio de Fundo|Cenario de Fundo|Cefndir|Bá»‘i cáº£nh|Bakgrunnur|Bakgrunn|Bakgrund|Baggrund|Background|B4|Antecedents|Antecedentes|Ã†r|Aer|Achtergrond):/)) {
        state.allowPlaceholders = false;
        state.allowSteps = true;
        state.allowBackground = false;
        state.allowMultilineArgument = false;
        state.inKeywordLine = true;
        return "keyword";

      // SCENARIO OUTLINE
      } else if (!state.inKeywordLine &amp;&amp; state.allowScenario &amp;&amp; stream.match(/(å&nbsp;´æ™¯å¤§ç¶±|åœºæ™¯å¤§çº²|åŠ‡æœ¬å¤§ç¶±|å‰§æœ¬å¤§çº²|ãƒ†ãƒ³ãƒ—ãƒ¬|ã‚·ãƒŠãƒªã‚ªãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.go" id="apidoc.element.codemirror.modes.go">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>go
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">go = function (config) {
  var indentUnit = config.indentUnit;

  var keywords = {
    "break":true, "case":true, "chan":true, "const":true, "continue":true,
    "default":true, "defer":true, "else":true, "fallthrough":true, "for":true,
    "func":true, "go":true, "goto":true, "if":true, "import":true,
    "interface":true, "map":true, "package":true, "range":true, "return":true,
    "select":true, "struct":true, "switch":true, "type":true, "var":true,
    "bool":true, "byte":true, "complex64":true, "complex128":true,
    "float32":true, "float64":true, "int8":true, "int16":true, "int32":true,
    "int64":true, "string":true, "uint8":true, "uint16":true, "uint32":true,
    "uint64":true, "int":true, "uint":true, "uintptr":true, "error": true,
    "rune":true
  };

  var atoms = {
    "true":true, "false":true, "iota":true, "nil":true, "append":true,
    "cap":true, "close":true, "complex":true, "copy":true, "delete":true, "imag":true,
    "len":true, "make":true, "new":true, "panic":true, "print":true,
    "println":true, "real":true, "recover":true
  };

  var isOperatorChar = /[+\-*&amp;^%:=&lt;&gt;!|\/]/;

  var curPunc;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'" || ch == "`") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (/[\d\.]/.test(ch)) {
      if (ch == ".") {
        stream.match(/^[0-9]+([eE][\-+]?[0-9]+)?/);
      } else if (ch == "0") {
        stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^0[0-7]+/);
      } else {
        stream.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/);
      }
      return "number";
    }
    if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_\xa1-\uffff]/);
    var cur = stream.current();
    if (keywords.propertyIsEnumerable(cur)) {
      if (cur == "case" || cur == "default") curPunc = "case";
      return "keyword";
    }
    if (atoms.propertyIsEnumerable(cur)) return "atom";
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote &amp;&amp; !escaped) {end = true; break;}
        escaped = !escaped &amp;&amp; quote != "`" &amp;&amp; next == "\\";
      }
      if (end || !(escaped || quote == "`"))
        state.tokenize = tokenBase;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" &amp;&amp; maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function Context(indented, column, type, align, prev) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.align = align;
    this.prev = prev;
  }
  function pushContext(state, col, type) {
    return state.context = new Context(state.indented, col, type, null, state.context);
  }
  function popContext(state) {
    if (!state.context.prev) return;
    var t = state.context.type;
    if (t == ")" || t == "]" || t == "}")
      state.indented = state.context.indented;
    return state.context = state.context.prev;
  }

  // Interface

  return {
    startState: function(basecolumn) {
      return {
        tokenize: null,
        context: new Context((basecolumn || 0) - indentUnit, 0, "top", false),
        indented: 0,
        startOfLine: true
      };
    },

    token: function(stream, state) {
      var ctx = state.context;
      if (stream.sol()) {
        if (ctx.align == null) ctx.align = false;
        state.indented = stream.indentation();
        state.startOfLine = true;
        if (ctx.ty ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.groovy" id="apidoc.element.codemirror.modes.groovy">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>groovy
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groovy = function (config) {
  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i &lt; words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var keywords = words(
    "abstract as assert boolean break byte case catch char class const continue def default " +
    "do double else enum extends final finally float for goto if implements import in " +
    "instanceof int interface long native new package private protected public return " +
    "short static strictfp super switch synchronized threadsafe throw throws transient " +
    "try void volatile while");
  var blockKeywords = words("catch class do else finally for if switch try while enum interface def");
  var standaloneKeywords = words("return break continue");
  var atoms = words("null true false this");

  var curPunc;
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      return startString(ch, stream, state);
    }
    if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      curPunc = ch;
      return null;
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      if (stream.eat(/eE/)) { stream.eat(/\+\-/); stream.eatWhile(/\d/); }
      return "number";
    }
    if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize.push(tokenComment);
        return tokenComment(stream, state);
      }
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
      if (expectExpression(state.lastToken, false)) {
        return startString(ch, stream, state);
      }
    }
    if (ch == "-" &amp;&amp; stream.eat("&gt;")) {
      curPunc = "-&gt;";
      return null;
    }
    if (/[+\-*&amp;%=&lt;&gt;!?|\/~]/.test(ch)) {
      stream.eatWhile(/[+\-*&amp;%=&lt;&gt;|~]/);
      return "operator";
    }
    stream.eatWhile(/[\w\$_]/);
    if (ch == "@") { stream.eatWhile(/[\w\$_\.]/); return "meta"; }
    if (state.lastToken == ".") return "property";
    if (stream.eat(":")) { curPunc = "proplabel"; return "property"; }
    var cur = stream.current();
    if (atoms.propertyIsEnumerable(cur)) { return "atom"; }
    if (keywords.propertyIsEnumerable(cur)) {
      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = "newstatement";
      else if (standaloneKeywords.propertyIsEnumerable(cur)) curPunc = "standalone";
      return "keyword";
    }
    return "variable";
  }
  tokenBase.isBase = true;

  function startString(quote, stream, state) {
    var tripleQuoted = false;
    if (quote != "/" &amp;&amp; stream.eat(quote)) {
      if (stream.eat(quote)) tripleQuoted = true;
      else return "string";
    }
    function t(stream, state) {
      var escaped = false, next, end = !tripleQuoted;
      while ((next = stream.next()) != null) {
        if (next == quote &amp;&amp; !escaped) {
          if (!tripleQuoted) { break; }
          if (stream.match(quote + quote)) { end = true; break; }
        }
        if (quote == '"' &amp;&amp; next == "$" &amp;&amp; !escaped &amp;&amp; stream.eat("{")) {
          state.tokenize.push(tokenBaseUntilBrace());
          return "string";
        }
        escaped = !escaped &amp;&amp; next == "\\";
      }
      if (end) state.tokenize.pop();
      return "string";
    }
    state.tokenize.push(t);
    return t(stream, state);
  }

  function tokenBaseUntilBrace() {
    var depth = 1;
    function t(stream, state) {
      if (stream.peek() == "}") {
        depth--;
        if (depth == 0) {
          state.tokenize.pop();
          return state.tokenize[state.tokenize.length-1](stream, state);
        }
      } else if (stream.peek() == "{") {
        depth++;
      }
      return tokenBase(stream, state);
    }
    t.isBase = true;
    return t;
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" &amp;&amp; maybeEnd) {
        state.tokenize.pop();
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function expectExpression(last, newline) {
    return !last || last == "operator" || last == "-&gt;" || /[\.\[\{\(,;:]/.test(last) ||
      last == "newstatement" || last == "keyword" || last == "prop ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.haml" id="apidoc.element.codemirror.modes.haml">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>haml
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">haml = function (config) {
  var htmlMode = CodeMirror.getMode(config, {name: "htmlmixed"});
  var rubyMode = CodeMirror.getMode(config, "ruby");

  function rubyInQuote(endQuote) {
    return function(stream, state) {
      var ch = stream.peek();
      if (ch == endQuote &amp;&amp; state.rubyState.tokenize.length == 1) {
        // step out of ruby context as it seems to complete processing all the braces
        stream.next();
        state.tokenize = html;
        return "closeAttributeTag";
      } else {
        return ruby(stream, state);
      }
    };
  }

  function ruby(stream, state) {
    if (stream.match("-#")) {
      stream.skipToEnd();
      return "comment";
    }
    return rubyMode.token(stream, state.rubyState);
  }

  function html(stream, state) {
    var ch = stream.peek();

    // handle haml declarations. All declarations that cant be handled here
    // will be passed to html mode
    if (state.previousToken.style == "comment" ) {
      if (state.indented &gt; state.previousToken.indented) {
        stream.skipToEnd();
        return "commentLine";
      }
    }

    if (state.startOfLine) {
      if (ch == "!" &amp;&amp; stream.match("!!")) {
        stream.skipToEnd();
        return "tag";
      } else if (stream.match(/^%[\w:#\.]+=/)) {
        state.tokenize = ruby;
        return "hamlTag";
      } else if (stream.match(/^%[\w:]+/)) {
        return "hamlTag";
      } else if (ch == "/" ) {
        stream.skipToEnd();
        return "comment";
      }
    }

    if (state.startOfLine || state.previousToken.style == "hamlTag") {
      if ( ch == "#" || ch == ".") {
        stream.match(/[\w-#\.]*/);
        return "hamlAttribute";
      }
    }

    // donot handle --&gt; as valid ruby, make it HTML close comment instead
    if (state.startOfLine &amp;&amp; !stream.match("--&gt;", false) &amp;&amp; (ch == "=" || ch == "-" )) {
      state.tokenize = ruby;
      return state.tokenize(stream, state);
    }

    if (state.previousToken.style == "hamlTag" ||
        state.previousToken.style == "closeAttributeTag" ||
        state.previousToken.style == "hamlAttribute") {
      if (ch == "(") {
        state.tokenize = rubyInQuote(")");
        return state.tokenize(stream, state);
      } else if (ch == "{") {
        if (!stream.match(/^\{%.*/)) {
          state.tokenize = rubyInQuote("}");
          return state.tokenize(stream, state);
        }
      }
    }

    return htmlMode.token(stream, state.htmlState);
  }

  return {
    // default to html mode
    startState: function() {
      var htmlState = CodeMirror.startState(htmlMode);
      var rubyState = CodeMirror.startState(rubyMode);
      return {
        htmlState: htmlState,
        rubyState: rubyState,
        indented: 0,
        previousToken: { style: null, indented: 0},
        tokenize: html
      };
    },

    copyState: function(state) {
      return {
        htmlState : CodeMirror.copyState(htmlMode, state.htmlState),
        rubyState: CodeMirror.copyState(rubyMode, state.rubyState),
        indented: state.indented,
        previousToken: state.previousToken,
        tokenize: state.tokenize
      };
    },

    token: function(stream, state) {
      if (stream.sol()) {
        state.indented = stream.indentation();
        state.startOfLine = true;
      }
      if (stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      state.startOfLine = false;
      // dont record comment line as we only want to measure comment line with
      // the opening comment block
      if (style &amp;&amp; style != "commentLine") {
        state.previousToken = { style: style, indented: state.indented };
      }
      // if current state is ruby and the previous token is not `,` reset the
      // tokenize to html
      if (stream.eol() &amp;&amp; state.tokenize == ruby) {
        stream.backUp(1);
        var ch = stream.peek();
        stream.next();
        if (ch &amp;&amp; ch != ",") {
          state.tokenize = html;
        }
      }
      // reprocess some of the specific style tag when finish setting previousToken
      if (style == "hamlTag") {
        style = "tag ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.handlebars" id="apidoc.element.codemirror.modes.handlebars">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>handlebars
        <span class="apidocSignatureSpan">(config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handlebars = function (config, parserConfig) {
  var handlebars = CodeMirror.getMode(config, "handlebars-tags");
  if (!parserConfig || !parserConfig.base) return handlebars;
  return CodeMirror.multiplexingMode(
    CodeMirror.getMode(config, parserConfig.base),
    {open: "{{", close: "}}", mode: handlebars, parseDelimiters: true}
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.handlebars-tags" id="apidoc.element.codemirror.modes.handlebars-tags">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>handlebars-tags
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handlebars-tags = function (config) {
  return CodeMirror.simpleMode(config, states);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.haskell" id="apidoc.element.codemirror.modes.haskell">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>haskell
        <span class="apidocSignatureSpan">(_config, modeConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">haskell = function (_config, modeConfig) {

  function switchState(source, setState, f) {
    setState(f);
    return f(source, setState);
  }

  // These should all be Unicode extended, as per the Haskell 2010 report
  var smallRE = /[a-z_]/;
  var largeRE = /[A-Z]/;
  var digitRE = /\d/;
  var hexitRE = /[0-9A-Fa-f]/;
  var octitRE = /[0-7]/;
  var idRE = /[a-z_A-Z0-9'\xa1-\uffff]/;
  var symbolRE = /[-!#$%&amp;*+.\/&lt;=&gt;?@\\^|~:]/;
  var specialRE = /[(),;[\]`{}]/;
  var whiteCharRE = /[ \t\v\f]/; // newlines are handled in tokenizer

  function normal(source, setState) {
    if (source.eatWhile(whiteCharRE)) {
      return null;
    }

    var ch = source.next();
    if (specialRE.test(ch)) {
      if (ch == '{' &amp;&amp; source.eat('-')) {
        var t = "comment";
        if (source.eat('#')) {
          t = "meta";
        }
        return switchState(source, setState, ncomment(t, 1));
      }
      return null;
    }

    if (ch == '\'') {
      if (source.eat('\\')) {
        source.next();  // should handle other escapes here
      }
      else {
        source.next();
      }
      if (source.eat('\'')) {
        return "string";
      }
      return "string error";
    }

    if (ch == '"') {
      return switchState(source, setState, stringLiteral);
    }

    if (largeRE.test(ch)) {
      source.eatWhile(idRE);
      if (source.eat('.')) {
        return "qualifier";
      }
      return "variable-2";
    }

    if (smallRE.test(ch)) {
      source.eatWhile(idRE);
      return "variable";
    }

    if (digitRE.test(ch)) {
      if (ch == '0') {
        if (source.eat(/[xX]/)) {
          source.eatWhile(hexitRE); // should require at least 1
          return "integer";
        }
        if (source.eat(/[oO]/)) {
          source.eatWhile(octitRE); // should require at least 1
          return "number";
        }
      }
      source.eatWhile(digitRE);
      var t = "number";
      if (source.match(/^\.\d+/)) {
        t = "number";
      }
      if (source.eat(/[eE]/)) {
        t = "number";
        source.eat(/[-+]/);
        source.eatWhile(digitRE); // should require at least 1
      }
      return t;
    }

    if (ch == "." &amp;&amp; source.eat("."))
      return "keyword";

    if (symbolRE.test(ch)) {
      if (ch == '-' &amp;&amp; source.eat(/-/)) {
        source.eatWhile(/-/);
        if (!source.eat(symbolRE)) {
          source.skipToEnd();
          return "comment";
        }
      }
      var t = "variable";
      if (ch == ':') {
        t = "variable-2";
      }
      source.eatWhile(symbolRE);
      return t;
    }

    return "error";
  }

  function ncomment(type, nest) {
    if (nest == 0) {
      return normal;
    }
    return function(source, setState) {
      var currNest = nest;
      while (!source.eol()) {
        var ch = source.next();
        if (ch == '{' &amp;&amp; source.eat('-')) {
          ++currNest;
        }
        else if (ch == '-' &amp;&amp; source.eat('}')) {
          --currNest;
          if (currNest == 0) {
            setState(normal);
            return type;
          }
        }
      }
      setState(ncomment(type, currNest));
      return type;
    };
  }

  function stringLiteral(source, setState) {
    while (!source.eol()) {
      var ch = source.next();
      if (ch == '"') {
        setState(normal);
        return "string";
      }
      if (ch == '\\') {
        if (source.eol() || source.eat(whiteCharRE)) {
          setState(stringGap);
          return "string";
        }
        if (source.eat('&amp;')) {
        }
        else {
          source.next(); // should handle other escapes here
        }
      }
    }
    setState(normal);
    return "string error";
  }

  function stringGap(source, setState) {
    if (source.eat('\\')) {
      return switchState(source, setState, stringLiteral);
    }
    source.next();
    setState(normal);
    return "error";
  }


  var wellKnownWords = (function() {
    var wkw = {};
    function setType(t) {
      return function () {
        for (var i = 0; i &lt; arguments.length; i++)
          wkw[arguments[i]] = t;
      };
    }

    setType("keyword")( ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.haskell-literate" id="apidoc.element.codemirror.modes.haskell-literate">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>haskell-literate
        <span class="apidocSignatureSpan">(config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">haskell-literate = function (config, parserConfig) {
  var baseMode = CodeMirror.getMode(config, (parserConfig &amp;&amp; parserConfig.base) || "haskell")

  return {
    startState: function () {
      return {
        inCode: false,
        baseState: CodeMirror.startState(baseMode)
      }
    },
    token: function (stream, state) {
      if (stream.sol()) {
        if (state.inCode = stream.eat("&gt;"))
          return "meta"
      }
      if (state.inCode) {
        return baseMode.token(stream, state.baseState)
      } else {
        stream.skipToEnd()
        return "comment"
      }
    },
    innerMode: function (state) {
      return state.inCode ? {state: state.baseState, mode: baseMode} : null
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.haxe" id="apidoc.element.codemirror.modes.haxe">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>haxe
        <span class="apidocSignatureSpan">(config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">haxe = function (config, parserConfig) {
  var indentUnit = config.indentUnit;

  // Tokenizer

  function kw(type) {return {type: type, style: "keyword"};}
  var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
  var operator = kw("operator"), atom = {type: "atom", style: "atom"}, attribute = {type:"attribute", style: "attribute"};
  var type = kw("typedef");
  var keywords = {
    "if": A, "while": A, "else": B, "do": B, "try": B,
    "return": C, "break": C, "continue": C, "new": C, "throw": C,
    "var": kw("var"), "inline":attribute, "static": attribute, "using":kw("import"),
    "public": attribute, "private": attribute, "cast": kw("cast"), "import": kw("import"), "macro": kw("macro"),
    "function": kw("function"), "catch": kw("catch"), "untyped": kw("untyped"), "callback": kw("cb"),
    "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
    "in": operator, "never": kw("property_access"), "trace":kw("trace"),
    "class": type, "abstract":type, "enum":type, "interface":type, "typedef":type, "extends":type, "implements":type, "dynamic":
type,
    "true": atom, "false": atom, "null": atom
  };

  var isOperatorChar = /[+\-*&amp;%=&lt;&gt;!?|]/;

  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }

  function toUnescaped(stream, end) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (next == end &amp;&amp; !escaped)
        return true;
      escaped = !escaped &amp;&amp; next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }

  function haxeTokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      return chain(stream, state, haxeTokenString(ch));
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "0" &amp;&amp; stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    } else if (/\d/.test(ch) || ch == "-" &amp;&amp; stream.eat(/\d/)) {
      stream.match(/^\d*(?:\.\d*(?!\.))?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    } else if (state.reAllowed &amp;&amp; (ch == "~" &amp;&amp; stream.eat(/\//))) {
      toUnescaped(stream, "/");
      stream.eatWhile(/[gimsu]/);
      return ret("regexp", "string-2");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        return chain(stream, state, haxeTokenComment);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else {
        stream.eatWhile(isOperatorChar);
        return ret("operator", null, stream.current());
      }
    } else if (ch == "#") {
        stream.skipToEnd();
        return ret("conditional", "meta");
    } else if (ch == "@") {
      stream.eat(/:/);
      stream.eatWhile(/[\w_]/);
      return ret ("metadata", "meta");
    } else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret("operator", null, stream.current());
    } else {
      var word;
      if(/[A-Z]/.test(ch)) {
        stream.eatWhile(/[\w_&lt;&gt;]/);
        word = stream.current();
        return ret("type", "variable-3", word);
      } else {
        stream.eatWhile(/[\w_]/);
        var word = stream.current(), known = keywords.propertyIsEnumerable(word) &amp;&amp; keywords[word];
        return (known &amp;&amp; state.kwAllowed) ? ret(known.type, known.style, word) :
                       ret("variable", "variable", word);
      }
    }
  }

  function haxeTokenString(quote) {
    return function(stream, state) {
      if (toUnescaped(stream, quote))
        state.tokenize = haxeTokenBase;
      return ret("string", "string");
    };
  }

  function haxeTokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" &amp;&amp; maybeEnd) {
        state.tokenize = haxeTokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  // Pars ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.htmlembedded" id="apidoc.element.codemirror.modes.htmlembedded">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>htmlembedded
        <span class="apidocSignatureSpan">(config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">htmlembedded = function (config, parserConfig) {
  return CodeMirror.multiplexingMode(CodeMirror.getMode(config, "htmlmixed"), {
    open: parserConfig.open || parserConfig.scriptStartRegex || "&lt;%",
    close: parserConfig.close || parserConfig.scriptEndRegex || "%&gt;",
    mode: CodeMirror.getMode(config, parserConfig.scriptingModeSpec)
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.htmlmixed" id="apidoc.element.codemirror.modes.htmlmixed">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>htmlmixed
        <span class="apidocSignatureSpan">(config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">htmlmixed = function (config, parserConfig) {
  var htmlMode = CodeMirror.getMode(config, {
    name: "xml",
    htmlMode: true,
    multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
    multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag
  });

  var tags = {};
  var configTags = parserConfig &amp;&amp; parserConfig.tags, configScript = parserConfig &amp;&amp; parserConfig.scriptTypes;
  addTags(defaultTags, tags);
  if (configTags) addTags(configTags, tags);
  if (configScript) for (var i = configScript.length - 1; i &gt;= 0; i--)
    tags.script.unshift(["type", configScript[i].matches, configScript[i].mode])

  function html(stream, state) {
    var style = htmlMode.token(stream, state.htmlState), tag = /\btag\b/.test(style), tagName
    if (tag &amp;&amp; !/[&lt;&gt;\s\/]/.test(stream.current()) &amp;&amp;
        (tagName = state.htmlState.tagName &amp;&amp; state.htmlState.tagName.toLowerCase()) &amp;&amp;
        tags.hasOwnProperty(tagName)) {
      state.inTag = tagName + " "
    } else if (state.inTag &amp;&amp; tag &amp;&amp; /&gt;$/.test(stream.current())) {
      var inTag = /^([\S]+) (.*)/.exec(state.inTag)
      state.inTag = null
      var modeSpec = stream.current() == "&gt;" &amp;&amp; findMatchingMode(tags[inTag[1]], inTag[2])
      var mode = CodeMirror.getMode(config, modeSpec)
      var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
      state.token = function (stream, state) {
        if (stream.match(endTagA, false)) {
          state.token = html;
          state.localState = state.localMode = null;
          return null;
        }
        return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
      };
      state.localMode = mode;
      state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, ""));
    } else if (state.inTag) {
      state.inTag += stream.current()
      if (stream.eol()) state.inTag += " "
    }
    return style;
  };

  return {
    startState: function () {
      var state = CodeMirror.startState(htmlMode);
      return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};
    },

    copyState: function (state) {
      var local;
      if (state.localState) {
        local = CodeMirror.copyState(state.localMode, state.localState);
      }
      return {token: state.token, inTag: state.inTag,
              localMode: state.localMode, localState: local,
              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
    },

    token: function (stream, state) {
      return state.token(stream, state);
    },

    indent: function (state, textAfter) {
      if (!state.localMode || /^\s*&lt;\//.test(textAfter))
        return htmlMode.indent(state.htmlState, textAfter);
      else if (state.localMode.indent)
        return state.localMode.indent(state.localState, textAfter);
      else
        return CodeMirror.Pass;
    },

    innerMode: function (state) {
      return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.http" id="apidoc.element.codemirror.modes.http">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>http
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">http = function () {
  function failFirstLine(stream, state) {
    stream.skipToEnd();
    state.cur = header;
    return "error";
  }

  function start(stream, state) {
    if (stream.match(/^HTTP\/\d\.\d/)) {
      state.cur = responseStatusCode;
      return "keyword";
    } else if (stream.match(/^[A-Z]+/) &amp;&amp; /[ \t]/.test(stream.peek())) {
      state.cur = requestPath;
      return "keyword";
    } else {
      return failFirstLine(stream, state);
    }
  }

  function responseStatusCode(stream, state) {
    var code = stream.match(/^\d+/);
    if (!code) return failFirstLine(stream, state);

    state.cur = responseStatusText;
    var status = Number(code[0]);
    if (status &gt;= 100 &amp;&amp; status &lt; 200) {
      return "positive informational";
    } else if (status &gt;= 200 &amp;&amp; status &lt; 300) {
      return "positive success";
    } else if (status &gt;= 300 &amp;&amp; status &lt; 400) {
      return "positive redirect";
    } else if (status &gt;= 400 &amp;&amp; status &lt; 500) {
      return "negative client-error";
    } else if (status &gt;= 500 &amp;&amp; status &lt; 600) {
      return "negative server-error";
    } else {
      return "error";
    }
  }

  function responseStatusText(stream, state) {
    stream.skipToEnd();
    state.cur = header;
    return null;
  }

  function requestPath(stream, state) {
    stream.eatWhile(/\S/);
    state.cur = requestProtocol;
    return "string-2";
  }

  function requestProtocol(stream, state) {
    if (stream.match(/^HTTP\/\d\.\d$/)) {
      state.cur = header;
      return "keyword";
    } else {
      return failFirstLine(stream, state);
    }
  }

  function header(stream) {
    if (stream.sol() &amp;&amp; !stream.eat(/[ \t]/)) {
      if (stream.match(/^.*?:/)) {
        return "atom";
      } else {
        stream.skipToEnd();
        return "error";
      }
    } else {
      stream.skipToEnd();
      return "string";
    }
  }

  function body(stream) {
    stream.skipToEnd();
    return null;
  }

  return {
    token: function(stream, state) {
      var cur = state.cur;
      if (cur != header &amp;&amp; cur != body &amp;&amp; stream.eatSpace()) return null;
      return cur(stream, state);
    },

    blankLine: function(state) {
      state.cur = body;
    },

    startState: function() {
      return {cur: start};
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.hxml" id="apidoc.element.codemirror.modes.hxml">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>hxml
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hxml = function () {

  return {
    startState: function () {
      return {
        define: false,
        inString: false
      };
    },
    token: function (stream, state) {
      var ch = stream.peek();
      var sol = stream.sol();

      //<span class="apidocCodeCommentSpan">/* comments */
</span>      if (ch == "#") {
        stream.skipToEnd();
        return "comment";
      }
      if (sol &amp;&amp; ch == "-") {
        var style = "variable-2";

        stream.eat(/-/);

        if (stream.peek() == "-") {
          stream.eat(/-/);
          style = "keyword a";
        }

        if (stream.peek() == "D") {
          stream.eat(/[D]/);
          style = "keyword c";
          state.define = true;
        }

        stream.eatWhile(/[A-Z]/i);
        return style;
      }

      var ch = stream.peek();

      if (state.inString == false &amp;&amp; ch == "'") {
        state.inString = true;
        ch = stream.next();
      }

      if (state.inString == true) {
        if (stream.skipTo("'")) {

        } else {
          stream.skipToEnd();
        }

        if (stream.peek() == "'") {
          stream.next();
          state.inString = false;
        }

        return "string";
      }

      stream.next();
      return null;
    },
    lineComment: "#"
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.idl" id="apidoc.element.codemirror.modes.idl">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>idl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">idl = function () {
  return {
    token: function(stream) {
      return tokenBase(stream);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.javascript" id="apidoc.element.codemirror.modes.javascript">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>javascript
        <span class="apidocSignatureSpan">(config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">javascript = function (config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;
  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    var jsKeywords = {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": C, "break": C, "continue": C, "new": kw("new"), "delete": C, "throw": C, "debugger": C,
      "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
      "await": C, "async": kw("async")
    };

    // Extend the 'normal' keywords with the TypeScript language extensions
    if (isTS) {
      var type = {type: "variable", style: "variable-3"};
      var tsKeywords = {
        // object-like things
        "interface": kw("class"),
        "implements": C,
        "namespace": C,
        "module": kw("module"),
        "enum": kw("module"),
        "type": kw("type"),

        // scope modifiers
        "public": kw("modifier"),
        "private": kw("modifier"),
        "protected": kw("modifier"),
        "abstract": kw("modifier"),

        // operators
        "as": operator,

        // types
        "string": type, "number": type, "boolean": type, "any": type
      };

      for (var attr in tsKeywords) {
        jsKeywords[attr] = tsKeywords[attr];
      }
    }

    return jsKeywords;
  }();

  var isOperatorChar = /[+\-*&amp;%=&lt;&gt;!?|~^@]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" &amp;&amp; !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet &amp;&amp; next == "]") inSet = false;
      }
      escaped = !escaped &amp;&amp; next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." &amp;&amp; stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
      return ret("number", "number");
    } else if (ch == "." &amp;&amp; stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" &amp;&amp; stream.eat("&gt;")) {
      return ret("=&gt;", "operator");
    } else if (ch == "0" &amp;&amp; stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    } else if (ch == "0" &amp;&amp; stream.eat(/o/i)) {
      stream.eatWhile(/[0-7]/i);
      return ret("number", "number");
    } else if (ch == "0" &amp;&amp; stream.eat(/b/i)) {
      stream.eatWhile(/[01]/i);
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stre ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.jinja2" id="apidoc.element.codemirror.modes.jinja2">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>jinja2
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jinja2 = function () {
  var keywords = ["and", "as", "block", "endblock", "by", "cycle", "debug", "else", "elif",
    "extends", "filter", "endfilter", "firstof", "for",
    "endfor", "if", "endif", "ifchanged", "endifchanged",
    "ifequal", "endifequal", "ifnotequal",
    "endifnotequal", "in", "include", "load", "not", "now", "or",
    "parsed", "regroup", "reversed", "spaceless",
    "endspaceless", "ssi", "templatetag", "openblock",
    "closeblock", "openvariable", "closevariable",
    "openbrace", "closebrace", "opencomment",
    "closecomment", "widthratio", "url", "with", "endwith",
    "get_current_language", "trans", "endtrans", "noop", "blocktrans",
    "endblocktrans", "get_available_languages",
    "get_current_language_bidi", "plural"],
  operator = /^[+\-*&amp;%=&lt;&gt;!?|~^]/,
  sign = /^[:\[\(\{]/,
  atom = ["true", "false"],
  number = /^(\d[+\-\*\/])?\d+(\.\d+)?/;

  keywords = new RegExp("((" + keywords.join(")|(") + "))\\b");
  atom = new RegExp("((" + atom.join(")|(") + "))\\b");

  function tokenBase (stream, state) {
    var ch = stream.peek();

    //Comment
    if (state.incomment) {
      if(!stream.skipTo("#}")) {
        stream.skipToEnd();
      } else {
        stream.eatWhile(/\#|}/);
        state.incomment = false;
      }
      return "comment";
    //Tag
    } else if (state.intag) {
      //After operator
      if(state.operator) {
        state.operator = false;
        if(stream.match(atom)) {
          return "atom";
        }
        if(stream.match(number)) {
          return "number";
        }
      }
      //After sign
      if(state.sign) {
        state.sign = false;
        if(stream.match(atom)) {
          return "atom";
        }
        if(stream.match(number)) {
          return "number";
        }
      }

      if(state.instring) {
        if(ch == state.instring) {
          state.instring = false;
        }
        stream.next();
        return "string";
      } else if(ch == "'" || ch == '"') {
        state.instring = ch;
        stream.next();
        return "string";
      } else if(stream.match(state.intag + "}") || stream.eat("-") &amp;&amp; stream.match(state.intag + "}")) {
        state.intag = false;
        return "tag";
      } else if(stream.match(operator)) {
        state.operator = true;
        return "operator";
      } else if(stream.match(sign)) {
        state.sign = true;
      } else {
        if(stream.eat(" ") || stream.sol()) {
          if(stream.match(keywords)) {
            return "keyword";
          }
          if(stream.match(atom)) {
            return "atom";
          }
          if(stream.match(number)) {
            return "number";
          }
          if(stream.sol()) {
            stream.next();
          }
        } else {
          stream.next();
        }

      }
      return "variable";
    } else if (stream.eat("{")) {
      if (ch = stream.eat("#")) {
        state.incomment = true;
        if(!stream.skipTo("#}")) {
          stream.skipToEnd();
        } else {
          stream.eatWhile(/\#|}/);
          state.incomment = false;
        }
        return "comment";
      //Open tag
      } else if (ch = stream.eat(/\{|%/)) {
        //Cache close tag
        state.intag = ch;
        if(ch == "{") {
          state.intag = "}";
        }
        stream.eat("-");
        return "tag";
      }
    }
    stream.next();
  };

  return {
    startState: function () {
      return {tokenize: tokenBase};
    },
    token: function (stream, state) {
      return state.tokenize(stream, state);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.jsx" id="apidoc.element.codemirror.modes.jsx">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>jsx
        <span class="apidocSignatureSpan">(config, modeConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsx = function (config, modeConfig) {
  var xmlMode = CodeMirror.getMode(config, {name: "xml", allowMissing: true, multilineTagIndentPastTag: false})
  var jsMode = CodeMirror.getMode(config, modeConfig &amp;&amp; modeConfig.base || "javascript")

  function flatXMLIndent(state) {
    var tagName = state.tagName
    state.tagName = null
    var result = xmlMode.indent(state, "")
    state.tagName = tagName
    return result
  }

  function token(stream, state) {
    if (state.context.mode == xmlMode)
      return xmlToken(stream, state, state.context)
    else
      return jsToken(stream, state, state.context)
  }

  function xmlToken(stream, state, cx) {
    if (cx.depth == 2) { // Inside a JS /* */ comment
      if (stream.match(/^.*?\*\//)) cx.depth = 1
      else stream.skipToEnd()
      return "comment"
    }

    if (stream.peek() == "{") {
      xmlMode.skipAttribute(cx.state)

      var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context
      // If JS starts on same line as tag
      if (xmlContext &amp;&amp; stream.match(/^[^&gt;]*&gt;\s*$/, false)) {
        while (xmlContext.prev &amp;&amp; !xmlContext.startOfLine)
          xmlContext = xmlContext.prev
        // If tag starts the line, use XML indentation level
        if (xmlContext.startOfLine) indent -= config.indentUnit
        // Else use JS indentation level
        else if (cx.prev.state.lexical) indent = cx.prev.state.lexical.indented
      // Else if inside of tag
      } else if (cx.depth == 1) {
        indent += config.indentUnit
      }

      state.context = new Context(CodeMirror.startState(jsMode, indent),
                                  jsMode, 0, state.context)
      return null
    }

    if (cx.depth == 1) { // Inside of tag
      if (stream.peek() == "&lt;") { // Tag inside of tag
        xmlMode.skipAttribute(cx.state)
        state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)),
                                    xmlMode, 0, state.context)
        return null
      } else if (stream.match("//")) {
        stream.skipToEnd()
        return "comment"
      } else if (stream.match("/*")) {
        cx.depth = 2
        return token(stream, state)
      }
    }

    var style = xmlMode.token(stream, cx.state), cur = stream.current(), stop
    if (/\btag\b/.test(style)) {
      if (/&gt;$/.test(cur)) {
        if (cx.state.context) cx.depth = 0
        else state.context = state.context.prev
      } else if (/^&lt;/.test(cur)) {
        cx.depth = 1
      }
    } else if (!style &amp;&amp; (stop = cur.indexOf("{")) &gt; -1) {
      stream.backUp(cur.length - stop)
    }
    return style
  }

  function jsToken(stream, state, cx) {
    if (stream.peek() == "&lt;" &amp;&amp; jsMode.expressionAllowed(stream, cx.state)) {
      jsMode.skipExpression(cx.state)
      state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, "")),
                                  xmlMode, 0, state.context)
      return null
    }

    var style = jsMode.token(stream, cx.state)
    if (!style &amp;&amp; cx.depth != null) {
      var cur = stream.current()
      if (cur == "{") {
        cx.depth++
      } else if (cur == "}") {
        if (--cx.depth == 0) state.context = state.context.prev
      }
    }
    return style
  }

  return {
    startState: function() {
      return {context: new Context(CodeMirror.startState(jsMode), jsMode)}
    },

    copyState: function(state) {
      return {context: copyContext(state.context)}
    },

    token: token,

    indent: function(state, textAfter, fullLine) {
      return state.context.mode.indent(state.context.state, textAfter, fullLine)
    },

    innerMode: function(state) {
      return state.context
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.julia" id="apidoc.element.codemirror.modes.julia">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>julia
        <span class="apidocSignatureSpan">(config, parserConf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">julia = function (config, parserConf) {
  function wordRegexp(words, end) {
    if (typeof end === "undefined") { end = "\\b"; }
    return new RegExp("^((" + words.join(")|(") + "))" + end);
  }

  var octChar = "\\\\[0-7]{1,3}";
  var hexChar = "\\\\x[A-Fa-f0-9]{1,2}";
  var sChar = "\\\\[abefnrtv0%?'\"\\\\]";
  var uChar = "([^\\u0027\\u005C\\uD800-\\uDFFF]|[\\uD800-\\uDFFF][\\uDC00-\\uDFFF])";

  var operators = parserConf.operators || wordRegexp([
      "\\.?[\\\\%*+\\-&lt;&gt;!=\\/^]=?", "\\.?[|&amp;\\u00F7\\u2260\\u2264\\u2265]",
      "\\u00D7", "\\u2208", "\\u2209", "\\u220B", "\\u220C", "\\u2229",
      "\\u222A", "\\u2286", "\\u2288", "\\u228A", "\\u22c5", "\\?", "~", ":",
      "\\$", "\\.[&lt;&gt;]", "&lt;&lt;=?", "&gt;&gt;&gt;?=?", "\\.[&lt;&gt;=]=", "-&gt;?", "\\/\\/", "=&gt;",
      "&lt;:", "\\bin\\b(?!\\()"], "");
  var delimiters = parserConf.delimiters || /^[;,()[\]{}]/;
  var identifiers = parserConf.identifiers || /^[_A-Za-z\u00A1-\uFFFF][\w\u00A1-\uFFFF]*!*/;

  var chars = wordRegexp([octChar, hexChar, sChar, uChar], "'");
  var openers = wordRegexp(["begin", "function", "type", "immutable", "let",
      "macro", "for", "while", "quote", "if", "else", "elseif", "try",
      "finally", "catch", "do"]);
  var closers = wordRegexp(["end", "else", "elseif", "catch", "finally"]);
  var keywords = wordRegexp(["if", "else", "elseif", "while", "for", "begin",
      "let", "end", "do", "try", "catch", "finally", "return", "break",
      "continue", "global", "local", "const", "export", "import", "importall",
      "using", "function", "macro", "module", "baremodule", "type",
      "immutable", "quote", "typealias", "abstract", "bitstype"]);
  var builtins = wordRegexp(["true", "false", "nothing", "NaN", "Inf"]);

  var macro = /^@[_A-Za-z][\w]*/;
  var symbol = /^:[_A-Za-z\u00A1-\uFFFF][\w\u00A1-\uFFFF]*!*/;
  var stringPrefixes = /^(`|([_A-Za-z\u00A1-\uFFFF]*"("")?))/;

  function inArray(state) {
    return inGenerator(state, '[')
  }

  function inGenerator(state, bracket) {
    var curr = currentScope(state),
        prev = currentScope(state, 1);
    if (typeof(bracket) === "undefined") { bracket = '('; }
    if (curr === bracket || (prev === bracket &amp;&amp; curr === "for")) {
      return true;
    }
    return false;
  }

  function currentScope(state, n) {
    if (typeof(n) === "undefined") { n = 0; }
    if (state.scopes.length &lt;= n) {
      return null;
    }
    return state.scopes[state.scopes.length - (n + 1)];
  }

  // tokenizers
  function tokenBase(stream, state) {
    // Handle multiline comments
    if (stream.match(/^#=/, false)) {
      state.tokenize = tokenComment;
      return state.tokenize(stream, state);
    }

    // Handle scope changes
    var leavingExpr = state.leavingExpr;
    if (stream.sol()) {
      leavingExpr = false;
    }
    state.leavingExpr = false;

    if (leavingExpr) {
      if (stream.match(/^'+/)) {
        return "operator";
      }
    }

    if (stream.match(/^\.{2,3}/)) {
      return "operator";
    }

    if (stream.eatSpace()) {
      return null;
    }

    var ch = stream.peek();

    // Handle single line comments
    if (ch === '#') {
      stream.skipToEnd();
      return "comment";
    }

    if (ch === '[') {
      state.scopes.push('[');
    }

    if (ch === '(') {
      state.scopes.push('(');
    }

    var scope = currentScope(state);

    if (inArray(state) &amp;&amp; ch === ']') {
      if (scope === "for") { state.scopes.pop(); }
      state.scopes.pop();
      state.leavingExpr = true;
    }

    if (inGenerator(state) &amp;&amp; ch === ')') {
      if (scope === "for") { state.scopes.pop(); }
      state.scopes.pop();
      state.leavingExpr = true;
    }

    var match;
    if (match = stream.match(openers, false)) {
      state.scopes.push(match[0]);
    }

    if (stream.match(closers, false)) {
      state.scopes.pop();
    }

    if (inArray(state)) {
      if (state.lastToken == "end" &amp;&amp; stream.match(/^:/)) {
        return "operator";
      }
      if (stream.match(/^end/)) {
        return "number";
      }
    }

    // Handle type annotations
    if (stream.match(/^::(?![:\$])/)) {
      state.toke ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.livescript" id="apidoc.element.codemirror.modes.livescript">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>livescript
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">livescript = function (){
  var tokenBase = function(stream, state) {
    var next_rule = state.next || "start";
    if (next_rule) {
      state.next = state.next;
      var nr = Rules[next_rule];
      if (nr.splice) {
        for (var i$ = 0; i$ &lt; nr.length; ++i$) {
          var r = nr[i$];
          if (r.regex &amp;&amp; stream.match(r.regex)) {
            state.next = r.next || state.next;
            return r.token;
          }
        }
        stream.next();
        return 'error';
      }
      if (stream.match(r = Rules[next_rule])) {
        if (r.regex &amp;&amp; stream.match(r.regex)) {
          state.next = r.next;
          return r.token;
        } else {
          stream.next();
          return 'error';
        }
      }
    }
    stream.next();
    return 'error';
  };
  var external = {
    startState: function(){
      return {
        next: 'start',
        lastToken: {style: null, indent: 0, content: ""}
      };
    },
    token: function(stream, state){
      while (stream.pos == stream.start)
        var style = tokenBase(stream, state);
      state.lastToken = {
        style: style,
        indent: stream.indentation(),
        content: stream.current()
      };
      return style.replace(/\./g, ' ');
    },
    indent: function(state){
      var indentation = state.lastToken.indent;
      if (state.lastToken.content.match(indenter)) {
        indentation += 2;
      }
      return indentation;
    }
  };
  return external;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.lua" id="apidoc.element.codemirror.modes.lua">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>lua
        <span class="apidocSignatureSpan">(config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lua = function (config, parserConfig) {
  var indentUnit = config.indentUnit;

  function prefixRE(words) {
    return new RegExp("^(?:" + words.join("|") + ")", "i");
  }
  function wordRE(words) {
    return new RegExp("^(?:" + words.join("|") + ")$", "i");
  }
  var specials = wordRE(parserConfig.specials || []);

  // long list of standard functions from lua manual
  var builtins = wordRE([
    "_G","_VERSION","assert","collectgarbage","dofile","error","getfenv","getmetatable","ipairs","load",
    "loadfile","loadstring","module","next","pairs","pcall","print","rawequal","rawget","rawset","require",
    "select","setfenv","setmetatable","tonumber","tostring","type","unpack","xpcall",

    "coroutine.create","coroutine.resume","coroutine.running","coroutine.status","coroutine.wrap","coroutine.yield",

    "debug.debug","debug.getfenv","debug.gethook","debug.getinfo","debug.getlocal","debug.getmetatable",
    "debug.getregistry","debug.getupvalue","debug.setfenv","debug.sethook","debug.setlocal","debug.setmetatable",
    "debug.setupvalue","debug.traceback",

    "close","flush","lines","read","seek","setvbuf","write",

    "io.close","io.flush","io.input","io.lines","io.open","io.output","io.popen","io.read","io.stderr","io.stdin",
    "io.stdout","io.tmpfile","io.type","io.write",

    "math.abs","math.acos","math.asin","math.atan","math.atan2","math.ceil","math.cos","math.cosh","math.deg",
    "math.exp","math.floor","math.fmod","math.frexp","math.huge","math.ldexp","math.log","math.log10","math.max",
    "math.min","math.modf","math.pi","math.pow","math.rad","math.random","math.randomseed","math.sin","math.sinh",
    "math.sqrt","math.tan","math.tanh",

    "os.clock","os.date","os.difftime","os.execute","os.exit","os.getenv","os.remove","os.rename","os.setlocale",
    "os.time","os.tmpname",

    "package.cpath","package.loaded","package.loaders","package.loadlib","package.path","package.preload",
    "package.seeall",

    "string.byte","string.char","string.dump","string.find","string.format","string.gmatch","string.gsub",
    "string.len","string.lower","string.match","string.rep","string.reverse","string.sub","string.upper",

    "table.concat","table.insert","table.maxn","table.remove","table.sort"
  ]);
  var keywords = wordRE(["and","break","elseif","false","nil","not","or","return",
                         "true","function", "end", "if", "then", "else", "do",
                         "while", "repeat", "until", "for", "in", "local" ]);

  var indentTokens = wordRE(["function", "if","repeat","do", "\\(", "{"]);
  var dedentTokens = wordRE(["end", "until", "\\)", "}"]);
  var dedentPartial = prefixRE(["end", "until", "\\)", "}", "else", "elseif"]);

  function readBracket(stream) {
    var level = 0;
    while (stream.eat("=")) ++level;
    stream.eat("[");
    return level;
  }

  function normal(stream, state) {
    var ch = stream.next();
    if (ch == "-" &amp;&amp; stream.eat("-")) {
      if (stream.eat("[") &amp;&amp; stream.eat("["))
        return (state.cur = bracketed(readBracket(stream), "comment"))(stream, state);
      stream.skipToEnd();
      return "comment";
    }
    if (ch == "\"" || ch == "'")
      return (state.cur = string(ch))(stream, state);
    if (ch == "[" &amp;&amp; /[\[=]/.test(stream.peek()))
      return (state.cur = bracketed(readBracket(stream), "string"))(stream, state);
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w.%]/);
      return "number";
    }
    if (/[\w_]/.test(ch)) {
      stream.eatWhile(/[\w\\\-_.]/);
      return "variable";
    }
    return null;
  }

  function bracketed(level, style) {
    return function(stream, state) {
      var curlev = null, ch;
      while ((ch = stream.next()) != null) {
        if (curlev == null) {if (ch == "]") curlev = 0;}
        else if (ch == "=") ++curlev;
        else if (ch == "]" &amp;&amp; curlev == level) { state.cur = normal; break; }
        else curlev = null;
      }
      return style;
    };
  }

  function string(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.markdown" id="apidoc.element.codemirror.modes.markdown">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>markdown
        <span class="apidocSignatureSpan">(cmCfg, modeCfg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">markdown = function (cmCfg, modeCfg) {

  var htmlMode = CodeMirror.getMode(cmCfg, "text/html");
  var htmlModeMissing = htmlMode.name == "null"

  function getMode(name) {
    if (CodeMirror.findModeByName) {
      var found = CodeMirror.findModeByName(name);
      if (found) name = found.mime || found.mimes[0];
    }
    var mode = CodeMirror.getMode(cmCfg, name);
    return mode.name == "null" ? null : mode;
  }

  // Should characters that affect highlighting be highlighted separate?
  // Does not include characters that will be output (such as `1.` and `-` for lists)
  if (modeCfg.highlightFormatting === undefined)
    modeCfg.highlightFormatting = false;

  // Maximum number of nested blockquotes. Set to 0 for infinite nesting.
  // Excess `&gt;` will emit `error` token.
  if (modeCfg.maxBlockquoteDepth === undefined)
    modeCfg.maxBlockquoteDepth = 0;

  // Use `fencedCodeBlocks` to configure fenced code blocks. false to
  // disable, string to specify a precise regexp that the fence should
  // match, and true to allow three or more backticks or tildes (as
  // per CommonMark).

  // Turn on task lists? ("- [ ] " and "- [x] ")
  if (modeCfg.taskLists === undefined) modeCfg.taskLists = false;

  // Turn on strikethrough syntax
  if (modeCfg.strikethrough === undefined)
    modeCfg.strikethrough = false;

  // Allow token types to be overridden by user-provided token types.
  if (modeCfg.tokenTypeOverrides === undefined)
    modeCfg.tokenTypeOverrides = {};

  var tokenTypes = {
    header: "header",
    code: "comment",
    quote: "quote",
    list1: "variable-2",
    list2: "variable-3",
    list3: "keyword",
    hr: "hr",
    image: "image",
    imageAltText: "image-alt-text",
    imageMarker: "image-marker",
    formatting: "formatting",
    linkInline: "link",
    linkEmail: "link",
    linkText: "link",
    linkHref: "string",
    em: "em",
    strong: "strong",
    strikethrough: "strikethrough"
  };

  for (var tokenType in tokenTypes) {
    if (tokenTypes.hasOwnProperty(tokenType) &amp;&amp; modeCfg.tokenTypeOverrides[tokenType]) {
      tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType];
    }
  }

  var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/
  ,   listRE = /^(?:[*\-+]|^[0-9]+([.)]))\s+/
  ,   taskListRE = /^\[(x| )\](?=\s)/ // Must follow listRE
  ,   atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/
  ,   setextHeaderRE = /^ *(?:\={1,}|-{1,})\s*$/
  ,   textRE = /^[^#!\[\]*_\\&lt;&gt;` "'(~]+/
  ,   fencedCodeRE = new RegExp("^(" + (modeCfg.fencedCodeBlocks === true ? "~~~+|```+" : modeCfg.fencedCodeBlocks) +
                                ")[ \\t]*([\\w+#\-]*)")
  ,   punctuation = /[!\"#$%&amp;\'()*+,\-\.\/:;&lt;=&gt;?@\[\\\]^_`{|}~â€”]/

  function switchInline(stream, state, f) {
    state.f = state.inline = f;
    return f(stream, state);
  }

  function switchBlock(stream, state, f) {
    state.f = state.block = f;
    return f(stream, state);
  }

  function lineIsEmpty(line) {
    return !line || !/\S/.test(line.string)
  }

  // Blocks

  function blankLine(state) {
    // Reset linkTitle state
    state.linkTitle = false;
    // Reset EM state
    state.em = false;
    // Reset STRONG state
    state.strong = false;
    // Reset strikethrough state
    state.strikethrough = false;
    // Reset state.quote
    state.quote = 0;
    // Reset state.indentedCode
    state.indentedCode = false;
    if (state.f == htmlBlock) {
      state.f = inlineNormal;
      state.block = blockNormal;
    }
    // Reset state.trailingSpace
    state.trailingSpace = 0;
    state.trailingSpaceNewLine = false;
    // Mark this line as blank
    state.prevLine = state.thisLine
    state.thisLine = null
    return null;
  }

  function blockNormal(stream, state) {

    var sol = stream.sol();

    var prevLineIsList = state.list !== false,
        prevLineIsIndentedCode = state.indentedCode;

    state.indentedCode = false;

    if (prevLineIsList) {
      if (state.indentationDiff &gt;= 0) { // Continued list
        if (state.indentationDiff &lt; 4) { // Only adjust indentation if *not* a code block
          state.indentatio ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.mathematica" id="apidoc.element.codemirror.modes.mathematica">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>mathematica
        <span class="apidocSignatureSpan">(_config, _parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mathematica = function (_config, _parserConfig) {

  // used pattern building blocks
  var Identifier = '[a-zA-Z\\$][a-zA-Z0-9\\$]*';
  var pBase      = "(?:\\d+)";
  var pFloat     = "(?:\\.\\d+|\\d+\\.\\d*|\\d+)";
  var pFloatBase = "(?:\\.\\w+|\\w+\\.\\w*|\\w+)";
  var pPrecision = "(?:`(?:`?"+pFloat+")?)";

  // regular expressions
  var reBaseForm        = new RegExp('(?:'+pBase+'(?:\\^\\^'+pFloatBase+pPrecision+'?(?:\\*\\^[+-]?\\d+)?))');
  var reFloatForm       = new RegExp('(?:' + pFloat + pPrecision + '?(?:\\*\\^[+-]?\\d+)?)');
  var reIdInContext     = new RegExp('(?:`?)(?:' + Identifier + ')(?:`(?:' + Identifier + '))*(?:`?)');

  function tokenBase(stream, state) {
    var ch;

    // get next character
    ch = stream.next();

    // string
    if (ch === '"') {
      state.tokenize = tokenString;
      return state.tokenize(stream, state);
    }

    // comment
    if (ch === '(') {
      if (stream.eat('*')) {
        state.commentLevel++;
        state.tokenize = tokenComment;
        return state.tokenize(stream, state);
      }
    }

    // go back one character
    stream.backUp(1);

    // look for numbers
    // Numbers in a baseform
    if (stream.match(reBaseForm, true, false)) {
      return 'number';
    }

    // Mathematica numbers. Floats (1.2, .2, 1.) can have optionally a precision (`float) or an accuracy definition
    // (``float). Note: while 1.2` is possible 1.2`` is not. At the end an exponent (float*^+12) can follow.
    if (stream.match(reFloatForm, true, false)) {
      return 'number';
    }

<span class="apidocCodeCommentSpan">    /* In[23] and Out[34] */
</span>    if (stream.match(/(?:In|Out)\[[0-9]*\]/, true, false)) {
      return 'atom';
    }

    // usage
    if (stream.match(/([a-zA-Z\$]+(?:`?[a-zA-Z0-9\$])*::usage)/, true, false)) {
      return 'meta';
    }

    // message
    if (stream.match(/([a-zA-Z\$]+(?:`?[a-zA-Z0-9\$])*::[a-zA-Z\$][a-zA-Z0-9\$]*):?/, true, false)) {
      return 'string-2';
    }

    // this makes a look-ahead match for something like variable:{_Integer}
    // the match is then forwarded to the mma-patterns tokenizer.
    if (stream.match(/([a-zA-Z\$][a-zA-Z0-9\$]*\s*:)(?:(?:[a-zA-Z\$][a-zA-Z0-9\$]*)|(?:[^:=&gt;~@\^\&amp;\*\)\[\]'\?,\|])).*/, true, false
)) {
      return 'variable-2';
    }

    // catch variables which are used together with Blank (_), BlankSequence (__) or BlankNullSequence (___)
    // Cannot start with a number, but can have numbers at any other position. Examples
    // blub__Integer, a1_, b34_Integer32
    if (stream.match(/[a-zA-Z\$][a-zA-Z0-9\$]*_+[a-zA-Z\$][a-zA-Z0-9\$]*/, true, false)) {
      return 'variable-2';
    }
    if (stream.match(/[a-zA-Z\$][a-zA-Z0-9\$]*_+/, true, false)) {
      return 'variable-2';
    }
    if (stream.match(/_+[a-zA-Z\$][a-zA-Z0-9\$]*/, true, false)) {
      return 'variable-2';
    }

    // Named characters in Mathematica, like \[Gamma].
    if (stream.match(/\\\[[a-zA-Z\$][a-zA-Z0-9\$]*\]/, true, false)) {
      return 'variable-3';
    }

    // Match all braces separately
    if (stream.match(/(?:\[|\]|{|}|\(|\))/, true, false)) {
      return 'bracket';
    }

    // Catch Slots (#, ##, #3, ##9 and the V10 named slots #name). I have never seen someone using more than one digit after #,
so we match
    // only one.
    if (stream.match(/(?:#[a-zA-Z\$][a-zA-Z0-9\$]*|#+[0-9]?)/, true, false)) {
      return 'variable-2';
    }

    // Literals like variables, keywords, functions
    if (stream.match(reIdInContext, true, false)) {
      return 'keyword';
    }

    // operators. Note that operators like @@ or /; are matched separately for each symbol.
    if (stream.match(/(?:\\|\+|\-|\*|\/|,|;|\.|:|@|~|=|&gt;|&lt;|&amp;|\||_|`|'|\^|\?|!|%)/, true, false)) {
      return 'operator';
    }

    // everything else is an error
    stream.next(); // advance the stream.
    return 'error';
  }

  function tokenString(stream, state) {
    var next, end = false, escaped = false;
    while ((next = stream.next()) != null) {
      if (next === '"' &amp;&amp; !escaped) {
        end = true;
        break;
      }
      escaped = !escaped &amp;&amp; next === '\\';
    }
    if (end ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.mbox" id="apidoc.element.codemirror.modes.mbox">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>mbox
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mbox = function () {
  return {
    startState: function() {
      return {
        // Is in a mbox separator
        inSeparator: false,
        // Is in a mail header
        inHeader: false,
        // If bracketed email is permitted. Only applicable when inHeader
        emailPermitted: false,
        // Name of current header
        header: null,
        // Is in a region of mail headers
        inHeaders: false
      };
    },
    token: readToken,
    blankLine: function(state) {
      state.inHeaders = state.inSeparator = state.inHeader = false;
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.mirc" id="apidoc.element.codemirror.modes.mirc">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>mirc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mirc = function () {
  function parseWords(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i &lt; words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var specials = parseWords("$! $$ $&amp; $? $+ $abook $abs $active $activecid " +
                            "$activewid $address $addtok $agent $agentname $agentstat $agentver " +
                            "$alias $and $anick $ansi2mirc $aop $appactive $appstate $asc $asctime " +
                            "$asin $atan $avoice $away $awaymsg $awaytime $banmask $base $bfind " +
                            "$binoff $biton $bnick $bvar $bytes $calc $cb $cd $ceil $chan $chanmodes " +
                            "$chantypes $chat $chr $cid $clevel $click $cmdbox $cmdline $cnick $color " +
                            "$com $comcall $comchan $comerr $compact $compress $comval $cos $count " +
                            "$cr $crc $creq $crlf $ctime $ctimer $ctrlenter $date $day $daylight " +
                            "$dbuh $dbuw $dccignore $dccport $dde $ddename $debug $decode $decompress " +
                            "$deltok $devent $dialog $did $didreg $didtok $didwm $disk $dlevel $dll " +
                            "$dllcall $dname $dns $duration $ebeeps $editbox $emailaddr $encode $error " +
                            "$eval $event $exist $feof $ferr $fgetc $file $filename $filtered $finddir " +
                            "$finddirn $findfile $findfilen $findtok $fline $floor $fopen $fread $fserve " +
                            "$fulladdress $fulldate $fullname $fullscreen $get $getdir $getdot $gettok $gmt " +
                            "$group $halted $hash $height $hfind $hget $highlight $hnick $hotline " +
                            "$hotlinepos $ial $ialchan $ibl $idle $iel $ifmatch $ignore $iif $iil " +
                            "$inelipse $ini $inmidi $inpaste $inpoly $input $inrect $inroundrect " +
                            "$insong $instok $int $inwave $ip $isalias $isbit $isdde $isdir $isfile " +
                            "$isid $islower $istok $isupper $keychar $keyrpt $keyval $knick $lactive " +
                            "$lactivecid $lactivewid $left $len $level $lf $line $lines $link $lock " +
                            "$lock $locked $log $logstamp $logstampfmt $longfn $longip $lower $ltimer " +
                            "$maddress $mask $matchkey $matchtok $md5 $me $menu $menubar $menucontext " +
                            "$menutype $mid $middir $mircdir $mircexe $mircini $mklogfn $mnick $mode " +
                            "$modefirst $modelast $modespl $mouse $msfile $network $newnick $nick $nofile " +
                            "$nopath $noqt $not $notags $notify $null $numeric $numok $oline $onpoly " +
                            "$opnick $or $ord $os $passivedcc $pic $play $pnick $port $portable $portfree " +
                            "$pos $prefix $prop $protect $puttok $qt $query $rand $r $rawmsg $read $readomo " +
                            "$readn $regex $regml $regsub $regsubex $remove $remtok $replace $replacex " +
                            "$reptok $result $rgb $right $round $scid $scon $script $scriptdir $scriptline " +
                            "$sdir $send $server $serverip $sfile $sha1 $shortfn $show $signal $sin " +
                            "$site $sline $snick $snicks $snotify $sock $sockbr $sockerr $sockname " +
                            "$sorttok $sound $sqrt $ssl $sreq $sslready $status $strip $str $stripped " +
                            "$syle $submenu $switchbar $tan $target $ticks $time $timer $timestamp " +
                            "$timestampfmt $timezone $tip $titlebar $toolbar $treebar $trust $ulevel " +
                            "$ulist $upper $uptime $url $usermode $v1 $v2 $var $vcmd $vcmdstat $vcmdver " +
                            "$version $vnick $vol $wid $width $wildsite $wildtok $window $wrap $xor");
  var keywords = parseWords("abook ajinvite alias aline ame amsg anick aop auser autojoin avoice " +
                            "away background ban bcopy beep b ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.mllike" id="apidoc.element.codemirror.modes.mllike">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>mllike
        <span class="apidocSignatureSpan">(_config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mllike = function (_config, parserConfig) {
  var words = {
    'let': 'keyword',
    'rec': 'keyword',
    'in': 'keyword',
    'of': 'keyword',
    'and': 'keyword',
    'if': 'keyword',
    'then': 'keyword',
    'else': 'keyword',
    'for': 'keyword',
    'to': 'keyword',
    'while': 'keyword',
    'do': 'keyword',
    'done': 'keyword',
    'fun': 'keyword',
    'function': 'keyword',
    'val': 'keyword',
    'type': 'keyword',
    'mutable': 'keyword',
    'match': 'keyword',
    'with': 'keyword',
    'try': 'keyword',
    'open': 'builtin',
    'ignore': 'builtin',
    'begin': 'keyword',
    'end': 'keyword'
  };

  var extraWords = parserConfig.extraWords || {};
  for (var prop in extraWords) {
    if (extraWords.hasOwnProperty(prop)) {
      words[prop] = parserConfig.extraWords[prop];
    }
  }

  function tokenBase(stream, state) {
    var ch = stream.next();

    if (ch === '"') {
      state.tokenize = tokenString;
      return state.tokenize(stream, state);
    }
    if (ch === '(') {
      if (stream.eat('*')) {
        state.commentLevel++;
        state.tokenize = tokenComment;
        return state.tokenize(stream, state);
      }
    }
    if (ch === '~') {
      stream.eatWhile(/\w/);
      return 'variable-2';
    }
    if (ch === '`') {
      stream.eatWhile(/\w/);
      return 'quote';
    }
    if (ch === '/' &amp;&amp; parserConfig.slashComments &amp;&amp; stream.eat('/')) {
      stream.skipToEnd();
      return 'comment';
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\d]/);
      if (stream.eat('.')) {
        stream.eatWhile(/[\d]/);
      }
      return 'number';
    }
    if ( /[+\-*&amp;%=&lt;&gt;!?|]/.test(ch)) {
      return 'operator';
    }
    if (/[\w\xa1-\uffff]/.test(ch)) {
      stream.eatWhile(/[\w\xa1-\uffff]/);
      var cur = stream.current();
      return words.hasOwnProperty(cur) ? words[cur] : 'variable';
    }
    return null
  }

  function tokenString(stream, state) {
    var next, end = false, escaped = false;
    while ((next = stream.next()) != null) {
      if (next === '"' &amp;&amp; !escaped) {
        end = true;
        break;
      }
      escaped = !escaped &amp;&amp; next === '\\';
    }
    if (end &amp;&amp; !escaped) {
      state.tokenize = tokenBase;
    }
    return 'string';
  };

  function tokenComment(stream, state) {
    var prev, next;
    while(state.commentLevel &gt; 0 &amp;&amp; (next = stream.next()) != null) {
      if (prev === '(' &amp;&amp; next === '*') state.commentLevel++;
      if (prev === '*' &amp;&amp; next === ')') state.commentLevel--;
      prev = next;
    }
    if (state.commentLevel &lt;= 0) {
      state.tokenize = tokenBase;
    }
    return 'comment';
  }

  return {
    startState: function() {return {tokenize: tokenBase, commentLevel: 0};},
    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      return state.tokenize(stream, state);
    },

    blockCommentStart: "(*",
    blockCommentEnd: "*)",
    lineComment: parserConfig.slashComments ? "//" : null
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.modelica" id="apidoc.element.codemirror.modes.modelica">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>modelica
        <span class="apidocSignatureSpan">(config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">modelica = function (config, parserConfig) {

  var indentUnit = config.indentUnit;
  var keywords = parserConfig.keywords || {};
  var builtin = parserConfig.builtin || {};
  var atoms = parserConfig.atoms || {};

  var isSingleOperatorChar = /[;=\(:\),{}.*&lt;&gt;+\-\/^\[\]]/;
  var isDoubleOperatorChar = /(:=|&lt;=|&gt;=|==|&lt;&gt;|\.\+|\.\-|\.\*|\.\/|\.\^)/;
  var isDigit = /[0-9]/;
  var isNonDigit = /[_a-zA-Z]/;

  function tokenLineComment(stream, state) {
    stream.skipToEnd();
    state.tokenize = null;
    return "comment";
  }

  function tokenBlockComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (maybeEnd &amp;&amp; ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function tokenString(stream, state) {
    var escaped = false, ch;
    while ((ch = stream.next()) != null) {
      if (ch == '"' &amp;&amp; !escaped) {
        state.tokenize = null;
        state.sol = false;
        break;
      }
      escaped = !escaped &amp;&amp; ch == "\\";
    }

    return "string";
  }

  function tokenIdent(stream, state) {
    stream.eatWhile(isDigit);
    while (stream.eat(isDigit) || stream.eat(isNonDigit)) { }


    var cur = stream.current();

    if(state.sol &amp;&amp; (cur == "package" || cur == "model" || cur == "when" || cur == "connector")) state.level++;
    else if(state.sol &amp;&amp; cur == "end" &amp;&amp; state.level &gt; 0) state.level--;

    state.tokenize = null;
    state.sol = false;

    if (keywords.propertyIsEnumerable(cur)) return "keyword";
    else if (builtin.propertyIsEnumerable(cur)) return "builtin";
    else if (atoms.propertyIsEnumerable(cur)) return "atom";
    else return "variable";
  }

  function tokenQIdent(stream, state) {
    while (stream.eat(/[^']/)) { }

    state.tokenize = null;
    state.sol = false;

    if(stream.eat("'"))
      return "variable";
    else
      return "error";
  }

  function tokenUnsignedNuber(stream, state) {
    stream.eatWhile(isDigit);
    if (stream.eat('.')) {
      stream.eatWhile(isDigit);
    }
    if (stream.eat('e') || stream.eat('E')) {
      if (!stream.eat('-'))
        stream.eat('+');
      stream.eatWhile(isDigit);
    }

    state.tokenize = null;
    state.sol = false;
    return "number";
  }

  // Interface
  return {
    startState: function() {
      return {
        tokenize: null,
        level: 0,
        sol: true
      };
    },

    token: function(stream, state) {
      if(state.tokenize != null) {
        return state.tokenize(stream, state);
      }

      if(stream.sol()) {
        state.sol = true;
      }

      // WHITESPACE
      if(stream.eatSpace()) {
        state.tokenize = null;
        return null;
      }

      var ch = stream.next();

      // LINECOMMENT
      if(ch == '/' &amp;&amp; stream.eat('/')) {
        state.tokenize = tokenLineComment;
      }
      // BLOCKCOMMENT
      else if(ch == '/' &amp;&amp; stream.eat('*')) {
        state.tokenize = tokenBlockComment;
      }
      // TWO SYMBOL TOKENS
      else if(isDoubleOperatorChar.test(ch+stream.peek())) {
        stream.next();
        state.tokenize = null;
        return "operator";
      }
      // SINGLE SYMBOL TOKENS
      else if(isSingleOperatorChar.test(ch)) {
        state.tokenize = null;
        return "operator";
      }
      // IDENT
      else if(isNonDigit.test(ch)) {
        state.tokenize = tokenIdent;
      }
      // Q-IDENT
      else if(ch == "'" &amp;&amp; stream.peek() &amp;&amp; stream.peek() != "'") {
        state.tokenize = tokenQIdent;
      }
      // STRING
      else if(ch == '"') {
        state.tokenize = tokenString;
      }
      // UNSIGNED_NUBER
      else if(isDigit.test(ch)) {
        state.tokenize = tokenUnsignedNuber;
      }
      // ERROR
      else {
        state.tokenize = null;
        return "error";
      }

      return state.tokenize(stream, state);
    },

    indent: function(state, textAfter) {
      if (state.tokenize != null) return CodeMirror.Pass;

      var level = state.level;
      if(/(algorithm)/.test(textAfter)) level--;
      if(/(equation)/.test(textAfter)) lev ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.mscgen" id="apidoc.element.codemirror.modes.mscgen">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>mscgen
        <span class="apidocSignatureSpan">(_, modeConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mscgen = function (_, modeConfig) {
  var language = languages[modeConfig &amp;&amp; modeConfig.language || "mscgen"]
  return {
    startState: startStateFn,
    copyState: copyStateFn,
    token: produceTokenFunction(language),
    lineComment : "#",
    blockCommentStart : "/*",
    blockCommentEnd : "*/"
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.mumps" id="apidoc.element.codemirror.modes.mumps">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>mumps
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mumps = function () {
  function wordRegexp(words) {
    return new RegExp("^((" + words.join(")|(") + "))\\b", "i");
  }

  var singleOperators = new RegExp("^[\\+\\-\\*/&amp;#!_?\\\\&lt;&gt;=\\'\\[\\]]");
  var doubleOperators = new RegExp("^(('=)|(&lt;=)|(&gt;=)|('&gt;)|('&lt;)|([[)|(]])|(^$))");
  var singleDelimiters = new RegExp("^[\\.,:]");
  var brackets = new RegExp("[()]");
  var identifiers = new RegExp("^[%A-Za-z][A-Za-z0-9]*");
  var commandKeywords = ["break","close","do","else","for","goto", "halt", "hang", "if", "job","kill","lock","merge","new","open
", "quit", "read", "set", "tcommit", "trollback", "tstart", "use", "view", "write", "xecute", "b","c","d","e","f","g", "h", "i", "
j","k","l","m","n","o", "q", "r", "s", "tc", "tro", "ts", "u", "v", "w", "x"];
  // The following list includes instrinsic functions _and_ special variables
  var intrinsicFuncsWords = ["\\$ascii", "\\$char", "\\$data", "\\$ecode", "\\$estack", "\\$etrap", "\\$extract", "\\$find", "\\$
fnumber", "\\$get", "\\$horolog", "\\$io", "\\$increment", "\\$job", "\\$justify", "\\$length", "\\$name", "\\$next", "\\$order", "\\$piece", "\\$qlength", "\\$qsubscript", "\\$query", "\\$quit", "\\$random", "\\$reverse", "\\$select", "\\$stack", "\\$test", "\\$text", "\\$translate", "\\$view", "\\$x", "\\$y", "\\$a", "\\$c", "\\$d", "\\$e", "\\$ec", "\\$es", "\\$et", "\\$f", "\\$fn", "\\$g", "\\$h", "\\$i", "\\$j", "\\$l", "\\$n", "\\$na", "\\$o", "\\$p", "\\$q", "\\$ql", "\\$qs", "\\$r", "\\$re", "\\$s", "\\$st", "\\$t", "\\$tr", "\\$v", "\\$z"];
  var intrinsicFuncs = wordRegexp(intrinsicFuncsWords);
  var command = wordRegexp(commandKeywords);

  function tokenBase(stream, state) {
    if (stream.sol()) {
      state.label = true;
      state.commandMode = 0;
    }

    // The &lt;space&gt; character has meaning in MUMPS. Ignoring consecutive
    // spaces would interfere with interpreting whether the next non-space
    // character belongs to the command or argument context.

    // Examine each character and update a mode variable whose interpretation is:
    //   &gt;0 =&gt; command    0 =&gt; argument    &lt;0 =&gt; command post-conditional
    var ch = stream.peek();

    if (ch == " " || ch == "\t") { // Pre-process &lt;space&gt;
      state.label = false;
      if (state.commandMode == 0)
        state.commandMode = 1;
      else if ((state.commandMode &lt; 0) || (state.commandMode == 2))
        state.commandMode = 0;
    } else if ((ch != ".") &amp;&amp; (state.commandMode &gt; 0)) {
      if (ch == ":")
        state.commandMode = -1;   // SIS - Command post-conditional
      else
        state.commandMode = 2;
    }

    // Do not color parameter list as line tag
    if ((ch === "(") || (ch === "\u0009"))
      state.label = false;

    // MUMPS comment starts with ";"
    if (ch === ";") {
      stream.skipToEnd();
      return "comment";
    }

    // Number Literals // SIS/RLM - MUMPS permits canonic number followed by concatenate operator
    if (stream.match(/^[-+]?\d+(\.\d+)?([eE][-+]?\d+)?/))
      return "number";

    // Handle Strings
    if (ch == '"') {
      if (stream.skipTo('"')) {
        stream.next();
        return "string";
      } else {
        stream.skipToEnd();
        return "error";
      }
    }

    // Handle operators and Delimiters
    if (stream.match(doubleOperators) || stream.match(singleOperators))
      return "operator";

    // Prevents leading "." in DO block from falling through to error
    if (stream.match(singleDelimiters))
      return null;

    if (brackets.test(ch)) {
      stream.next();
      return "bracket";
    }

    if (state.commandMode &gt; 0 &amp;&amp; stream.match(command))
      return "variable-2";

    if (stream.match(intrinsicFuncs))
      return "builtin";

    if (stream.match(identifiers))
      return "variable";

    // Detect dollar-sign when not a documented intrinsic function
    // "^" may introduce a GVN or SSVN - Color same as function
    if (ch === "$" || ch === "^") {
      stream.next();
      return "builtin";
    }

    // MUMPS Indirection
    if (ch === "@") {
      stream.next();
      return "string-2";
    }

    if (/[\w%]/.test ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.nginx" id="apidoc.element.codemirror.modes.nginx">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>nginx
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nginx = function (config) {

  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i &lt; words.length; ++i) obj[words[i]] = true;
    return obj;
  }

  var keywords = words(
    /* ngxDirectiveControl */ "break return rewrite set" +
    /* ngxDirective */ " accept_mutex accept_mutex_delay access_log add_after_body add_before_body add_header addition_types aio
 alias allow ancient_browser ancient_browser_value auth_basic auth_basic_user_file auth_http auth_http_header auth_http_timeout
autoindex autoindex_exact_size autoindex_localtime charset charset_types client_body_buffer_size client_body_in_file_only client_body_in_single_buffer
 client_body_temp_path client_body_timeout client_header_buffer_size client_header_timeout client_max_body_size connection_pool_size
 create_full_put_path daemon dav_access dav_methods debug_connection debug_points default_type degradation degrade deny devpoll_changes
 devpoll_events directio directio_alignment empty_gif env epoll_events error_log eventport_events expires fastcgi_bind fastcgi_buffer_size
 fastcgi_buffers fastcgi_busy_buffers_size fastcgi_cache fastcgi_cache_key fastcgi_cache_methods fastcgi_cache_min_uses fastcgi_cache_path
 fastcgi_cache_use_stale fastcgi_cache_valid fastcgi_catch_stderr fastcgi_connect_timeout fastcgi_hide_header fastcgi_ignore_client_abort
 fastcgi_ignore_headers fastcgi_index fastcgi_intercept_errors fastcgi_max_temp_file_size fastcgi_next_upstream fastcgi_param fastcgi_pass_header
 fastcgi_pass_request_body fastcgi_pass_request_headers fastcgi_read_timeout fastcgi_send_lowat fastcgi_send_timeout fastcgi_split_path_info
 fastcgi_store fastcgi_store_access fastcgi_temp_file_write_size fastcgi_temp_path fastcgi_upstream_fail_timeout fastcgi_upstream_max_fails
 flv geoip_city geoip_country google_perftools_profiles gzip gzip_buffers gzip_comp_level gzip_disable gzip_hash gzip_http_version
 gzip_min_length gzip_no_buffer gzip_proxied gzip_static gzip_types gzip_vary gzip_window if_modified_since ignore_invalid_headers
 image_filter image_filter_buffer image_filter_jpeg_quality image_filter_transparency imap_auth imap_capabilities imap_client_buffer
 index ip_hash keepalive_requests keepalive_timeout kqueue_changes kqueue_events large_client_header_buffers limit_conn limit_conn_log_level
 limit_rate limit_rate_after limit_req limit_req_log_level limit_req_zone limit_zone lingering_time lingering_timeout lock_file
log_format log_not_found log_subrequest map_hash_bucket_size map_hash_max_size master_process memcached_bind memcached_buffer_size
 memcached_connect_timeout memcached_next_upstream memcached_read_timeout memcached_send_timeout memcached_upstream_fail_timeout
 memcached_upstream_max_fails merge_slashes min_delete_depth modern_browser modern_browser_value msie_padding msie_refresh multi_accept
 open_file_cache open_file_cache_errors open_file_cache_events open_file_cache_min_uses open_file_cache_valid open_log_file_cache
 output_buffers override_charset perl perl_modules perl_require perl_set pid pop3_auth pop3_capabilities port_in_redirect postpone_gzipping
 postpone_output protocol proxy proxy_bind proxy_buffer proxy_buffer_size proxy_buffering proxy_buffers proxy_busy_buffers_size
proxy_cache proxy_cache_key proxy_cache_methods proxy_cache_min_uses proxy_cache_path proxy_cache_use_stale proxy_cache_valid proxy_connect_timeout
 proxy_headers_hash_bucket_size proxy_headers_hash_max_size proxy_hide_header proxy_ignore_client_abort proxy_ignore_headers proxy_intercept_errors
 proxy_max_temp_file_size proxy_method proxy_next_upstream proxy_pass_error_message proxy_pass_header proxy_pass_request_body proxy_pass_request_headers
 proxy_read_timeout proxy_redirect proxy_send_lowat proxy_send_timeout proxy_set_body proxy_set_header proxy_ssl_session_reuse proxy_store
 proxy_store_access proxy_temp_file_write_size proxy_temp_path proxy_timeout proxy_upstream_fail_timeout proxy_upstream_max_fails
 random_index read_ahead real_ip_header recursive_error_pages request_pool_size reset_timedout_connection resolver resolver_timeout
 rewrite_ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.nsis" id="apidoc.element.codemirror.modes.nsis">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>nsis
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nsis = function (config) {
  return CodeMirror.simpleMode(config, states);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.ntriples" id="apidoc.element.codemirror.modes.ntriples">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>ntriples
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ntriples = function () {

  var Location = {
    PRE_SUBJECT         : 0,
    WRITING_SUB_URI     : 1,
    WRITING_BNODE_URI   : 2,
    PRE_PRED            : 3,
    WRITING_PRED_URI    : 4,
    PRE_OBJ             : 5,
    WRITING_OBJ_URI     : 6,
    WRITING_OBJ_BNODE   : 7,
    WRITING_OBJ_LITERAL : 8,
    WRITING_LIT_LANG    : 9,
    WRITING_LIT_TYPE    : 10,
    POST_OBJ            : 11,
    ERROR               : 12
  };
  function transitState(currState, c) {
    var currLocation = currState.location;
    var ret;

    // Opening.
    if     (currLocation == Location.PRE_SUBJECT &amp;&amp; c == '&lt;') ret = Location.WRITING_SUB_URI;
    else if(currLocation == Location.PRE_SUBJECT &amp;&amp; c == '_') ret = Location.WRITING_BNODE_URI;
    else if(currLocation == Location.PRE_PRED    &amp;&amp; c == '&lt;') ret = Location.WRITING_PRED_URI;
    else if(currLocation == Location.PRE_OBJ     &amp;&amp; c == '&lt;') ret = Location.WRITING_OBJ_URI;
    else if(currLocation == Location.PRE_OBJ     &amp;&amp; c == '_') ret = Location.WRITING_OBJ_BNODE;
    else if(currLocation == Location.PRE_OBJ     &amp;&amp; c == '"') ret = Location.WRITING_OBJ_LITERAL;

    // Closing.
    else if(currLocation == Location.WRITING_SUB_URI     &amp;&amp; c == '&gt;') ret = Location.PRE_PRED;
    else if(currLocation == Location.WRITING_BNODE_URI   &amp;&amp; c == ' ') ret = Location.PRE_PRED;
    else if(currLocation == Location.WRITING_PRED_URI    &amp;&amp; c == '&gt;') ret = Location.PRE_OBJ;
    else if(currLocation == Location.WRITING_OBJ_URI     &amp;&amp; c == '&gt;') ret = Location.POST_OBJ;
    else if(currLocation == Location.WRITING_OBJ_BNODE   &amp;&amp; c == ' ') ret = Location.POST_OBJ;
    else if(currLocation == Location.WRITING_OBJ_LITERAL &amp;&amp; c == '"') ret = Location.POST_OBJ;
    else if(currLocation == Location.WRITING_LIT_LANG &amp;&amp; c == ' ') ret = Location.POST_OBJ;
    else if(currLocation == Location.WRITING_LIT_TYPE &amp;&amp; c == '&gt;') ret = Location.POST_OBJ;

    // Closing typed and language literal.
    else if(currLocation == Location.WRITING_OBJ_LITERAL &amp;&amp; c == '@') ret = Location.WRITING_LIT_LANG;
    else if(currLocation == Location.WRITING_OBJ_LITERAL &amp;&amp; c == '^') ret = Location.WRITING_LIT_TYPE;

    // Spaces.
    else if( c == ' ' &amp;&amp;
             (
               currLocation == Location.PRE_SUBJECT ||
               currLocation == Location.PRE_PRED    ||
               currLocation == Location.PRE_OBJ     ||
               currLocation == Location.POST_OBJ
             )
           ) ret = currLocation;

    // Reset.
    else if(currLocation == Location.POST_OBJ &amp;&amp; c == '.') ret = Location.PRE_SUBJECT;

    // Error
    else ret = Location.ERROR;

    currState.location=ret;
  }

  return {
    startState: function() {
       return {
           location : Location.PRE_SUBJECT,
           uris     : [],
           anchors  : [],
           bnodes   : [],
           langs    : [],
           types    : []
       };
    },
    token: function(stream, state) {
      var ch = stream.next();
      if(ch == '&lt;') {
         transitState(state, ch);
         var parsedURI = '';
         stream.eatWhile( function(c) { if( c != '#' &amp;&amp; c != '&gt;' ) { parsedURI += c; return true; } return false;} );
         state.uris.push(parsedURI);
         if( stream.match('#', false) ) return 'variable';
         stream.next();
         transitState(state, '&gt;');
         return 'variable';
      }
      if(ch == '#') {
        var parsedAnchor = '';
        stream.eatWhile(function(c) { if(c != '&gt;' &amp;&amp; c != ' ') { parsedAnchor+= c; return true; } return false;});
        state.anchors.push(parsedAnchor);
        return 'variable-2';
      }
      if(ch == '&gt;') {
          transitState(state, '&gt;');
          return 'variable';
      }
      if(ch == '_') {
          transitState(state, ch);
          var parsedBNode = '';
          stream.eatWhile(function(c) { if( c != ' ' ) { parsedBNode += c; return true; } return false;});
          state.bnodes.push(parsedBNode);
          stream.next();
          transitState(state, ' ');
          return 'builtin';
      }
      if(ch == '"') {
          transitState(state, ch);
          stream.eatWhile( funct ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.null" id="apidoc.element.codemirror.modes.null">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>null
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">null = function () {
  return {token: function(stream) {stream.skipToEnd();}};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.octave" id="apidoc.element.codemirror.modes.octave">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>octave
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">octave = function () {
  function wordRegexp(words) {
    return new RegExp("^((" + words.join(")|(") + "))\\b");
  }

  var singleOperators = new RegExp("^[\\+\\-\\*/&amp;|\\^~&lt;&gt;!@'\\\\]");
  var singleDelimiters = new RegExp('^[\\(\\[\\{\\},:=;]');
  var doubleOperators = new RegExp("^((==)|(~=)|(&lt;=)|(&gt;=)|(&lt;&lt;)|(&gt;&gt;)|(\\.[\\+\\-\\*/\\^\\\\]))");
  var doubleDelimiters = new RegExp("^((!=)|(\\+=)|(\\-=)|(\\*=)|(/=)|(&amp;=)|(\\|=)|(\\^=))");
  var tripleDelimiters = new RegExp("^((&gt;&gt;=)|(&lt;&lt;=))");
  var expressionEnd = new RegExp("^[\\]\\)]");
  var identifiers = new RegExp("^[_A-Za-z\xa1-\uffff][_A-Za-z0-9\xa1-\uffff]*");

  var builtins = wordRegexp([
    'error', 'eval', 'function', 'abs', 'acos', 'atan', 'asin', 'cos',
    'cosh', 'exp', 'log', 'prod', 'sum', 'log10', 'max', 'min', 'sign', 'sin', 'sinh',
    'sqrt', 'tan', 'reshape', 'break', 'zeros', 'default', 'margin', 'round', 'ones',
    'rand', 'syn', 'ceil', 'floor', 'size', 'clear', 'zeros', 'eye', 'mean', 'std', 'cov',
    'det', 'eig', 'inv', 'norm', 'rank', 'trace', 'expm', 'logm', 'sqrtm', 'linspace', 'plot',
    'title', 'xlabel', 'ylabel', 'legend', 'text', 'grid', 'meshgrid', 'mesh', 'num2str',
    'fft', 'ifft', 'arrayfun', 'cellfun', 'input', 'fliplr', 'flipud', 'ismember'
  ]);

  var keywords = wordRegexp([
    'return', 'case', 'switch', 'else', 'elseif', 'end', 'endif', 'endfunction',
    'if', 'otherwise', 'do', 'for', 'while', 'try', 'catch', 'classdef', 'properties', 'events',
    'methods', 'global', 'persistent', 'endfor', 'endwhile', 'printf', 'sprintf', 'disp', 'until',
    'continue', 'pkg'
  ]);


  // tokenizers
  function tokenTranspose(stream, state) {
    if (!stream.sol() &amp;&amp; stream.peek() === '\'') {
      stream.next();
      state.tokenize = tokenBase;
      return 'operator';
    }
    state.tokenize = tokenBase;
    return tokenBase(stream, state);
  }


  function tokenComment(stream, state) {
    if (stream.match(/^.*%}/)) {
      state.tokenize = tokenBase;
      return 'comment';
    };
    stream.skipToEnd();
    return 'comment';
  }

  function tokenBase(stream, state) {
    // whitespaces
    if (stream.eatSpace()) return null;

    // Handle one line Comments
    if (stream.match('%{')){
      state.tokenize = tokenComment;
      stream.skipToEnd();
      return 'comment';
    }

    if (stream.match(/^[%#]/)){
      stream.skipToEnd();
      return 'comment';
    }

    // Handle Number Literals
    if (stream.match(/^[0-9\.+-]/, false)) {
      if (stream.match(/^[+-]?0x[0-9a-fA-F]+[ij]?/)) {
        stream.tokenize = tokenBase;
        return 'number'; };
      if (stream.match(/^[+-]?\d*\.\d+([EeDd][+-]?\d+)?[ij]?/)) { return 'number'; };
      if (stream.match(/^[+-]?\d+([EeDd][+-]?\d+)?[ij]?/)) { return 'number'; };
    }
    if (stream.match(wordRegexp(['nan','NaN','inf','Inf']))) { return 'number'; };

    // Handle Strings
    var m = stream.match(/^"(?:[^"]|"")*("|$)/) || stream.match(/^'(?:[^']|'')*('|$)/)
    if (m) { return m[1] ? 'string' : "string error"; }

    // Handle words
    if (stream.match(keywords)) { return 'keyword'; } ;
    if (stream.match(builtins)) { return 'builtin'; } ;
    if (stream.match(identifiers)) { return 'variable'; } ;

    if (stream.match(singleOperators) || stream.match(doubleOperators)) { return 'operator'; };
    if (stream.match(singleDelimiters) || stream.match(doubleDelimiters) || stream.match(tripleDelimiters)) { return null; };

    if (stream.match(expressionEnd)) {
      state.tokenize = tokenTranspose;
      return null;
    };


    // Handle non-detected items
    stream.next();
    return 'error';
  };


  return {
    startState: function() {
      return {
        tokenize: tokenBase
      };
    },

    token: function(stream, state) {
      var style = state.tokenize(stream, state);
      if (style === 'number' || style === 'variable'){
        state.tokenize = tokenTranspose;
      }
      return style;
    },

    lineComment: '%',

    fold: 'indent'
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.oz" id="apidoc.element.codemirror.modes.oz">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>oz
        <span class="apidocSignatureSpan">(conf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">oz = function (conf) {

  function wordRegexp(words) {
    return new RegExp("^((" + words.join(")|(") + "))\\b");
  }

  var singleOperators = /[\^@!\|&lt;&gt;#~\.\*\-\+\\/,=]/;
  var doubleOperators = /(&lt;-)|(:=)|(=&lt;)|(&gt;=)|(&lt;=)|(&lt;:)|(&gt;:)|(=:)|(\\=)|(\\=:)|(!!)|(==)|(::)/;
  var tripleOperators = /(:::)|(\.\.\.)|(=&lt;:)|(&gt;=:)/;

  var middle = ["in", "then", "else", "of", "elseof", "elsecase", "elseif", "catch",
    "finally", "with", "require", "prepare", "import", "export", "define", "do"];
  var end = ["end"];

  var atoms = wordRegexp(["true", "false", "nil", "unit"]);
  var commonKeywords = wordRegexp(["andthen", "at", "attr", "declare", "feat", "from", "lex",
    "mod", "div", "mode", "orelse", "parser", "prod", "prop", "scanner", "self", "syn", "token"]);
  var openingKeywords = wordRegexp(["local", "proc", "fun", "case", "class", "if", "cond", "or", "dis",
    "choice", "not", "thread", "try", "raise", "lock", "for", "suchthat", "meth", "functor"]);
  var middleKeywords = wordRegexp(middle);
  var endKeywords = wordRegexp(end);

  // Tokenizers
  function tokenBase(stream, state) {
    if (stream.eatSpace()) {
      return null;
    }

    // Brackets
    if(stream.match(/[{}]/)) {
      return "bracket";
    }

    // Special [] keyword
    if (stream.match(/(\[])/)) {
        return "keyword"
    }

    // Operators
    if (stream.match(tripleOperators) || stream.match(doubleOperators)) {
      return "operator";
    }

    // Atoms
    if(stream.match(atoms)) {
      return 'atom';
    }

    // Opening keywords
    var matched = stream.match(openingKeywords);
    if (matched) {
      if (!state.doInCurrentLine)
        state.currentIndent++;
      else
        state.doInCurrentLine = false;

      // Special matching for signatures
      if(matched[0] == "proc" || matched[0] == "fun")
        state.tokenize = tokenFunProc;
      else if(matched[0] == "class")
        state.tokenize = tokenClass;
      else if(matched[0] == "meth")
        state.tokenize = tokenMeth;

      return 'keyword';
    }

    // Middle and other keywords
    if (stream.match(middleKeywords) || stream.match(commonKeywords)) {
      return "keyword"
    }

    // End keywords
    if (stream.match(endKeywords)) {
      state.currentIndent--;
      return 'keyword';
    }

    // Eat the next char for next comparisons
    var ch = stream.next();

    // Strings
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }

    // Numbers
    if (/[~\d]/.test(ch)) {
      if (ch == "~") {
        if(! /^[0-9]/.test(stream.peek()))
          return null;
        else if (( stream.next() == "0" &amp;&amp; stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\.[0-9]+)?([eE][~+]?[0-9]+)?/))
          return "number";
      }

      if ((ch == "0" &amp;&amp; stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\.[0-9]+)?([eE][~+]?[0-9]+)?/))
        return "number";

      return null;
    }

    // Comments
    if (ch == "%") {
      stream.skipToEnd();
      return 'comment';
    }
    else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      }
    }

    // Single operators
    if(singleOperators.test(ch)) {
      return "operator";
    }

    // If nothing match, we skip the entire alphanumerical block
    stream.eatWhile(/\w/);

    return "variable";
  }

  function tokenClass(stream, state) {
    if (stream.eatSpace()) {
      return null;
    }
    stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);
    state.tokenize = tokenBase;
    return "variable-3"
  }

  function tokenMeth(stream, state) {
    if (stream.eatSpace()) {
      return null;
    }
    stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);
    state.tokenize = tokenBase;
    return "def"
  }

  function tokenFunProc(stream, state) {
    if (stream.eatSpace()) {
      return null;
    }

    if(!state.hasPassedFirstStage &amp;&amp; stream.eat("{")) {
      state.hasPassedFirstStage = true;
      return "bracket";
    }
    else if(state.hasPassedFirstStage) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.pascal" id="apidoc.element.codemirror.modes.pascal">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>pascal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pascal = function () {
  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i &lt; words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var keywords = words("and array begin case const div do downto else end file for forward integer " +
                       "boolean char function goto if in label mod nil not of or packed procedure " +
                       "program record repeat set string then to type until var while with");
  var atoms = {"null": true};

  var isOperatorChar = /[+\-*&amp;%=&lt;&gt;!?|\/]/;

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == "#" &amp;&amp; state.startOfLine) {
      stream.skipToEnd();
      return "meta";
    }
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    if (ch == "(" &amp;&amp; stream.eat("*")) {
      state.tokenize = tokenComment;
      return tokenComment(stream, state);
    }
    if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return null;
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    if (ch == "/") {
      if (stream.eat("/")) {
        stream.skipToEnd();
        return "comment";
      }
    }
    if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    stream.eatWhile(/[\w\$_]/);
    var cur = stream.current();
    if (keywords.propertyIsEnumerable(cur)) return "keyword";
    if (atoms.propertyIsEnumerable(cur)) return "atom";
    return "variable";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote &amp;&amp; !escaped) {end = true; break;}
        escaped = !escaped &amp;&amp; next == "\\";
      }
      if (end || !escaped) state.tokenize = null;
      return "string";
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == ")" &amp;&amp; maybeEnd) {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  // Interface

  return {
    startState: function() {
      return {tokenize: null};
    },

    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style == "comment" || style == "meta") return style;
      return style;
    },

    electricChars: "{}"
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.pegjs" id="apidoc.element.codemirror.modes.pegjs">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>pegjs
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pegjs = function (config) {
  var jsMode = CodeMirror.getMode(config, "javascript");

  function identifier(stream) {
    return stream.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
  }

  return {
    startState: function () {
      return {
        inString: false,
        stringType: null,
        inComment: false,
        inCharacterClass: false,
        braced: 0,
        lhs: true,
        localState: null
      };
    },
    token: function (stream, state) {
      if (stream)

      //check for state changes
      if (!state.inString &amp;&amp; !state.inComment &amp;&amp; ((stream.peek() == '"') || (stream.peek() == "'"))) {
        state.stringType = stream.peek();
        stream.next(); // Skip quote
        state.inString = true; // Update state
      }
      if (!state.inString &amp;&amp; !state.inComment &amp;&amp; stream.match(/^\/\*/)) {
        state.inComment = true;
      }

      //return state
      if (state.inString) {
        while (state.inString &amp;&amp; !stream.eol()) {
          if (stream.peek() === state.stringType) {
            stream.next(); // Skip quote
            state.inString = false; // Clear flag
          } else if (stream.peek() === '\\') {
            stream.next();
            stream.next();
          } else {
            stream.match(/^.[^\\\"\']*/);
          }
        }
        return state.lhs ? "property string" : "string"; // Token style
      } else if (state.inComment) {
        while (state.inComment &amp;&amp; !stream.eol()) {
          if (stream.match(/\*\//)) {
            state.inComment = false; // Clear flag
          } else {
            stream.match(/^.[^\*]*/);
          }
        }
        return "comment";
      } else if (state.inCharacterClass) {
          while (state.inCharacterClass &amp;&amp; !stream.eol()) {
            if (!(stream.match(/^[^\]\\]+/) || stream.match(/^\\./))) {
              state.inCharacterClass = false;
            }
          }
      } else if (stream.peek() === '[') {
        stream.next();
        state.inCharacterClass = true;
        return 'bracket';
      } else if (stream.match(/^\/\//)) {
        stream.skipToEnd();
        return "comment";
      } else if (state.braced || stream.peek() === '{') {
        if (state.localState === null) {
          state.localState = CodeMirror.startState(jsMode);
        }
        var token = jsMode.token(stream, state.localState);
        var text = stream.current();
        if (!token) {
          for (var i = 0; i &lt; text.length; i++) {
            if (text[i] === '{') {
              state.braced++;
            } else if (text[i] === '}') {
              state.braced--;
            }
          };
        }
        return token;
      } else if (identifier(stream)) {
        if (stream.peek() === ':') {
          return 'variable';
        }
        return 'variable-2';
      } else if (['[', ']', '(', ')'].indexOf(stream.peek()) != -1) {
        stream.next();
        return 'bracket';
      } else if (!stream.eatSpace()) {
        stream.next();
      }
      return null;
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.perl" id="apidoc.element.codemirror.modes.perl">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>perl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">perl = function (){
        // http://perldoc.perl.org
        var PERL={                                      //   null - magic touch
                                                        //   1 - keyword
                                                        //   2 - def
                                                        //   3 - atom
                                                        //   4 - operator
                                                        //   5 - variable-2 (predefined)
                                                        //   [x,y] - x=1,2,3; y=must be defined if x{...}
                                                //      PERL operators
                '-&gt;'                            :   4,
                '++'                            :   4,
                '--'                            :   4,
                '**'                            :   4,
                                                        //   ! ~ \ and unary + and -
                '=~'                            :   4,
                '!~'                            :   4,
                '*'                             :   4,
                '/'                             :   4,
                '%'                             :   4,
                'x'                             :   4,
                '+'                             :   4,
                '-'                             :   4,
                '.'                             :   4,
                '&lt;&lt;'                            :   4,
                '&gt;&gt;'                            :   4,
                                                        //   named unary operators
                '&lt;'                             :   4,
                '&gt;'                             :   4,
                '&lt;='                            :   4,
                '&gt;='                            :   4,
                'lt'                            :   4,
                'gt'                            :   4,
                'le'                            :   4,
                'ge'                            :   4,
                '=='                            :   4,
                '!='                            :   4,
                '&lt;=&gt;'                           :   4,
                'eq'                            :   4,
                'ne'                            :   4,
                'cmp'                           :   4,
                '~~'                            :   4,
                '&amp;'                             :   4,
                '|'                             :   4,
                '^'                             :   4,
                '&amp;&amp;'                            :   4,
                '||'                            :   4,
                '//'                            :   4,
                '..'                            :   4,
                '...'                           :   4,
                '?'                             :   4,
                ':'                             :   4,
                '='                             :   4,
                '+='                            :   4,
                '-='                            :   4,
                '*='                            :   4,  //   etc. ???
                ','                             :   4,
                '=&gt;'                            :   4,
                '::'                            :   4,
                                                        //   list operators (rightward)
                'not'                           :   4,
                'and'                           :   4,
                'or'                            :   4,
                'xor'                           :   4,
                                                //      PERL predefined variables (I know, what this is a paranoid idea, but may
 be needed for people, who learn PERL, and for me as well, ...and may be for you?;)
                'BEGIN'                         :   [5,1],
                'END'                           :   [5,1], ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.php" id="apidoc.element.codemirror.modes.php">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>php
        <span class="apidocSignatureSpan">(config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">php = function (config, parserConfig) {
  var htmlMode = CodeMirror.getMode(config, "text/html");
  var phpMode = CodeMirror.getMode(config, phpConfig);

  function dispatch(stream, state) {
    var isPHP = state.curMode == phpMode;
    if (stream.sol() &amp;&amp; state.pending &amp;&amp; state.pending != '"' &amp;&amp; state.pending != "'") state.pending = null;
    if (!isPHP) {
      if (stream.match(/^&lt;\?\w*/)) {
        state.curMode = phpMode;
        if (!state.php) state.php = CodeMirror.startState(phpMode, htmlMode.indent(state.html, ""))
        state.curState = state.php;
        return "meta";
      }
      if (state.pending == '"' || state.pending == "'") {
        while (!stream.eol() &amp;&amp; stream.next() != state.pending) {}
        var style = "string";
      } else if (state.pending &amp;&amp; stream.pos &lt; state.pending.end) {
        stream.pos = state.pending.end;
        var style = state.pending.style;
      } else {
        var style = htmlMode.token(stream, state.curState);
      }
      if (state.pending) state.pending = null;
      var cur = stream.current(), openPHP = cur.search(/&lt;\?/), m;
      if (openPHP != -1) {
        if (style == "string" &amp;&amp; (m = cur.match(/[\'\"]$/)) &amp;&amp; !/\?&gt;/.test(cur)) state.pending = m[0];
        else state.pending = {end: stream.pos, style: style};
        stream.backUp(cur.length - openPHP);
      }
      return style;
    } else if (isPHP &amp;&amp; state.php.tokenize == null &amp;&amp; stream.match("?&gt;")) {
      state.curMode = htmlMode;
      state.curState = state.html;
      if (!state.php.context.prev) state.php = null;
      return "meta";
    } else {
      return phpMode.token(stream, state.curState);
    }
  }

  return {
    startState: function() {
      var html = CodeMirror.startState(htmlMode)
      var php = parserConfig.startOpen ? CodeMirror.startState(phpMode) : null
      return {html: html,
              php: php,
              curMode: parserConfig.startOpen ? phpMode : htmlMode,
              curState: parserConfig.startOpen ? php : html,
              pending: null};
    },

    copyState: function(state) {
      var html = state.html, htmlNew = CodeMirror.copyState(htmlMode, html),
          php = state.php, phpNew = php &amp;&amp; CodeMirror.copyState(phpMode, php), cur;
      if (state.curMode == htmlMode) cur = htmlNew;
      else cur = phpNew;
      return {html: htmlNew, php: phpNew, curMode: state.curMode, curState: cur,
              pending: state.pending};
    },

    token: dispatch,

    indent: function(state, textAfter) {
      if ((state.curMode != phpMode &amp;&amp; /^\s*&lt;\//.test(textAfter)) ||
          (state.curMode == phpMode &amp;&amp; /^\?&gt;/.test(textAfter)))
        return htmlMode.indent(state.html, textAfter);
      return state.curMode.indent(state.curState, textAfter);
    },

    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    lineComment: "//",

    innerMode: function(state) { return {state: state.curState, mode: state.curMode}; }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.pig" id="apidoc.element.codemirror.modes.pig">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>pig
        <span class="apidocSignatureSpan">(_config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pig = function (_config, parserConfig) {
  var keywords = parserConfig.keywords,
  builtins = parserConfig.builtins,
  types = parserConfig.types,
  multiLineStrings = parserConfig.multiLineStrings;

  var isOperatorChar = /[*+\-%&lt;&gt;=&amp;?:\/!|]/;

  function chain(stream, state, f) {
    state.tokenize = f;
    return f(stream, state);
  }

  function tokenComment(stream, state) {
    var isEnd = false;
    var ch;
    while(ch = stream.next()) {
      if(ch == "/" &amp;&amp; isEnd) {
        state.tokenize = tokenBase;
        break;
      }
      isEnd = (ch == "*");
    }
    return "comment";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next, end = false;
      while((next = stream.next()) != null) {
        if (next == quote &amp;&amp; !escaped) {
          end = true; break;
        }
        escaped = !escaped &amp;&amp; next == "\\";
      }
      if (end || !(escaped || multiLineStrings))
        state.tokenize = tokenBase;
      return "error";
    };
  }


  function tokenBase(stream, state) {
    var ch = stream.next();

    // is a start of string?
    if (ch == '"' || ch == "'")
      return chain(stream, state, tokenString(ch));
    // is it one of the special chars
    else if(/[\[\]{}\(\),;\.]/.test(ch))
      return null;
    // is it a number?
    else if(/\d/.test(ch)) {
      stream.eatWhile(/[\w\.]/);
      return "number";
    }
    // multi line comment or operator
    else if (ch == "/") {
      if (stream.eat("*")) {
        return chain(stream, state, tokenComment);
      }
      else {
        stream.eatWhile(isOperatorChar);
        return "operator";
      }
    }
    // single line comment or operator
    else if (ch=="-") {
      if(stream.eat("-")){
        stream.skipToEnd();
        return "comment";
      }
      else {
        stream.eatWhile(isOperatorChar);
        return "operator";
      }
    }
    // is it an operator
    else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return "operator";
    }
    else {
      // get the while word
      stream.eatWhile(/[\w\$_]/);
      // is it one of the listed keywords?
      if (keywords &amp;&amp; keywords.propertyIsEnumerable(stream.current().toUpperCase())) {
        //keywords can be used as variables like flatten(group), group.$0 etc..
        if (!stream.eat(")") &amp;&amp; !stream.eat("."))
          return "keyword";
      }
      // is it one of the builtin functions?
      if (builtins &amp;&amp; builtins.propertyIsEnumerable(stream.current().toUpperCase()))
        return "variable-2";
      // is it one of the listed types?
      if (types &amp;&amp; types.propertyIsEnumerable(stream.current().toUpperCase()))
        return "variable-3";
      // default is a 'variable'
      return "variable";
    }
  }

  // Interface
  return {
    startState: function() {
      return {
        tokenize: tokenBase,
        startOfLine: true
      };
    },

    token: function(stream, state) {
      if(stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      return style;
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.powershell" id="apidoc.element.codemirror.modes.powershell">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>powershell
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">powershell = function () {
  function buildRegexp(patterns, options) {
    options = options || {};
    var prefix = options.prefix !== undefined ? options.prefix : '^';
    var suffix = options.suffix !== undefined ? options.suffix : '\\b';

    for (var i = 0; i &lt; patterns.length; i++) {
      if (patterns[i] instanceof RegExp) {
        patterns[i] = patterns[i].source;
      }
      else {
        patterns[i] = patterns[i].replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&amp;');
      }
    }

    return new RegExp(prefix + '(' + patterns.join('|') + ')' + suffix, 'i');
  }

  var notCharacterOrDash = '(?=[^A-Za-z\\d\\-_]|$)';
  var varNames = /[\w\-:]/
  var keywords = buildRegexp([
    /begin|break|catch|continue|data|default|do|dynamicparam/,
    /else|elseif|end|exit|filter|finally|for|foreach|from|function|if|in/,
    /param|process|return|switch|throw|trap|try|until|where|while/
  ], { suffix: notCharacterOrDash });

  var punctuation = /[\[\]{},;`\.]|@[({]/;
  var wordOperators = buildRegexp([
    'f',
    /b?not/,
    /[ic]?split/, 'join',
    /is(not)?/, 'as',
    /[ic]?(eq|ne|[gl][te])/,
    /[ic]?(not)?(like|match|contains)/,
    /[ic]?replace/,
    /b?(and|or|xor)/
  ], { prefix: '-' });
  var symbolOperators = /[+\-*\/%]=|\+\+|--|\.\.|[+\-*&amp;^%:=!|\/]|&lt;(?!#)|(?!#)&gt;/;
  var operators = buildRegexp([wordOperators, symbolOperators], { suffix: '' });

  var numbers = /^((0x[\da-f]+)|((\d+\.\d+|\d\.|\.\d+|\d+)(e[\+\-]?\d+)?))[ld]?([kmgtp]b)?/i;

  var identifiers = /^[A-Za-z\_][A-Za-z\-\_\d]*\b/;

  var symbolBuiltins = /[A-Z]:|%|\?/i;
  var namedBuiltins = buildRegexp([
    /Add-(Computer|Content|History|Member|PSSnapin|Type)/,
    /Checkpoint-Computer/,
    /Clear-(Content|EventLog|History|Host|Item(Property)?|Variable)/,
    /Compare-Object/,
    /Complete-Transaction/,
    /Connect-PSSession/,
    /ConvertFrom-(Csv|Json|SecureString|StringData)/,
    /Convert-Path/,
    /ConvertTo-(Csv|Html|Json|SecureString|Xml)/,
    /Copy-Item(Property)?/,
    /Debug-Process/,
    /Disable-(ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)/,
    /Disconnect-PSSession/,
    /Enable-(ComputerRestore|PSBreakpoint|PSRemoting|PSSessionConfiguration)/,
    /(Enter|Exit)-PSSession/,
    /Export-(Alias|Clixml|Console|Counter|Csv|FormatData|ModuleMember|PSSession)/,
    /ForEach-Object/,
    /Format-(Custom|List|Table|Wide)/,
    new RegExp('Get-(Acl|Alias|AuthenticodeSignature|ChildItem|Command|ComputerRestorePoint|Content|ControlPanelItem|Counter|Credential
'
      + '|Culture|Date|Event|EventLog|EventSubscriber|ExecutionPolicy|FormatData|Help|History|Host|HotFix|Item|ItemProperty|Job'
      + '|Location|Member|Module|PfxCertificate|Process|PSBreakpoint|PSCallStack|PSDrive|PSProvider|PSSession|PSSessionConfiguration
'
      + '|PSSnapin|Random|Service|TraceSource|Transaction|TypeData|UICulture|Unique|Variable|Verb|WinEvent|WmiObject)'),
    /Group-Object/,
    /Import-(Alias|Clixml|Counter|Csv|LocalizedData|Module|PSSession)/,
    /ImportSystemModules/,
    /Invoke-(Command|Expression|History|Item|RestMethod|WebRequest|WmiMethod)/,
    /Join-Path/,
    /Limit-EventLog/,
    /Measure-(Command|Object)/,
    /Move-Item(Property)?/,
    new RegExp('New-(Alias|Event|EventLog|Item(Property)?|Module|ModuleManifest|Object|PSDrive|PSSession|PSSessionConfigurationFile
'
      + '|PSSessionOption|PSTransportOption|Service|TimeSpan|Variable|WebServiceProxy|WinEvent)'),
    /Out-(Default|File|GridView|Host|Null|Printer|String)/,
    /Pause/,
    /(Pop|Push)-Location/,
    /Read-Host/,
    /Receive-(Job|PSSession)/,
    /Register-(EngineEvent|ObjectEvent|PSSessionConfiguration|WmiEvent)/,
    /Remove-(Computer|Event|EventLog|Item(Property)?|Job|Module|PSBreakpoint|PSDrive|PSSession|PSSnapin|TypeData|Variable|WmiObject
)/,
    /Rename-(Computer|Item(Property)?)/,
    /Reset-ComputerMachinePassword/,
    /Resolve-Path/,
    /Restart-(Computer|Service)/,
    /Restore-Computer/,
    /Resume-(Job|Service)/,
    /Save-Help/,
    /Select-(Object|String|Xml)/,
    /Send-MailMessage/,
    new RegExp('Set-(Acl|Alias|AuthenticodeSignature|Content|Date|ExecutionPol ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.properties" id="apidoc.element.codemirror.modes.properties">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>properties
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">properties = function () {
  return {
    token: function(stream, state) {
      var sol = stream.sol() || state.afterSection;
      var eol = stream.eol();

      state.afterSection = false;

      if (sol) {
        if (state.nextMultiline) {
          state.inMultiline = true;
          state.nextMultiline = false;
        } else {
          state.position = "def";
        }
      }

      if (eol &amp;&amp; ! state.nextMultiline) {
        state.inMultiline = false;
        state.position = "def";
      }

      if (sol) {
        while(stream.eatSpace()) {}
      }

      var ch = stream.next();

      if (sol &amp;&amp; (ch === "#" || ch === "!" || ch === ";")) {
        state.position = "comment";
        stream.skipToEnd();
        return "comment";
      } else if (sol &amp;&amp; ch === "[") {
        state.afterSection = true;
        stream.skipTo("]"); stream.eat("]");
        return "header";
      } else if (ch === "=" || ch === ":") {
        state.position = "quote";
        return null;
      } else if (ch === "\\" &amp;&amp; state.position === "quote") {
        if (stream.eol()) {  // end of line?
          // Multiline value
          state.nextMultiline = true;
        }
      }

      return state.position;
    },

    startState: function() {
      return {
        position : "def",       // Current position, "def", "quote" or "comment"
        nextMultiline : false,  // Is the next line multiline value
        inMultiline : false,    // Is the current line a multiline value
        afterSection : false    // Did we just open a section
      };
    }

  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.protobuf" id="apidoc.element.codemirror.modes.protobuf">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>protobuf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">protobuf = function () {
  return {token: tokenBase};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.pug" id="apidoc.element.codemirror.modes.pug">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>pug
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pug = function (config) {
  // token types
  var KEYWORD = 'keyword';
  var DOCTYPE = 'meta';
  var ID = 'builtin';
  var CLASS = 'qualifier';

  var ATTRS_NEST = {
    '{': '}',
    '(': ')',
    '[': ']'
  };

  var jsMode = CodeMirror.getMode(config, 'javascript');

  function State() {
    this.javaScriptLine = false;
    this.javaScriptLineExcludesColon = false;

    this.javaScriptArguments = false;
    this.javaScriptArgumentsDepth = 0;

    this.isInterpolating = false;
    this.interpolationNesting = 0;

    this.jsState = CodeMirror.startState(jsMode);

    this.restOfLine = '';

    this.isIncludeFiltered = false;
    this.isEach = false;

    this.lastTag = '';
    this.scriptType = '';

    // Attributes Mode
    this.isAttrs = false;
    this.attrsNest = [];
    this.inAttributeName = true;
    this.attributeIsType = false;
    this.attrValue = '';

    // Indented Mode
    this.indentOf = Infinity;
    this.indentToken = '';

    this.innerMode = null;
    this.innerState = null;

    this.innerModeForLine = false;
  }
<span class="apidocCodeCommentSpan">  /**
   * Safely copy a state
   *
   * @return {State}
   */
</span>  State.prototype.copy = function () {
    var res = new State();
    res.javaScriptLine = this.javaScriptLine;
    res.javaScriptLineExcludesColon = this.javaScriptLineExcludesColon;
    res.javaScriptArguments = this.javaScriptArguments;
    res.javaScriptArgumentsDepth = this.javaScriptArgumentsDepth;
    res.isInterpolating = this.isInterpolating;
    res.interpolationNesting = this.interpolationNesting;

    res.jsState = CodeMirror.copyState(jsMode, this.jsState);

    res.innerMode = this.innerMode;
    if (this.innerMode &amp;&amp; this.innerState) {
      res.innerState = CodeMirror.copyState(this.innerMode, this.innerState);
    }

    res.restOfLine = this.restOfLine;

    res.isIncludeFiltered = this.isIncludeFiltered;
    res.isEach = this.isEach;
    res.lastTag = this.lastTag;
    res.scriptType = this.scriptType;
    res.isAttrs = this.isAttrs;
    res.attrsNest = this.attrsNest.slice();
    res.inAttributeName = this.inAttributeName;
    res.attributeIsType = this.attributeIsType;
    res.attrValue = this.attrValue;
    res.indentOf = this.indentOf;
    res.indentToken = this.indentToken;

    res.innerModeForLine = this.innerModeForLine;

    return res;
  };

  function javaScript(stream, state) {
    if (stream.sol()) {
      // if javaScriptLine was set at end of line, ignore it
      state.javaScriptLine = false;
      state.javaScriptLineExcludesColon = false;
    }
    if (state.javaScriptLine) {
      if (state.javaScriptLineExcludesColon &amp;&amp; stream.peek() === ':') {
        state.javaScriptLine = false;
        state.javaScriptLineExcludesColon = false;
        return;
      }
      var tok = jsMode.token(stream, state.jsState);
      if (stream.eol()) state.javaScriptLine = false;
      return tok || true;
    }
  }
  function javaScriptArguments(stream, state) {
    if (state.javaScriptArguments) {
      if (state.javaScriptArgumentsDepth === 0 &amp;&amp; stream.peek() !== '(') {
        state.javaScriptArguments = false;
        return;
      }
      if (stream.peek() === '(') {
        state.javaScriptArgumentsDepth++;
      } else if (stream.peek() === ')') {
        state.javaScriptArgumentsDepth--;
      }
      if (state.javaScriptArgumentsDepth === 0) {
        state.javaScriptArguments = false;
        return;
      }

      var tok = jsMode.token(stream, state.jsState);
      return tok || true;
    }
  }

  function yieldStatement(stream) {
    if (stream.match(/^yield\b/)) {
        return 'keyword';
    }
  }

  function doctype(stream) {
    if (stream.match(/^(?:doctype) *([^\n]+)?/)) {
        return DOCTYPE;
    }
  }

  function interpolation(stream, state) {
    if (stream.match('#{')) {
      state.isInterpolating = true;
      state.interpolationNesting = 0;
      return 'punctuation';
    }
  }

  function interpolationContinued(stream, state) {
    if (state.isInterpolating) {
      if (stream.peek() === '}') {
        state.interpolationNesting--;
        if (state.interpolationNesting &lt; 0) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.puppet" id="apidoc.element.codemirror.modes.puppet">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>puppet
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">puppet = function () {
  // Stores the words from the define method
  var words = {};
  // Taken, mostly, from the Puppet official variable standards regex
  var variable_regex = /({)?([a-z][a-z0-9_]*)?((::[a-z][a-z0-9_]*)*::)?[a-zA-Z0-9_]+(})?/;

  // Takes a string of words separated by spaces and adds them as
  // keys with the value of the first argument 'style'
  function define(style, string) {
    var split = string.split(' ');
    for (var i = 0; i &lt; split.length; i++) {
      words[split[i]] = style;
    }
  }

  // Takes commonly known puppet types/words and classifies them to a style
  define('keyword', 'class define site node include import inherits');
  define('keyword', 'case if else in and elsif default or');
  define('atom', 'false true running present absent file directory undef');
  define('builtin', 'action augeas burst chain computer cron destination dport exec ' +
    'file filebucket group host icmp iniface interface jump k5login limit log_level ' +
    'log_prefix macauthorization mailalias maillist mcx mount nagios_command ' +
    'nagios_contact nagios_contactgroup nagios_host nagios_hostdependency ' +
    'nagios_hostescalation nagios_hostextinfo nagios_hostgroup nagios_service ' +
    'nagios_servicedependency nagios_serviceescalation nagios_serviceextinfo ' +
    'nagios_servicegroup nagios_timeperiod name notify outiface package proto reject ' +
    'resources router schedule scheduled_task selboolean selmodule service source ' +
    'sport ssh_authorized_key sshkey stage state table tidy todest toports tosource ' +
    'user vlan yumrepo zfs zone zpool');

  // After finding a start of a string ('|") this function attempts to find the end;
  // If a variable is encountered along the way, we display it differently when it
  // is encapsulated in a double-quoted string.
  function tokenString(stream, state) {
    var current, prev, found_var = false;
    while (!stream.eol() &amp;&amp; (current = stream.next()) != state.pending) {
      if (current === '$' &amp;&amp; prev != '\\' &amp;&amp; state.pending == '"') {
        found_var = true;
        break;
      }
      prev = current;
    }
    if (found_var) {
      stream.backUp(1);
    }
    if (current == state.pending) {
      state.continueString = false;
    } else {
      state.continueString = true;
    }
    return "string";
  }

  // Main function
  function tokenize(stream, state) {
    // Matches one whole word
    var word = stream.match(/[\w]+/, false);
    // Matches attributes (i.e. ensure =&gt; present ; 'ensure' would be matched)
    var attribute = stream.match(/(\s+)?\w+\s+=&gt;.*/, false);
    // Matches non-builtin resource declarations
    // (i.e. "apache::vhost {" or "mycustomclasss {" would be matched)
    var resource = stream.match(/(\s+)?[\w:_]+(\s+)?{/, false);
    // Matches virtual and exported resources (i.e. @@user { ; and the like)
    var special_resource = stream.match(/(\s+)?[@]{1,2}[\w:_]+(\s+)?{/, false);

    // Finally advance the stream
    var ch = stream.next();

    // Have we found a variable?
    if (ch === '$') {
      if (stream.match(variable_regex)) {
        // If so, and its in a string, assign it a different color
        return state.continueString ? 'variable-2' : 'variable';
      }
      // Otherwise return an invalid variable
      return "error";
    }
    // Should we still be looking for the end of a string?
    if (state.continueString) {
      // If so, go through the loop again
      stream.backUp(1);
      return tokenString(stream, state);
    }
    // Are we in a definition (class, node, define)?
    if (state.inDefinition) {
      // If so, return def (i.e. for 'class myclass {' ; 'myclass' would be matched)
      if (stream.match(/(\s+)?[\w:_]+(\s+)?/)) {
        return 'def';
      }
      // Match the rest it the next time around
      stream.match(/\s+{/);
      state.inDefinition = false;
    }
    // Are we in an 'include' statement?
    if (state.inInclude) {
      // Match and return the included class
      stream.match(/(\s+)?\S+(\s+)?/);
      state.inInclude = false;
      return 'def';
    }
    // D ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.python" id="apidoc.element.codemirror.modes.python">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>python
        <span class="apidocSignatureSpan">(conf, parserConf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">python = function (conf, parserConf) {
  var ERRORCLASS = "error";

  var singleDelimiters = parserConf.singleDelimiters || /^[\(\)\[\]\{\}@,:`=;\.]/;
  var doubleOperators = parserConf.doubleOperators || /^([!&lt;&gt;]==|&lt;&gt;|&lt;&lt;|&gt;&gt;|\/\/|\*\*)/;
  var doubleDelimiters = parserConf.doubleDelimiters || /^(\+=|\-=|\*=|%=|\/=|&amp;=|\|=|\^=)/;
  var tripleDelimiters = parserConf.tripleDelimiters || /^(\/\/=|&gt;&gt;=|&lt;&lt;=|\*\*=)/;

  var hangingIndent = parserConf.hangingIndent || conf.indentUnit;

  var myKeywords = commonKeywords, myBuiltins = commonBuiltins;
  if (parserConf.extra_keywords != undefined)
    myKeywords = myKeywords.concat(parserConf.extra_keywords);

  if (parserConf.extra_builtins != undefined)
    myBuiltins = myBuiltins.concat(parserConf.extra_builtins);

  var py3 = !(parserConf.version &amp;&amp; Number(parserConf.version) &lt; 3)
  if (py3) {
    // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator
    var singleOperators = parserConf.singleOperators || /^[\+\-\*\/%&amp;|\^~&lt;&gt;!@]/;
    var identifiers = parserConf.identifiers|| /^[_A-Za-z\u00A1-\uFFFF][_A-Za-z0-9\u00A1-\uFFFF]*/;
    myKeywords = myKeywords.concat(["nonlocal", "False", "True", "None", "async", "await"]);
    myBuiltins = myBuiltins.concat(["ascii", "bytes", "exec", "print"]);
    var stringPrefixes = new RegExp("^(([rbuf]|(br))?('{3}|\"{3}|['\"]))", "i");
  } else {
    var singleOperators = parserConf.singleOperators || /^[\+\-\*\/%&amp;|\^~&lt;&gt;!]/;
    var identifiers = parserConf.identifiers|| /^[_A-Za-z][_A-Za-z0-9]*/;
    myKeywords = myKeywords.concat(["exec", "print"]);
    myBuiltins = myBuiltins.concat(["apply", "basestring", "buffer", "cmp", "coerce", "execfile",
                                    "file", "intern", "long", "raw_input", "reduce", "reload",
                                    "unichr", "unicode", "xrange", "False", "True", "None"]);
    var stringPrefixes = new RegExp("^(([rubf]|(ur)|(br))?('{3}|\"{3}|['\"]))", "i");
  }
  var keywords = wordRegexp(myKeywords);
  var builtins = wordRegexp(myBuiltins);

  // tokenizers
  function tokenBase(stream, state) {
    if (stream.sol()) state.indent = stream.indentation()
    // Handle scope changes
    if (stream.sol() &amp;&amp; top(state).type == "py") {
      var scopeOffset = top(state).offset;
      if (stream.eatSpace()) {
        var lineOffset = stream.indentation();
        if (lineOffset &gt; scopeOffset)
          pushPyScope(state);
        else if (lineOffset &lt; scopeOffset &amp;&amp; dedent(stream, state) &amp;&amp; stream.peek() != "#")
          state.errorToken = true;
        return null;
      } else {
        var style = tokenBaseInner(stream, state);
        if (scopeOffset &gt; 0 &amp;&amp; dedent(stream, state))
          style += " " + ERRORCLASS;
        return style;
      }
    }
    return tokenBaseInner(stream, state);
  }

  function tokenBaseInner(stream, state) {
    if (stream.eatSpace()) return null;

    var ch = stream.peek();

    // Handle Comments
    if (ch == "#") {
      stream.skipToEnd();
      return "comment";
    }

    // Handle Number Literals
    if (stream.match(/^[0-9\.]/, false)) {
      var floatLiteral = false;
      // Floats
      if (stream.match(/^[\d_]*\.\d+(e[\+\-]?\d+)?/i)) { floatLiteral = true; }
      if (stream.match(/^[\d_]+\.\d*/)) { floatLiteral = true; }
      if (stream.match(/^\.\d+/)) { floatLiteral = true; }
      if (floatLiteral) {
        // Float literals may be "imaginary"
        stream.eat(/J/i);
        return "number";
      }
      // Integers
      var intLiteral = false;
      // Hex
      if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true;
      // Binary
      if (stream.match(/^0b[01_]+/i)) intLiteral = true;
      // Octal
      if (stream.match(/^0o[0-7_]+/i)) intLiteral = true;
      // Decimal
      if (stream.match(/^[1-9][\d_]*(e[\+\-]?[\d_]+)?/)) {
        // Decimal literals may be "imaginary"
        stream.eat(/J/i);
        // TODO - Can you have imaginary longs?
        intLiteral = true;
      }
      // Zero by itself with no other piece of number.
      if (stream.match(/^0(?![\dx])/i)) intLiteral = true;
      if (intLiteral) ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.q" id="apidoc.element.codemirror.modes.q">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>q
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">q = function (config){
  var indentUnit=config.indentUnit,
      curPunc,
      keywords=buildRE(["abs","acos","aj","aj0","all","and","any","asc","asin","asof","atan","attr","avg","avgs","bin","by","ceiling
","cols","cor","cos","count","cov","cross","csv","cut","delete","deltas","desc","dev","differ","distinct","div","do","each","ej","
enlist","eval","except","exec","exit","exp","fby","fills","first","fkeys","flip","floor","from","get","getenv","group","gtime","
hclose","hcount","hdel","hopen","hsym","iasc","idesc","if","ij","in","insert","inter","inv","key","keys","last","like","list","lj
","load","log","lower","lsq","ltime","ltrim","mavg","max","maxs","mcount","md5","mdev","med","meta","min","mins","mmax","mmin","
mmu","mod","msum","neg","next","not","null","or","over","parse","peach","pj","plist","prd","prds","prev","prior","rand","rank","
ratios","raze","read0","read1","reciprocal","reverse","rload","rotate","rsave","rtrim","save","scan","select","set","setenv","show
","signum","sin","sqrt","ss","ssr","string","sublist","sum","sums","sv","system","tables","tan","til","trim","txf","type","uj","
ungroup","union","update","upper","upsert","value","var","view","views","vs","wavg","where","where","while","within","wj","wj1","
wsum","xasc","xbar","xcol","xcols","xdesc","xexp","xgroup","xkey","xlog","xprev","xrank"]),
      E=/[|/&amp;^!+:\\\-*%$=~#;@&gt;&lt;,?_\'\"\[\(\]\)\s{}]/;
  function buildRE(w){return new RegExp("^("+w.join("|")+")$");}
  function tokenBase(stream,state){
    var sol=stream.sol(),c=stream.next();
    curPunc=null;
    if(sol)
      if(c=="/")
        return(state.tokenize=tokenLineComment)(stream,state);
      else if(c=="\\"){
        if(stream.eol()||/\s/.test(stream.peek()))
          return stream.skipToEnd(),/^\\\s*$/.test(stream.current())?(state.tokenize=tokenCommentToEOF)(stream, state):state.tokenize
=tokenBase,"comment";
        else
          return state.tokenize=tokenBase,"builtin";
      }
    if(/\s/.test(c))
      return stream.peek()=="/"?(stream.skipToEnd(),"comment"):"whitespace";
    if(c=='"')
      return(state.tokenize=tokenString)(stream,state);
    if(c=='`')
      return stream.eatWhile(/[A-Z|a-z|\d|_|:|\/|\.]/),"symbol";
    if(("."==c&amp;&amp;/\d/.test(stream.peek()))||/\d/.test(c)){
      var t=null;
      stream.backUp(1);
      if(stream.match(/^\d{4}\.\d{2}(m|\.\d{2}([D|T](\d{2}(:\d{2}(:\d{2}(\.\d{1,9})?)?)?)?)?)/)
      || stream.match(/^\d+D(\d{2}(:\d{2}(:\d{2}(\.\d{1,9})?)?)?)/)
      || stream.match(/^\d{2}:\d{2}(:\d{2}(\.\d{1,9})?)?/)
      || stream.match(/^\d+[ptuv]{1}/))
        t="temporal";
      else if(stream.match(/^0[NwW]{1}/)
      || stream.match(/^0x[\d|a-f|A-F]*/)
      || stream.match(/^[0|1]+[b]{1}/)
      || stream.match(/^\d+[chijn]{1}/)
      || stream.match(/-?\d*(\.\d*)?(e[+\-]?\d+)?(e|f)?/))
        t="number";
      return(t&amp;&amp;(!(c=stream.peek())||E.test(c)))?t:(stream.next(),"error");
    }
    if(/[A-Z|a-z]|\./.test(c))
      return stream.eatWhile(/[A-Z|a-z|\.|_|\d]/),keywords.test(stream.current())?"keyword":"variable";
    if(/[|/&amp;^!+:\\\-*%$=~#;@&gt;&lt;\.,?_\']/.test(c))
      return null;
    if(/[{}\(\[\]\)]/.test(c))
      return null;
    return"error";
  }
  function tokenLineComment(stream,state){
    return stream.skipToEnd(),/\/\s*$/.test(stream.current())?(state.tokenize=tokenBlockComment)(stream,state):(state.tokenize=tokenBase
),"comment";
  }
  function tokenBlockComment(stream,state){
    var f=stream.sol()&amp;&amp;stream.peek()=="\\";
    stream.skipToEnd();
    if(f&amp;&amp;/^\\\s*$/.test(stream.current()))
      state.tokenize=tokenBase;
    return"comment";
  }
  function tokenCommentToEOF(stream){return stream.skipToEnd(),"comment";}
  function tokenString(stream,state){
    var escaped=false,next,end=false;
    while((next=stream.next())){
      if(next=="\""&amp;&amp;!escaped){end=true;break;}
      escaped=!escaped&amp;&amp;next=="\\";
    }
    if(end)state.tokenize=tokenBase;
    return"string";
  }
  function pushContext(state,type,col){state.context={prev:state.context,indent:state.indent,col:col,type:type};}
  function popContext(state){state.indent=state.context.in ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.r" id="apidoc.element.codemirror.modes.r">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>r
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">r = function (config) {
  function wordObj(str) {
    var words = str.split(" "), res = {};
    for (var i = 0; i &lt; words.length; ++i) res[words[i]] = true;
    return res;
  }
  var atoms = wordObj("NULL NA Inf NaN NA_integer_ NA_real_ NA_complex_ NA_character_");
  var builtins = wordObj("list quote bquote eval return call parse deparse");
  var keywords = wordObj("if else repeat while function for in next break");
  var blockkeywords = wordObj("if else repeat while function for");
  var opChars = /[+\-*\/^&lt;&gt;=!&amp;|~$:]/;
  var curPunc;

  function tokenBase(stream, state) {
    curPunc = null;
    var ch = stream.next();
    if (ch == "#") {
      stream.skipToEnd();
      return "comment";
    } else if (ch == "0" &amp;&amp; stream.eat("x")) {
      stream.eatWhile(/[\da-f]/i);
      return "number";
    } else if (ch == "." &amp;&amp; stream.eat(/\d/)) {
      stream.match(/\d*(?:e[+\-]?\d+)?/);
      return "number";
    } else if (/\d/.test(ch)) {
      stream.match(/\d*(?:\.\d+)?(?:e[+\-]\d+)?L?/);
      return "number";
    } else if (ch == "'" || ch == '"') {
      state.tokenize = tokenString(ch);
      return "string";
    } else if (ch == "`") {
      stream.match(/[^`]+`/);
      return "variable-3";
    } else if (ch == "." &amp;&amp; stream.match(/.[.\d]+/)) {
      return "keyword";
    } else if (/[\w\.]/.test(ch) &amp;&amp; ch != "_") {
      stream.eatWhile(/[\w\.]/);
      var word = stream.current();
      if (atoms.propertyIsEnumerable(word)) return "atom";
      if (keywords.propertyIsEnumerable(word)) {
        // Block keywords start new blocks, except 'else if', which only starts
        // one new block for the 'if', no block for the 'else'.
        if (blockkeywords.propertyIsEnumerable(word) &amp;&amp;
            !stream.match(/\s*if(\s+|$)/, false))
          curPunc = "block";
        return "keyword";
      }
      if (builtins.propertyIsEnumerable(word)) return "builtin";
      return "variable";
    } else if (ch == "%") {
      if (stream.skipTo("%")) stream.next();
      return "operator variable-2";
    } else if (
        (ch == "&lt;" &amp;&amp; stream.eat("-")) ||
        (ch == "&lt;" &amp;&amp; stream.match("&lt;-")) ||
        (ch == "-" &amp;&amp; stream.match(/&gt;&gt;?/))
      ) {
      return "operator arrow";
    } else if (ch == "=" &amp;&amp; state.ctx.argList) {
      return "arg-is";
    } else if (opChars.test(ch)) {
      if (ch == "$") return "operator dollar";
      stream.eatWhile(opChars);
      return "operator";
    } else if (/[\(\){}\[\];]/.test(ch)) {
      curPunc = ch;
      if (ch == ";") return "semi";
      return null;
    } else {
      return null;
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      if (stream.eat("\\")) {
        var ch = stream.next();
        if (ch == "x") stream.match(/^[a-f0-9]{2}/i);
        else if ((ch == "u" || ch == "U") &amp;&amp; stream.eat("{") &amp;&amp; stream.skipTo("}")) stream.next();
        else if (ch == "u") stream.match(/^[a-f0-9]{4}/i);
        else if (ch == "U") stream.match(/^[a-f0-9]{8}/i);
        else if (/[0-7]/.test(ch)) stream.match(/^[0-7]{1,2}/);
        return "string-2";
      } else {
        var next;
        while ((next = stream.next()) != null) {
          if (next == quote) { state.tokenize = tokenBase; break; }
          if (next == "\\") { stream.backUp(1); break; }
        }
        return "string";
      }
    };
  }

  var ALIGN_YES = 1, ALIGN_NO = 2, BRACELESS = 4

  function push(state, type, stream) {
    state.ctx = {type: type,
                 indent: state.indent,
                 flags: 0,
                 column: stream.column(),
                 prev: state.ctx};
  }
  function setFlag(state, flag) {
    var ctx = state.ctx
    state.ctx = {type: ctx.type,
                 indent: ctx.indent,
                 flags: ctx.flags | flag,
                 column: ctx.column,
                 prev: ctx.prev}
  }
  function pop(state) {
    state.indent = state.ctx.indent;
    state.ctx = state.ctx.prev;
  }

  return {
    startState: function() {
      return {tokenize: tokenBase,
              ctx: {type: "top",
                    indent: -config.inde ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.rpm-changes" id="apidoc.element.codemirror.modes.rpm-changes">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>rpm-changes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rpm-changes = function () {
  var headerSeperator = /^-+$/;
  var headerLine = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)  ?\d{1,2} \d{2}:\d{2}(:\d{2
})? [A-Z]{3,4}\d{4} - /;
  var simpleEmail = /^[\w+.-]+@[\w.-]+/;

  return {
    token: function(stream) {
      if (stream.sol()) {
        if (stream.match(headerSeperator)) { return 'tag'; }
        if (stream.match(headerLine)) { return 'tag'; }
      }
      if (stream.match(simpleEmail)) { return 'string'; }
      stream.next();
      return null;
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.rpm-spec" id="apidoc.element.codemirror.modes.rpm-spec">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>rpm-spec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rpm-spec = function () {
  var arch = /^(i386|i586|i686|x86_64|ppc64le|ppc64|ppc|ia64|s390x|s390|sparc64|sparcv9|sparc|noarch|alphaev6|alpha|hppa|mipsel)/;

  var preamble = /^[a-zA-Z0-9()]+:/;
  var section = /^%(debug_package|package|description|prep|build|install|files|clean|changelog|preinstall|preun|postinstall|postun
|pretrans|posttrans|pre|post|triggerin|triggerun|verifyscript|check|triggerpostun|triggerprein|trigger)/;
  var control_flow_complex = /^%(ifnarch|ifarch|if)/; // rpm control flow macros
  var control_flow_simple = /^%(else|endif)/; // rpm control flow macros
  var operators = /^(\!|\?|\&lt;\=|\&lt;|\&gt;\=|\&gt;|\=\=|\&amp;\&amp;|\|\|)/; // operators in control flow macros

  return {
    startState: function () {
        return {
          controlFlow: false,
          macroParameters: false,
          section: false
        };
    },
    token: function (stream, state) {
      var ch = stream.peek();
      if (ch == "#") { stream.skipToEnd(); return "comment"; }

      if (stream.sol()) {
        if (stream.match(preamble)) { return "header"; }
        if (stream.match(section)) { return "atom"; }
      }

      if (stream.match(/^\$\w+/)) { return "def"; } // Variables like '$RPM_BUILD_ROOT'
      if (stream.match(/^\$\{\w+\}/)) { return "def"; } // Variables like '${RPM_BUILD_ROOT}'

      if (stream.match(control_flow_simple)) { return "keyword"; }
      if (stream.match(control_flow_complex)) {
        state.controlFlow = true;
        return "keyword";
      }
      if (state.controlFlow) {
        if (stream.match(operators)) { return "operator"; }
        if (stream.match(/^(\d+)/)) { return "number"; }
        if (stream.eol()) { state.controlFlow = false; }
      }

      if (stream.match(arch)) {
        if (stream.eol()) { state.controlFlow = false; }
        return "number";
      }

      // Macros like '%make_install' or '%attr(0775,root,root)'
      if (stream.match(/^%[\w]+/)) {
        if (stream.match(/^\(/)) { state.macroParameters = true; }
        return "keyword";
      }
      if (state.macroParameters) {
        if (stream.match(/^\d+/)) { return "number";}
        if (stream.match(/^\)/)) {
          state.macroParameters = false;
          return "keyword";
        }
      }

      // Macros like '%{defined fedora}'
      if (stream.match(/^%\{\??[\w \-\:\!]+\}/)) {
        if (stream.eol()) { state.controlFlow = false; }
        return "def";
      }

      //TODO: Include bash script sub-parser (CodeMirror supports that)
      stream.next();
      return null;
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.rst" id="apidoc.element.codemirror.modes.rst">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>rst
        <span class="apidocSignatureSpan">(config, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rst = function (config, options) {

  var rx_strong = /^\*\*[^\*\s](?:[^\*]*[^\*\s])?\*\*/;
  var rx_emphasis = /^\*[^\*\s](?:[^\*]*[^\*\s])?\*/;
  var rx_literal = /^``[^`\s](?:[^`]*[^`\s])``/;

  var rx_number = /^(?:[\d]+(?:[\.,]\d+)*)/;
  var rx_positive = /^(?:\s\+[\d]+(?:[\.,]\d+)*)/;
  var rx_negative = /^(?:\s\-[\d]+(?:[\.,]\d+)*)/;

  var rx_uri_protocol = "[Hh][Tt][Tt][Pp][Ss]?://";
  var rx_uri_domain = "(?:[\\d\\w.-]+)\\.(?:\\w{2,6})";
  var rx_uri_path = "(?:/[\\d\\w\\#\\%\\&amp;\\-\\.\\,\\/\\:\\=\\?\\~]+)*";
  var rx_uri = new RegExp("^" + rx_uri_protocol + rx_uri_domain + rx_uri_path);

  var overlay = {
    token: function (stream) {

      if (stream.match(rx_strong) &amp;&amp; stream.match (/\W+|$/, false))
        return 'strong';
      if (stream.match(rx_emphasis) &amp;&amp; stream.match (/\W+|$/, false))
        return 'em';
      if (stream.match(rx_literal) &amp;&amp; stream.match (/\W+|$/, false))
        return 'string-2';
      if (stream.match(rx_number))
        return 'number';
      if (stream.match(rx_positive))
        return 'positive';
      if (stream.match(rx_negative))
        return 'negative';
      if (stream.match(rx_uri))
        return 'link';

      while (stream.next() != null) {
        if (stream.match(rx_strong, false)) break;
        if (stream.match(rx_emphasis, false)) break;
        if (stream.match(rx_literal, false)) break;
        if (stream.match(rx_number, false)) break;
        if (stream.match(rx_positive, false)) break;
        if (stream.match(rx_negative, false)) break;
        if (stream.match(rx_uri, false)) break;
      }

      return null;
    }
  };

  var mode = CodeMirror.getMode(
    config, options.backdrop || 'rst-base'
  );

  return CodeMirror.overlayMode(mode, overlay, true); // combine
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.rst-base" id="apidoc.element.codemirror.modes.rst-base">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>rst-base
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rst-base = function (config) {

  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////

  function format(string) {
    var args = Array.prototype.slice.call(arguments, 1);
    return string.replace(/{(\d+)}/g, function (match, n) {
      return typeof args[n] != 'undefined' ? args[n] : match;
    });
  }

  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////

  var mode_python = CodeMirror.getMode(config, 'python');
  var mode_stex = CodeMirror.getMode(config, 'stex');

  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////

  var SEPA = "\\s+";
  var TAIL = "(?:\\s*|\\W|$)",
  rx_TAIL = new RegExp(format('^{0}', TAIL));

  var NAME =
    "(?:[^\\W\\d_](?:[\\w!\"#$%&amp;'()\\*\\+,\\-\\.\/:;&lt;=&gt;\\?]*[^\\W_])?)",
  rx_NAME = new RegExp(format('^{0}', NAME));
  var NAME_WWS =
    "(?:[^\\W\\d_](?:[\\w\\s!\"#$%&amp;'()\\*\\+,\\-\\.\/:;&lt;=&gt;\\?]*[^\\W_])?)";
  var REF_NAME = format('(?:{0}|`{1}`)', NAME, NAME_WWS);

  var TEXT1 = "(?:[^\\s\\|](?:[^\\|]*[^\\s\\|])?)";
  var TEXT2 = "(?:[^\\`]+)",
  rx_TEXT2 = new RegExp(format('^{0}', TEXT2));

  var rx_section = new RegExp(
    "^([!'#$%&amp;\"()*+,-./:;&lt;=&gt;?@\\[\\\\\\]^_`{|}~])\\1{3,}\\s*$");
  var rx_explicit = new RegExp(
    format('^\\.\\.{0}', SEPA));
  var rx_link = new RegExp(
    format('^_{0}:{1}|^__:{1}', REF_NAME, TAIL));
  var rx_directive = new RegExp(
    format('^{0}::{1}', REF_NAME, TAIL));
  var rx_substitution = new RegExp(
    format('^\\|{0}\\|{1}{2}::{3}', TEXT1, SEPA, REF_NAME, TAIL));
  var rx_footnote = new RegExp(
    format('^\\[(?:\\d+|#{0}?|\\*)]{1}', REF_NAME, TAIL));
  var rx_citation = new RegExp(
    format('^\\[{0}\\]{1}', REF_NAME, TAIL));

  var rx_substitution_ref = new RegExp(
    format('^\\|{0}\\|', TEXT1));
  var rx_footnote_ref = new RegExp(
    format('^\\[(?:\\d+|#{0}?|\\*)]_', REF_NAME));
  var rx_citation_ref = new RegExp(
    format('^\\[{0}\\]_', REF_NAME));
  var rx_link_ref1 = new RegExp(
    format('^{0}__?', REF_NAME));
  var rx_link_ref2 = new RegExp(
    format('^`{0}`_', TEXT2));

  var rx_role_pre = new RegExp(
    format('^:{0}:`{1}`{2}', NAME, TEXT2, TAIL));
  var rx_role_suf = new RegExp(
    format('^`{1}`:{0}:{2}', NAME, TEXT2, TAIL));
  var rx_role = new RegExp(
    format('^:{0}:{1}', NAME, TAIL));

  var rx_directive_name = new RegExp(format('^{0}', REF_NAME));
  var rx_directive_tail = new RegExp(format('^::{0}', TAIL));
  var rx_substitution_text = new RegExp(format('^\\|{0}\\|', TEXT1));
  var rx_substitution_sepa = new RegExp(format('^{0}', SEPA));
  var rx_substitution_name = new RegExp(format('^{0}', REF_NAME));
  var rx_substitution_tail = new RegExp(format('^::{0}', TAIL));
  var rx_link_head = new RegExp("^_");
  var rx_link_name = new RegExp(format('^{0}|_', REF_NAME));
  var rx_link_tail = new RegExp(format('^:{0}', TAIL));

  var rx_verbatim = new RegExp('^::\\s*$');
  var rx_examples = new RegExp('^\\s+(?:&gt;&gt;&gt;|In \\[\\d+\\]:)\\s');

  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////

  function to_normal(stream, state) {
    var token = null;

    if (stream.sol() &amp;&amp; stream.match(rx_examples, false)) {
      change(state, to_mode, {
        mode: mode_python, local: CodeMirror.startState(mode_python)
      });
    } else if (stream.sol() &amp;&amp; stream.match(rx_explicit)) {
      change(state, to_explicit);
      token = 'meta';
    } else if (stream.sol() &amp;&amp; stream.match(rx_section)) {
      change(state, to_normal);
      token = 'header';
    } else if (phase(state) == rx_role_pre ||
               stream.match(rx_role_pre, false)) {

      switch (stage(state)) {
      case 0:
        change(state, to_normal, context(rx_role_pre, 1));
        stream.match(/^:/);
        token = 'meta';
        break;
      case 1:
        chan ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.ruby" id="apidoc.element.codemirror.modes.ruby">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>ruby
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ruby = function (config) {
  function wordObj(words) {
    var o = {};
    for (var i = 0, e = words.length; i &lt; e; ++i) o[words[i]] = true;
    return o;
  }
  var keywords = wordObj([
    "alias", "and", "BEGIN", "begin", "break", "case", "class", "def", "defined?", "do", "else",
    "elsif", "END", "end", "ensure", "false", "for", "if", "in", "module", "next", "not", "or",
    "redo", "rescue", "retry", "return", "self", "super", "then", "true", "undef", "unless",
    "until", "when", "while", "yield", "nil", "raise", "throw", "catch", "fail", "loop", "callcc",
    "caller", "lambda", "proc", "public", "protected", "private", "require", "load",
    "require_relative", "extend", "autoload", "__END__", "__FILE__", "__LINE__", "__dir__"
  ]);
  var indentWords = wordObj(["def", "class", "case", "for", "while", "until", "module", "then",
                             "catch", "loop", "proc", "begin"]);
  var dedentWords = wordObj(["end", "until"]);
  var matching = {"[": "]", "{": "}", "(": ")"};
  var curPunc;

  function chain(newtok, stream, state) {
    state.tokenize.push(newtok);
    return newtok(stream, state);
  }

  function tokenBase(stream, state) {
    if (stream.sol() &amp;&amp; stream.match("=begin") &amp;&amp; stream.eol()) {
      state.tokenize.push(readBlockComment);
      return "comment";
    }
    if (stream.eatSpace()) return null;
    var ch = stream.next(), m;
    if (ch == "`" || ch == "'" || ch == '"') {
      return chain(readQuoted(ch, "string", ch == '"' || ch == "`"), stream, state);
    } else if (ch == "/") {
      if (regexpAhead(stream))
        return chain(readQuoted(ch, "string-2", true), stream, state);
      else
        return "operator";
    } else if (ch == "%") {
      var style = "string", embed = true;
      if (stream.eat("s")) style = "atom";
      else if (stream.eat(/[WQ]/)) style = "string";
      else if (stream.eat(/[r]/)) style = "string-2";
      else if (stream.eat(/[wxq]/)) { style = "string"; embed = false; }
      var delim = stream.eat(/[^\w\s=]/);
      if (!delim) return "operator";
      if (matching.propertyIsEnumerable(delim)) delim = matching[delim];
      return chain(readQuoted(delim, style, embed, true), stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return "comment";
    } else if (ch == "&lt;" &amp;&amp; (m = stream.match(/^&lt;-?[\`\"\']?([a-zA-Z_?]\w*)[\`\"\']?(?:;|$)/))) {
      return chain(readHereDoc(m[1]), stream, state);
    } else if (ch == "0") {
      if (stream.eat("x")) stream.eatWhile(/[\da-fA-F]/);
      else if (stream.eat("b")) stream.eatWhile(/[01]/);
      else stream.eatWhile(/[0-7]/);
      return "number";
    } else if (/\d/.test(ch)) {
      stream.match(/^[\d_]*(?:\.[\d_]+)?(?:[eE][+\-]?[\d_]+)?/);
      return "number";
    } else if (ch == "?") {
      while (stream.match(/^\\[CM]-/)) {}
      if (stream.eat("\\")) stream.eatWhile(/\w/);
      else stream.next();
      return "string";
    } else if (ch == ":") {
      if (stream.eat("'")) return chain(readQuoted("'", "atom", false), stream, state);
      if (stream.eat('"')) return chain(readQuoted('"', "atom", true), stream, state);

      // :&gt; :&gt;&gt; :&lt; :&lt;&lt; are valid symbols
      if (stream.eat(/[\&lt;\&gt;]/)) {
        stream.eat(/[\&lt;\&gt;]/);
        return "atom";
      }

      // :+ :- :/ :* :| :&amp; :! are valid symbols
      if (stream.eat(/[\+\-\*\/\&amp;\|\:\!]/)) {
        return "atom";
      }

      // Symbols can't start by a digit
      if (stream.eat(/[a-zA-Z$@_\xa1-\uffff]/)) {
        stream.eatWhile(/[\w$\xa1-\uffff]/);
        // Only one ? ! = is allowed and only as the last character
        stream.eat(/[\?\!\=]/);
        return "atom";
      }
      return "operator";
    } else if (ch == "@" &amp;&amp; stream.match(/^@?[a-zA-Z_\xa1-\uffff]/)) {
      stream.eat("@");
      stream.eatWhile(/[\w\xa1-\uffff]/);
      return "variable-2";
    } else if (ch == "$") {
      if (stream.eat(/[a-zA-Z_]/)) {
        stream.eatWhile(/[\w]/);
      } else if (stream.eat(/\d/)) {
        stream.eat(/\d/);
      } else {
        stream.next(); // Must be a special global like $: or $!
      } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.rust" id="apidoc.element.codemirror.modes.rust">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>rust
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rust = function (config) {
  return CodeMirror.simpleMode(config, states);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.sas" id="apidoc.element.codemirror.modes.sas">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>sas
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sas = function () {
  var words = {};
  var isDoubleOperatorSym = {
    eq: 'operator',
    lt: 'operator',
    le: 'operator',
    gt: 'operator',
    ge: 'operator',
    "in": 'operator',
    ne: 'operator',
    or: 'operator'
  };
  var isDoubleOperatorChar = /(&lt;=|&gt;=|!=|&lt;&gt;)/;
  var isSingleOperatorChar = /[=\(:\),{}.*&lt;&gt;+\-\/^\[\]]/;

  // Takes a string of words separated by spaces and adds them as
  // keys with the value of the first argument 'style'
  function define(style, string, context) {
    if (context) {
      var split = string.split(' ');
      for (var i = 0; i &lt; split.length; i++) {
        words[split[i]] = {style: style, state: context};
      }
    }
  }
  //datastep
  define('def', 'stack pgm view source debug nesting nolist', ['inDataStep']);
  define('def', 'if while until for do do; end end; then else cancel', ['inDataStep']);
  define('def', 'label format _n_ _error_', ['inDataStep']);
  define('def', 'ALTER BUFNO BUFSIZE CNTLLEV COMPRESS DLDMGACTION ENCRYPT ENCRYPTKEY EXTENDOBSCOUNTER GENMAX GENNUM INDEX LABEL
OBSBUF OUTREP PW PWREQ READ REPEMPTY REPLACE REUSE ROLE SORTEDBY SPILL TOBSNO TYPE WRITE FILECLOSE FIRSTOBS IN OBS POINTOBS WHERE
 WHEREUP IDXNAME IDXWHERE DROP KEEP RENAME', ['inDataStep']);
  define('def', 'filevar finfo finv fipname fipnamel fipstate first firstobs floor', ['inDataStep']);
  define('def', 'varfmt varinfmt varlabel varlen varname varnum varray varrayx vartype verify vformat vformatd vformatdx vformatn
 vformatnx vformatw vformatwx vformatx vinarray vinarrayx vinformat vinformatd vinformatdx vinformatn vinformatnx vinformatw vinformatwx
 vinformatx vlabel vlabelx vlength vlengthx vname vnamex vnferr vtype vtypex weekday', ['inDataStep']);
  define('def', 'zipfips zipname zipnamel zipstate', ['inDataStep']);
  define('def', 'put putc putn', ['inDataStep']);
  define('builtin', 'data run', ['inDataStep']);


  //proc
  define('def', 'data', ['inProc']);

  // flow control for macros
  define('def', '%if %end %end; %else %else; %do %do; %then', ['inMacro']);

  //everywhere
  define('builtin', 'proc run; quit; libname filename %macro %mend option options', ['ALL']);

  define('def', 'footnote title libname ods', ['ALL']);
  define('def', '%let %put %global %sysfunc %eval ', ['ALL']);
  // automatic macro variables http://support.sas.com/documentation/cdl/en/mcrolref/61885/HTML/default/viewer.htm#a003167023.htm
  define('variable', '&amp;sysbuffr &amp;syscc &amp;syscharwidth &amp;syscmd &amp;sysdate &amp;sysdate9 &amp;sysday &amp;sysdevic &amp;sysdmg &amp;sysdsn &amp;sysencoding &amp;
sysenv &amp;syserr &amp;syserrortext &amp;sysfilrc &amp;syshostname &amp;sysindex &amp;sysinfo &amp;sysjobid &amp;syslast &amp;syslckrc &amp;syslibrc &amp;syslogapplname &amp;sysmacroname
 &amp;sysmenv &amp;sysmsg &amp;sysncpu &amp;sysodspath &amp;sysparm &amp;syspbuff &amp;sysprocessid &amp;sysprocessname &amp;sysprocname &amp;sysrc &amp;sysscp &amp;sysscpl &amp;sysscpl
 &amp;syssite &amp;sysstartid &amp;sysstartname &amp;systcpiphostname &amp;systime &amp;sysuserid &amp;sysver &amp;sysvlong &amp;sysvlong4 &amp;syswarningtext', ['ALL']);

  //footnote[1-9]? title[1-9]?

  //options statement
  define('def', 'source2 nosource2 page pageno pagesize', ['ALL']);

  //proc and datastep
  define('def', '_all_ _character_ _cmd_ _freq_ _i_ _infile_ _last_ _msg_ _null_ _numeric_ _temporary_ _type_ abort abs addr adjrsq
 airy alpha alter altlog altprint and arcos array arsin as atan attrc attrib attrn authserver autoexec awscontrol awsdef awsmenu
 awsmenumerge awstitle backward band base betainv between blocksize blshift bnot bor brshift bufno bufsize bxor by byerr byline
byte calculated call cards cards4 catcache cbufno cdf ceil center cexist change chisq cinv class cleanup close cnonct cntllev coalesce
 codegen col collate collin column comamid comaux1 comaux2 comdef compbl compound compress config continue convert cos cosh cpuid
 create cross crosstab css curobs cv daccdb daccdbsl daccsl daccsyd dacctab dairy datalines datalines4 datejul datepart datetime
 day dbcslang dbcstype dclose ddm delete delimiter depdb depdbsl depsl depsyd deptab dequote descending descript design= device
dflang dhms dif digamma dim dinfo display distinct dkricond dkrocond dlm dnum do dopen doptname doptnum dread ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.sass" id="apidoc.element.codemirror.modes.sass">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>sass
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sass = function (config) {
  var cssMode = CodeMirror.mimeModes["text/css"];
  var propertyKeywords = cssMode.propertyKeywords || {},
      colorKeywords = cssMode.colorKeywords || {},
      valueKeywords = cssMode.valueKeywords || {},
      fontProperties = cssMode.fontProperties || {};

  function tokenRegexp(words) {
    return new RegExp("^" + words.join("|"));
  }

  var keywords = ["true", "false", "null", "auto"];
  var keywordsRegexp = new RegExp("^" + keywords.join("|"));

  var operators = ["\\(", "\\)", "=", "&gt;", "&lt;", "==", "&gt;=", "&lt;=", "\\+", "-",
                   "\\!=", "/", "\\*", "%", "and", "or", "not", ";","\\{","\\}",":"];
  var opRegexp = tokenRegexp(operators);

  var pseudoElementsRegexp = /^::?[a-zA-Z_][\w\-]*/;

  var word;

  function isEndLine(stream) {
    return !stream.peek() || stream.match(/\s+$/, false);
  }

  function urlTokens(stream, state) {
    var ch = stream.peek();

    if (ch === ")") {
      stream.next();
      state.tokenizer = tokenBase;
      return "operator";
    } else if (ch === "(") {
      stream.next();
      stream.eatSpace();

      return "operator";
    } else if (ch === "'" || ch === '"') {
      state.tokenizer = buildStringTokenizer(stream.next());
      return "string";
    } else {
      state.tokenizer = buildStringTokenizer(")", false);
      return "string";
    }
  }
  function comment(indentation, multiLine) {
    return function(stream, state) {
      if (stream.sol() &amp;&amp; stream.indentation() &lt;= indentation) {
        state.tokenizer = tokenBase;
        return tokenBase(stream, state);
      }

      if (multiLine &amp;&amp; stream.skipTo("*/")) {
        stream.next();
        stream.next();
        state.tokenizer = tokenBase;
      } else {
        stream.skipToEnd();
      }

      return "comment";
    };
  }

  function buildStringTokenizer(quote, greedy) {
    if (greedy == null) { greedy = true; }

    function stringTokenizer(stream, state) {
      var nextChar = stream.next();
      var peekChar = stream.peek();
      var previousChar = stream.string.charAt(stream.pos-2);

      var endingString = ((nextChar !== "\\" &amp;&amp; peekChar === quote) || (nextChar === quote &amp;&amp; previousChar !== "\\"));

      if (endingString) {
        if (nextChar !== quote &amp;&amp; greedy) { stream.next(); }
        if (isEndLine(stream)) {
          state.cursorHalf = 0;
        }
        state.tokenizer = tokenBase;
        return "string";
      } else if (nextChar === "#" &amp;&amp; peekChar === "{") {
        state.tokenizer = buildInterpolationTokenizer(stringTokenizer);
        stream.next();
        return "operator";
      } else {
        return "string";
      }
    }

    return stringTokenizer;
  }

  function buildInterpolationTokenizer(currentTokenizer) {
    return function(stream, state) {
      if (stream.peek() === "}") {
        stream.next();
        state.tokenizer = currentTokenizer;
        return "operator";
      } else {
        return tokenBase(stream, state);
      }
    };
  }

  function indent(state) {
    if (state.indentCount == 0) {
      state.indentCount++;
      var lastScopeOffset = state.scopes[0].offset;
      var currentOffset = lastScopeOffset + config.indentUnit;
      state.scopes.unshift({ offset:currentOffset });
    }
  }

  function dedent(state) {
    if (state.scopes.length == 1) return;

    state.scopes.shift();
  }

  function tokenBase(stream, state) {
    var ch = stream.peek();

    // Comment
    if (stream.match("/*")) {
      state.tokenizer = comment(stream.indentation(), true);
      return state.tokenizer(stream, state);
    }
    if (stream.match("//")) {
      state.tokenizer = comment(stream.indentation(), false);
      return state.tokenizer(stream, state);
    }

    // Interpolation
    if (stream.match("#{")) {
      state.tokenizer = buildInterpolationTokenizer(tokenBase);
      return "operator";
    }

    // Strings
    if (ch === '"' || ch === "'") {
      stream.next();
      state.tokenizer = buildStringTokenizer(ch);
      return "string";
    }

    if(!state.cursorHalf){// state.cursorHalf === 0
    // first half i.e. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.scheme" id="apidoc.element.codemirror.modes.scheme">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>scheme
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scheme = function () {
    var BUILTIN = "builtin", COMMENT = "comment", STRING = "string",
        ATOM = "atom", NUMBER = "number", BRACKET = "bracket";
    var INDENT_WORD_SKIP = 2;

    function makeKeywords(str) {
        var obj = {}, words = str.split(" ");
        for (var i = 0; i &lt; words.length; ++i) obj[words[i]] = true;
        return obj;
    }

    var keywords = makeKeywords("Î» case-lambda call/cc class define-class exit-handler field import inherit init-field interface
 let*-values let-values let/ec mixin opt-lambda override protect provide public rename require require-for-syntax syntax syntax-
case syntax-error unit/sig unless when with-syntax and begin call-with-current-continuation call-with-input-file call-with-output
-file case cond define define-syntax delay do dynamic-wind else for-each if lambda let let* let-syntax letrec letrec-syntax map
or syntax-rules abs acos angle append apply asin assoc assq assv atan boolean? caar cadr call-with-input-file call-with-output-file
 call-with-values car cdddar cddddr cdr ceiling char-&gt;integer char-alphabetic? char-ci&lt;=? char-ci&lt;? char-ci=? char-ci&gt;=? char-ci
&gt;? char-downcase char-lower-case? char-numeric? char-ready? char-upcase char-upper-case? char-whitespace? char&lt;=? char&lt;? char=?
char&gt;=? char&gt;? char? close-input-port close-output-port complex? cons cos current-input-port current-output-port denominator display
 eof-object? eq? equal? eqv? eval even? exact-&gt;inexact exact? exp expt #f floor force gcd imag-part inexact-&gt;exact inexact? input
-port? integer-&gt;char integer? interaction-environment lcm length list list-&gt;string list-&gt;vector list-ref list-tail list? load log
 magnitude make-polar make-rectangular make-string make-vector max member memq memv min modulo negative? newline not null-environment
 null? number-&gt;string number? numerator odd? open-input-file open-output-file output-port? pair? peek-char port? positive? procedure
? quasiquote quote quotient rational? rationalize read read-char real-part real? remainder reverse round scheme-report-environment
 set! set-car! set-cdr! sin sqrt string string-&gt;list string-&gt;number string-&gt;symbol string-append string-ci&lt;=? string-ci&lt;? string
-ci=? string-ci&gt;=? string-ci&gt;? string-copy string-fill! string-length string-ref string-set! string&lt;=? string&lt;? string=? string&gt;=?
string&gt;? string? substring symbol-&gt;string symbol? #t tan transcript-off transcript-on truncate values vector vector-&gt;list vector
-fill! vector-length vector-ref vector-set! with-input-from-file with-output-to-file write write-char zero?");
    var indentKeys = makeKeywords("define let letrec let* lambda");

    function stateStack(indent, type, prev) { // represents a state stack object
        this.indent = indent;
        this.type = type;
        this.prev = prev;
    }

    function pushStack(state, indent, type) {
        state.indentStack = new stateStack(indent, type, state.indentStack);
    }

    function popStack(state) {
        state.indentStack = state.indentStack.prev;
    }

    var binaryMatcher = new RegExp(/^(?:[-+]i|[-+][01]+#*(?:\/[01]+#*)?i|[-+]?[01]+#*(?:\/[01]+#*)?@[-+]?[01]+#*(?:\/[01]+#*)?|[-+]?[
01]+#*(?:\/[01]+#*)?[-+](?:[01]+#*(?:\/[01]+#*)?)?i|[-+]?[01]+#*(?:\/[01]+#*)?)(?=[()\s;"]|$)/i);
    var octalMatcher = new RegExp(/^(?:[-+]i|[-+][0-7]+#*(?:\/[0-7]+#*)?i|[-+]?[0-7]+#*(?:\/[0-7]+#*)?@[-+]?[0-7]+#*(?:\/[0-7]+#*)?|[-+]?[
0-7]+#*(?:\/[0-7]+#*)?[-+](?:[0-7]+#*(?:\/[0-7]+#*)?)?i|[-+]?[0-7]+#*(?:\/[0-7]+#*)?)(?=[()\s;"]|$)/i);
    var hexMatcher = new RegExp(/^(?:[-+]i|[-+][\da-f]+#*(?:\/[\da-f]+#*)?i|[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?@[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?|[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?[-+](?:[\da-f]+#*(?:\/[\da-f]+#*)?)?i|[-+]?[\da-f]+#*(?:\/[\da-f]+#*)?)(?=[()\s;"]|$)/i);
    var decimalMatcher = new RegExp(/^(?:[-+]i|[-+](?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)
i|[-+]?(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)@[-+]?(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+)(?:[esfdl][-+]?\d+)?)|\d+#*\/\d+#*)|[-+]?(?:(?:(?:\d+#+\.?#*|\d+\.\d*#*|\.\d+#*|\d+ ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.shell" id="apidoc.element.codemirror.modes.shell">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>shell
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shell = function () {

  var words = {};
  function define(style, string) {
    var split = string.split(' ');
    for(var i = 0; i &lt; split.length; i++) {
      words[split[i]] = style;
    }
  };

  // Atoms
  define('atom', 'true false');

  // Keywords
  define('keyword', 'if then do else elif while until for in esac fi fin ' +
    'fil done exit set unset export function');

  // Commands
  define('builtin', 'ab awk bash beep cat cc cd chown chmod chroot clear cp ' +
    'curl cut diff echo find gawk gcc get git grep kill killall ln ls make ' +
    'mkdir openssl mv nc node npm ping ps restart rm rmdir sed service sh ' +
    'shopt shred source sort sleep ssh start stop su sudo tee telnet top ' +
    'touch vi vim wall wc wget who write yes zsh');

  function tokenBase(stream, state) {
    if (stream.eatSpace()) return null;

    var sol = stream.sol();
    var ch = stream.next();

    if (ch === '\\') {
      stream.next();
      return null;
    }
    if (ch === '\'' || ch === '"' || ch === '`') {
      state.tokens.unshift(tokenString(ch, ch === "`" ? "quote" : "string"));
      return tokenize(stream, state);
    }
    if (ch === '#') {
      if (sol &amp;&amp; stream.eat('!')) {
        stream.skipToEnd();
        return 'meta'; // 'comment'?
      }
      stream.skipToEnd();
      return 'comment';
    }
    if (ch === '$') {
      state.tokens.unshift(tokenDollar);
      return tokenize(stream, state);
    }
    if (ch === '+' || ch === '=') {
      return 'operator';
    }
    if (ch === '-') {
      stream.eat('-');
      stream.eatWhile(/\w/);
      return 'attribute';
    }
    if (/\d/.test(ch)) {
      stream.eatWhile(/\d/);
      if(stream.eol() || !/\w/.test(stream.peek())) {
        return 'number';
      }
    }
    stream.eatWhile(/[\w-]/);
    var cur = stream.current();
    if (stream.peek() === '=' &amp;&amp; /\w+/.test(cur)) return 'def';
    return words.hasOwnProperty(cur) ? words[cur] : null;
  }

  function tokenString(quote, style) {
    var close = quote == "(" ? ")" : quote == "{" ? "}" : quote
    return function(stream, state) {
      var next, end = false, escaped = false;
      while ((next = stream.next()) != null) {
        if (next === close &amp;&amp; !escaped) {
          end = true;
          break;
        }
        if (next === '$' &amp;&amp; !escaped &amp;&amp; quote !== "'") {
          escaped = true;
          stream.backUp(1);
          state.tokens.unshift(tokenDollar);
          break;
        }
        if (!escaped &amp;&amp; next === quote &amp;&amp; quote !== close) {
          state.tokens.unshift(tokenString(quote, style))
          return tokenize(stream, state)
        }
        escaped = !escaped &amp;&amp; next === '\\';
      }
      if (end || !escaped) state.tokens.shift();
      return style;
    };
  };

  var tokenDollar = function(stream, state) {
    if (state.tokens.length &gt; 1) stream.eat('$');
    var ch = stream.next()
    if (/['"({]/.test(ch)) {
      state.tokens[0] = tokenString(ch, ch == "(" ? "quote" : ch == "{" ? "def" : "string");
      return tokenize(stream, state);
    }
    if (!/\d/.test(ch)) stream.eatWhile(/\w/);
    state.tokens.shift();
    return 'def';
  };

  function tokenize(stream, state) {
    return (state.tokens[0] || tokenBase) (stream, state);
  };

  return {
    startState: function() {return {tokens:[]};},
    token: function(stream, state) {
      return tokenize(stream, state);
    },
    closeBrackets: "()[]{}''\"\"``",
    lineComment: '#',
    fold: "brace"
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.sieve" id="apidoc.element.codemirror.modes.sieve">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>sieve
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sieve = function (config) {
  function words(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i &lt; words.length; ++i) obj[words[i]] = true;
    return obj;
  }

  var keywords = words("if elsif else stop require");
  var atoms = words("true false not");
  var indentUnit = config.indentUnit;

  function tokenBase(stream, state) {

    var ch = stream.next();
    if (ch == "/" &amp;&amp; stream.eat("*")) {
      state.tokenize = tokenCComment;
      return tokenCComment(stream, state);
    }

    if (ch === '#') {
      stream.skipToEnd();
      return "comment";
    }

    if (ch == "\"") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }

    if (ch == "(") {
      state._indent.push("(");
      // add virtual angel wings so that editor behaves...
      // ...more sane incase of broken brackets
      state._indent.push("{");
      return null;
    }

    if (ch === "{") {
      state._indent.push("{");
      return null;
    }

    if (ch == ")")  {
      state._indent.pop();
      state._indent.pop();
    }

    if (ch === "}") {
      state._indent.pop();
      return null;
    }

    if (ch == ",")
      return null;

    if (ch == ";")
      return null;


    if (/[{}\(\),;]/.test(ch))
      return null;

    // 1*DIGIT "K" / "M" / "G"
    if (/\d/.test(ch)) {
      stream.eatWhile(/[\d]/);
      stream.eat(/[KkMmGg]/);
      return "number";
    }

    // ":" (ALPHA / "_") *(ALPHA / DIGIT / "_")
    if (ch == ":") {
      stream.eatWhile(/[a-zA-Z_]/);
      stream.eatWhile(/[a-zA-Z0-9_]/);

      return "operator";
    }

    stream.eatWhile(/\w/);
    var cur = stream.current();

    // "text:" *(SP / HTAB) (hash-comment / CRLF)
    // *(multiline-literal / multiline-dotstart)
    // "." CRLF
    if ((cur == "text") &amp;&amp; stream.eat(":"))
    {
      state.tokenize = tokenMultiLineString;
      return "string";
    }

    if (keywords.propertyIsEnumerable(cur))
      return "keyword";

    if (atoms.propertyIsEnumerable(cur))
      return "atom";

    return null;
  }

  function tokenMultiLineString(stream, state)
  {
    state._multiLineString = true;
    // the first line is special it may contain a comment
    if (!stream.sol()) {
      stream.eatSpace();

      if (stream.peek() == "#") {
        stream.skipToEnd();
        return "comment";
      }

      stream.skipToEnd();
      return "string";
    }

    if ((stream.next() == ".")  &amp;&amp; (stream.eol()))
    {
      state._multiLineString = false;
      state.tokenize = tokenBase;
    }

    return "string";
  }

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd &amp;&amp; ch == "/") {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return "comment";
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote &amp;&amp; !escaped)
          break;
        escaped = !escaped &amp;&amp; ch == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return "string";
    };
  }

  return {
    startState: function(base) {
      return {tokenize: tokenBase,
              baseIndent: base || 0,
              _indent: []};
    },

    token: function(stream, state) {
      if (stream.eatSpace())
        return null;

      return (state.tokenize || tokenBase)(stream, state);;
    },

    indent: function(state, _textAfter) {
      var length = state._indent.length;
      if (_textAfter &amp;&amp; (_textAfter[0] == "}"))
        length--;

      if (length &lt;0)
        length = 0;

      return length * indentUnit;
    },

    electricChars: "}"
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.slim" id="apidoc.element.codemirror.modes.slim">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>slim
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">slim = function (config) {
  var htmlMode = CodeMirror.getMode(config, {name: "htmlmixed"});
  var rubyMode = CodeMirror.getMode(config, "ruby");
  var modes = { html: htmlMode, ruby: rubyMode };
  var embedded = {
    ruby: "ruby",
    javascript: "javascript",
    css: "text/css",
    sass: "text/x-sass",
    scss: "text/x-scss",
    less: "text/x-less",
    styl: "text/x-styl", // no highlighting so far
    coffee: "coffeescript",
    asciidoc: "text/x-asciidoc",
    markdown: "text/x-markdown",
    textile: "text/x-textile", // no highlighting so far
    creole: "text/x-creole", // no highlighting so far
    wiki: "text/x-wiki", // no highlighting so far
    mediawiki: "text/x-mediawiki", // no highlighting so far
    rdoc: "text/x-rdoc", // no highlighting so far
    builder: "text/x-builder", // no highlighting so far
    nokogiri: "text/x-nokogiri", // no highlighting so far
    erb: "application/x-erb"
  };
  var embeddedRegexp = function(map){
    var arr = [];
    for(var key in map) arr.push(key);
    return new RegExp("^("+arr.join('|')+"):");
  }(embedded);

  var styleMap = {
    "commentLine": "comment",
    "slimSwitch": "operator special",
    "slimTag": "tag",
    "slimId": "attribute def",
    "slimClass": "attribute qualifier",
    "slimAttribute": "attribute",
    "slimSubmode": "keyword special",
    "closeAttributeTag": null,
    "slimDoctype": null,
    "lineContinuation": null
  };
  var closing = {
    "{": "}",
    "[": "]",
    "(": ")"
  };

  var nameStartChar = "_a-zA-Z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001
-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
  var nameChar = nameStartChar + "\\-0-9\xB7\u0300-\u036F\u203F-\u2040";
  var nameRegexp = new RegExp("^[:"+nameStartChar+"](?::["+nameChar+"]|["+nameChar+"]*)");
  var attributeNameRegexp = new RegExp("^[:"+nameStartChar+"][:\\."+nameChar+"]*(?=\\s*=)");
  var wrappedAttributeNameRegexp = new RegExp("^[:"+nameStartChar+"][:\\."+nameChar+"]*");
  var classNameRegexp = /^\.-?[_a-zA-Z]+[\w\-]*/;
  var classIdRegexp = /^#[_a-zA-Z]+[\w\-]*/;

  function backup(pos, tokenize, style) {
    var restore = function(stream, state) {
      state.tokenize = tokenize;
      if (stream.pos &lt; pos) {
        stream.pos = pos;
        return style;
      }
      return state.tokenize(stream, state);
    };
    return function(stream, state) {
      state.tokenize = restore;
      return tokenize(stream, state);
    };
  }

  function maybeBackup(stream, state, pat, offset, style) {
    var cur = stream.current();
    var idx = cur.search(pat);
    if (idx &gt; -1) {
      state.tokenize = backup(stream.pos, state.tokenize, style);
      stream.backUp(cur.length - idx - offset);
    }
    return style;
  }

  function continueLine(state, column) {
    state.stack = {
      parent: state.stack,
      style: "continuation",
      indented: column,
      tokenize: state.line
    };
    state.line = state.tokenize;
  }
  function finishContinue(state) {
    if (state.line == state.tokenize) {
      state.line = state.stack.tokenize;
      state.stack = state.stack.parent;
    }
  }

  function lineContinuable(column, tokenize) {
    return function(stream, state) {
      finishContinue(state);
      if (stream.match(/^\\$/)) {
        continueLine(state, column);
        return "lineContinuation";
      }
      var style = tokenize(stream, state);
      if (stream.eol() &amp;&amp; stream.current().match(/(?:^|[^\\])(?:\\\\)*\\$/)) {
        stream.backUp(1);
      }
      return style;
    };
  }
  function commaContinuable(column, tokenize) {
    return function(stream, state) {
      finishContinue(state);
      var style = tokenize(stream, state);
      if (stream.eol() &amp;&amp; stream.current().match(/,$/)) {
        continueLine(state, column);
      }
      return style;
    };
  }

  function rubyInQuote(endQuote, tokenize) {
    // TODO: add multi line support
    return function(stream, state) {
      var ch = stream.peek();
      if (ch == endQuote &amp;&amp; state.rubyState.tokenize.length == 1) {
        // step out of ruby context ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.smalltalk" id="apidoc.element.codemirror.modes.smalltalk">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>smalltalk
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">smalltalk = function (config) {

  var specialChars = /[+\-\/\\*~&lt;&gt;=@%|&amp;?!.,:;^]/;
  var keywords = /true|false|nil|self|super|thisContext/;

  var Context = function(tokenizer, parent) {
    this.next = tokenizer;
    this.parent = parent;
  };

  var Token = function(name, context, eos) {
    this.name = name;
    this.context = context;
    this.eos = eos;
  };

  var State = function() {
    this.context = new Context(next, null);
    this.expectVariable = true;
    this.indentation = 0;
    this.userIndentationDelta = 0;
  };

  State.prototype.userIndent = function(indentation) {
    this.userIndentationDelta = indentation &gt; 0 ? (indentation / config.indentUnit - this.indentation) : 0;
  };

  var next = function(stream, context, state) {
    var token = new Token(null, context, false);
    var aChar = stream.next();

    if (aChar === '"') {
      token = nextComment(stream, new Context(nextComment, context));

    } else if (aChar === '\'') {
      token = nextString(stream, new Context(nextString, context));

    } else if (aChar === '#') {
      if (stream.peek() === '\'') {
        stream.next();
        token = nextSymbol(stream, new Context(nextSymbol, context));
      } else {
        if (stream.eatWhile(/[^\s.{}\[\]()]/))
          token.name = 'string-2';
        else
          token.name = 'meta';
      }

    } else if (aChar === '$') {
      if (stream.next() === '&lt;') {
        stream.eatWhile(/[^\s&gt;]/);
        stream.next();
      }
      token.name = 'string-2';

    } else if (aChar === '|' &amp;&amp; state.expectVariable) {
      token.context = new Context(nextTemporaries, context);

    } else if (/[\[\]{}()]/.test(aChar)) {
      token.name = 'bracket';
      token.eos = /[\[{(]/.test(aChar);

      if (aChar === '[') {
        state.indentation++;
      } else if (aChar === ']') {
        state.indentation = Math.max(0, state.indentation - 1);
      }

    } else if (specialChars.test(aChar)) {
      stream.eatWhile(specialChars);
      token.name = 'operator';
      token.eos = aChar !== ';'; // ; cascaded message expression

    } else if (/\d/.test(aChar)) {
      stream.eatWhile(/[\w\d]/);
      token.name = 'number';

    } else if (/[\w_]/.test(aChar)) {
      stream.eatWhile(/[\w\d_]/);
      token.name = state.expectVariable ? (keywords.test(stream.current()) ? 'keyword' : 'variable') : null;

    } else {
      token.eos = state.expectVariable;
    }

    return token;
  };

  var nextComment = function(stream, context) {
    stream.eatWhile(/[^"]/);
    return new Token('comment', stream.eat('"') ? context.parent : context, true);
  };

  var nextString = function(stream, context) {
    stream.eatWhile(/[^']/);
    return new Token('string', stream.eat('\'') ? context.parent : context, false);
  };

  var nextSymbol = function(stream, context) {
    stream.eatWhile(/[^']/);
    return new Token('string-2', stream.eat('\'') ? context.parent : context, false);
  };

  var nextTemporaries = function(stream, context) {
    var token = new Token(null, context, false);
    var aChar = stream.next();

    if (aChar === '|') {
      token.context = context.parent;
      token.eos = true;

    } else {
      stream.eatWhile(/[^|]/);
      token.name = 'variable';
    }

    return token;
  };

  return {
    startState: function() {
      return new State;
    },

    token: function(stream, state) {
      state.userIndent(stream.indentation());

      if (stream.eatSpace()) {
        return null;
      }

      var token = state.context.next(stream, state.context, state);
      state.context = token.context;
      state.expectVariable = token.eos;

      return token.name;
    },

    blankLine: function(state) {
      state.userIndent(0);
    },

    indent: function(state, textAfter) {
      var i = state.context.next === next &amp;&amp; textAfter &amp;&amp; textAfter.charAt(0) === ']' ? -1 : state.userIndentationDelta;
      return (state.indentation + i) * config.indentUnit;
    },

    electricChars: ']'
  };

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.smarty" id="apidoc.element.codemirror.modes.smarty">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>smarty
        <span class="apidocSignatureSpan">(config, parserConf)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">smarty = function (config, parserConf) {
  var rightDelimiter = parserConf.rightDelimiter || "}";
  var leftDelimiter = parserConf.leftDelimiter || "{";
  var version = parserConf.version || 2;
  var baseMode = CodeMirror.getMode(config, parserConf.baseMode || "null");

  var keyFunctions = ["debug", "extends", "function", "include", "literal"];
  var regs = {
    operatorChars: /[+\-*&amp;%=&lt;&gt;!?]/,
    validIdentifier: /[a-zA-Z0-9_]/,
    stringChar: /['"]/
  };

  var last;
  function cont(style, lastType) {
    last = lastType;
    return style;
  }

  function chain(stream, state, parser) {
    state.tokenize = parser;
    return parser(stream, state);
  }

  // Smarty 3 allows { and } surrounded by whitespace to NOT slip into Smarty mode
  function doesNotCount(stream, pos) {
    if (pos == null) pos = stream.pos;
    return version === 3 &amp;&amp; leftDelimiter == "{" &amp;&amp;
      (pos == stream.string.length || /\s/.test(stream.string.charAt(pos)));
  }

  function tokenTop(stream, state) {
    var string = stream.string;
    for (var scan = stream.pos;;) {
      var nextMatch = string.indexOf(leftDelimiter, scan);
      scan = nextMatch + leftDelimiter.length;
      if (nextMatch == -1 || !doesNotCount(stream, nextMatch + leftDelimiter.length)) break;
    }
    if (nextMatch == stream.pos) {
      stream.match(leftDelimiter);
      if (stream.eat("*")) {
        return chain(stream, state, tokenBlock("comment", "*" + rightDelimiter));
      } else {
        state.depth++;
        state.tokenize = tokenSmarty;
        last = "startTag";
        return "tag";
      }
    }

    if (nextMatch &gt; -1) stream.string = string.slice(0, nextMatch);
    var token = baseMode.token(stream, state.base);
    if (nextMatch &gt; -1) stream.string = string;
    return token;
  }

  // parsing Smarty content
  function tokenSmarty(stream, state) {
    if (stream.match(rightDelimiter, true)) {
      if (version === 3) {
        state.depth--;
        if (state.depth &lt;= 0) {
          state.tokenize = tokenTop;
        }
      } else {
        state.tokenize = tokenTop;
      }
      return cont("tag", null);
    }

    if (stream.match(leftDelimiter, true)) {
      state.depth++;
      return cont("tag", "startTag");
    }

    var ch = stream.next();
    if (ch == "$") {
      stream.eatWhile(regs.validIdentifier);
      return cont("variable-2", "variable");
    } else if (ch == "|") {
      return cont("operator", "pipe");
    } else if (ch == ".") {
      return cont("operator", "property");
    } else if (regs.stringChar.test(ch)) {
      state.tokenize = tokenAttribute(ch);
      return cont("string", "string");
    } else if (regs.operatorChars.test(ch)) {
      stream.eatWhile(regs.operatorChars);
      return cont("operator", "operator");
    } else if (ch == "[" || ch == "]") {
      return cont("bracket", "bracket");
    } else if (ch == "(" || ch == ")") {
      return cont("bracket", "operator");
    } else if (/\d/.test(ch)) {
      stream.eatWhile(/\d/);
      return cont("number", "number");
    } else {

      if (state.last == "variable") {
        if (ch == "@") {
          stream.eatWhile(regs.validIdentifier);
          return cont("property", "property");
        } else if (ch == "|") {
          stream.eatWhile(regs.validIdentifier);
          return cont("qualifier", "modifier");
        }
      } else if (state.last == "pipe") {
        stream.eatWhile(regs.validIdentifier);
        return cont("qualifier", "modifier");
      } else if (state.last == "whitespace") {
        stream.eatWhile(regs.validIdentifier);
        return cont("attribute", "modifier");
      } if (state.last == "property") {
        stream.eatWhile(regs.validIdentifier);
        return cont("property", null);
      } else if (/\s/.test(ch)) {
        last = "whitespace";
        return null;
      }

      var str = "";
      if (ch != "/") {
        str += ch;
      }
      var c = null;
      while (c = stream.eat(regs.validIdentifier)) {
        str += c;
      }
      for (var i=0, j=keyFunctions.length; i&lt;j; i++) {
        if (keyFunctions[i] == str) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.solr" id="apidoc.element.codemirror.modes.solr">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>solr
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">solr = function () {
  "use strict";

  var isStringChar = /[^\s\|\!\+\-\*\?\~\^\&amp;\:\(\)\[\]\{\}\^\"\\]/;
  var isOperatorChar = /[\|\!\+\-\*\?\~\^\&amp;]/;
  var isOperatorString = /^(OR|AND|NOT|TO)$/i;

  function isNumber(word) {
    return parseFloat(word, 10).toString() === word;
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      while ((next = stream.next()) != null) {
        if (next == quote &amp;&amp; !escaped) break;
        escaped = !escaped &amp;&amp; next == "\\";
      }

      if (!escaped) state.tokenize = tokenBase;
      return "string";
    };
  }

  function tokenOperator(operator) {
    return function(stream, state) {
      var style = "operator";
      if (operator == "+")
        style += " positive";
      else if (operator == "-")
        style += " negative";
      else if (operator == "|")
        stream.eat(/\|/);
      else if (operator == "&amp;")
        stream.eat(/\&amp;/);
      else if (operator == "^")
        style += " boost";

      state.tokenize = tokenBase;
      return style;
    };
  }

  function tokenWord(ch) {
    return function(stream, state) {
      var word = ch;
      while ((ch = stream.peek()) &amp;&amp; ch.match(isStringChar) != null) {
        word += stream.next();
      }

      state.tokenize = tokenBase;
      if (isOperatorString.test(word))
        return "operator";
      else if (isNumber(word))
        return "number";
      else if (stream.peek() == ":")
        return "field";
      else
        return "string";
    };
  }

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"')
      state.tokenize = tokenString(ch);
    else if (isOperatorChar.test(ch))
      state.tokenize = tokenOperator(ch);
    else if (isStringChar.test(ch))
      state.tokenize = tokenWord(ch);

    return (state.tokenize != tokenBase) ? state.tokenize(stream, state) : null;
  }

  return {
    startState: function() {
      return {
        tokenize: tokenBase
      };
    },

    token: function(stream, state) {
      if (stream.eatSpace()) return null;
      return state.tokenize(stream, state);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.soy" id="apidoc.element.codemirror.modes.soy">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>soy
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">soy = function (config) {
  var textMode = CodeMirror.getMode(config, "text/plain");
  var modes = {
    html: CodeMirror.getMode(config, {name: "text/html", multilineTagIndentFactor: 2, multilineTagIndentPastTag: false}),
    attributes: textMode,
    text: textMode,
    uri: textMode,
    css: CodeMirror.getMode(config, "text/css"),
    js: CodeMirror.getMode(config, {name: "text/javascript", statementIndent: 2 * config.indentUnit})
  };

  function last(array) {
    return array[array.length - 1];
  }

  function tokenUntil(stream, state, untilRegExp) {
    if (stream.sol()) {
      for (var indent = 0; indent &lt; state.indent; indent++) {
        if (!stream.eat(/\s/)) break;
      }
      if (indent) return null;
    }
    var oldString = stream.string;
    var match = untilRegExp.exec(oldString.substr(stream.pos));
    if (match) {
      // We don't use backUp because it backs up just the position, not the state.
      // This uses an undocumented API.
      stream.string = oldString.substr(0, stream.pos + match.index);
    }
    var result = stream.hideFirstChars(state.indent, function() {
      var localState = last(state.localStates);
      return localState.mode.token(stream, localState.state);
    });
    stream.string = oldString;
    return result;
  }

  function contains(list, element) {
    while (list) {
      if (list.element === element) return true;
      list = list.next;
    }
    return false;
  }

  function prepend(list, element) {
    return {
      element: element,
      next: list
    };
  }

  // Reference a variable `name` in `list`.
  // Let `loose` be truthy to ignore missing identifiers.
  function ref(list, name, loose) {
    return contains(list, name) ? "variable-2" : (loose ? "variable" : "variable-2 error");
  }

  function popscope(state) {
    if (state.scopes) {
      state.variables = state.scopes.element;
      state.scopes = state.scopes.next;
    }
  }

  return {
    startState: function() {
      return {
        kind: [],
        kindTag: [],
        soyState: [],
        templates: null,
        variables: null,
        scopes: null,
        indent: 0,
        localStates: [{
          mode: modes.html,
          state: CodeMirror.startState(modes.html)
        }]
      };
    },

    copyState: function(state) {
      return {
        tag: state.tag, // Last seen Soy tag.
        kind: state.kind.concat([]), // Values of kind="" attributes.
        kindTag: state.kindTag.concat([]), // Opened tags with kind="" attributes.
        soyState: state.soyState.concat([]),
        templates: state.templates,
        variables: state.variables,
        scopes: state.scopes,
        indent: state.indent, // Indentation of the following line.
        localStates: state.localStates.map(function(localState) {
          return {
            mode: localState.mode,
            state: CodeMirror.copyState(localState.mode, localState.state)
          };
        })
      };
    },

    token: function(stream, state) {
      var match;

      switch (last(state.soyState)) {
        case "comment":
          if (stream.match(/^.*?\*\//)) {
            state.soyState.pop();
          } else {
            stream.skipToEnd();
          }
          return "comment";

        case "templ-def":
          if (match = stream.match(/^\.?([\w]+(?!\.[\w]+)*)/)) {
            state.templates = prepend(state.templates, match[1]);
            state.scopes = prepend(state.scopes, state.variables);
            state.soyState.pop();
            return "def";
          }
          stream.next();
          return null;

        case "templ-ref":
          if (match = stream.match(/^\.?([\w]+)/)) {
            state.soyState.pop();
            // If the first character is '.', try to match against a local template name.
            if (match[0][0] == '.') {
              return ref(state.templates, match[1], true);
            }
            // Otherwise
            return "variable";
          }
          stream.next();
          return null;

        case "param-def":
          if (match = stream.match(/^\w+/)) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.sparql" id="apidoc.element.codemirror.modes.sparql">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>sparql
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sparql = function (config) {
  var indentUnit = config.indentUnit;
  var curPunc;

  function wordRegexp(words) {
    return new RegExp("^(?:" + words.join("|") + ")$", "i");
  }
  var ops = wordRegexp(["str", "lang", "langmatches", "datatype", "bound", "sameterm", "isiri", "isuri",
                        "iri", "uri", "bnode", "count", "sum", "min", "max", "avg", "sample",
                        "group_concat", "rand", "abs", "ceil", "floor", "round", "concat", "substr", "strlen",
                        "replace", "ucase", "lcase", "encode_for_uri", "contains", "strstarts", "strends",
                        "strbefore", "strafter", "year", "month", "day", "hours", "minutes", "seconds",
                        "timezone", "tz", "now", "uuid", "struuid", "md5", "sha1", "sha256", "sha384",
                        "sha512", "coalesce", "if", "strlang", "strdt", "isnumeric", "regex", "exists",
                        "isblank", "isliteral", "a", "bind"]);
  var keywords = wordRegexp(["base", "prefix", "select", "distinct", "reduced", "construct", "describe",
                             "ask", "from", "named", "where", "order", "limit", "offset", "filter", "optional",
                             "graph", "by", "asc", "desc", "as", "having", "undef", "values", "group",
                             "minus", "in", "not", "service", "silent", "using", "insert", "delete", "union",
                             "true", "false", "with",
                             "data", "copy", "to", "move", "add", "create", "drop", "clear", "load"]);
  var operatorChars = /[*+\-&lt;&gt;=&amp;|\^\/!\?]/;

  function tokenBase(stream, state) {
    var ch = stream.next();
    curPunc = null;
    if (ch == "$" || ch == "?") {
      if(ch == "?" &amp;&amp; stream.match(/\s/, false)){
        return "operator";
      }
      stream.match(/^[\w\d]*/);
      return "variable-2";
    }
    else if (ch == "&lt;" &amp;&amp; !stream.match(/^[\s\u00a0=]/, false)) {
      stream.match(/^[^\s\u00a0&gt;]*&gt;?/);
      return "atom";
    }
    else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenLiteral(ch);
      return state.tokenize(stream, state);
    }
    else if (/[{}\(\),\.;\[\]]/.test(ch)) {
      curPunc = ch;
      return "bracket";
    }
    else if (ch == "#") {
      stream.skipToEnd();
      return "comment";
    }
    else if (operatorChars.test(ch)) {
      stream.eatWhile(operatorChars);
      return "operator";
    }
    else if (ch == ":") {
      stream.eatWhile(/[\w\d\._\-]/);
      return "atom";
    }
    else if (ch == "@") {
      stream.eatWhile(/[a-z\d\-]/i);
      return "meta";
    }
    else {
      stream.eatWhile(/[_\w\d]/);
      if (stream.eat(":")) {
        stream.eatWhile(/[\w\d_\-]/);
        return "atom";
      }
      var word = stream.current();
      if (ops.test(word))
        return "builtin";
      else if (keywords.test(word))
        return "keyword";
      else
        return "variable";
    }
  }

  function tokenLiteral(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote &amp;&amp; !escaped) {
          state.tokenize = tokenBase;
          break;
        }
        escaped = !escaped &amp;&amp; ch == "\\";
      }
      return "string";
    };
  }

  function pushContext(state, type, col) {
    state.context = {prev: state.context, indent: state.indent, col: col, type: type};
  }
  function popContext(state) {
    state.indent = state.context.indent;
    state.context = state.context.prev;
  }

  return {
    startState: function() {
      return {tokenize: tokenBase,
              context: null,
              indent: 0,
              col: 0};
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (state.context &amp;&amp; state.context.align == null) state.context.align = false;
        state.indent = stream.indentation();
      }
      if (stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);

      if (style != "comment" &amp;&amp; state.context &amp;&amp; state.context.align == null &amp;&amp; state.context.type != "pattern") { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.spreadsheet" id="apidoc.element.codemirror.modes.spreadsheet">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>spreadsheet
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadsheet = function () {
  return {
    startState: function () {
      return {
        stringType: null,
        stack: []
      };
    },
    token: function (stream, state) {
      if (!stream) return;

      //check for state changes
      if (state.stack.length === 0) {
        //strings
        if ((stream.peek() == '"') || (stream.peek() == "'")) {
          state.stringType = stream.peek();
          stream.next(); // Skip quote
          state.stack.unshift("string");
        }
      }

      //return state
      //stack has
      switch (state.stack[0]) {
      case "string":
        while (state.stack[0] === "string" &amp;&amp; !stream.eol()) {
          if (stream.peek() === state.stringType) {
            stream.next(); // Skip quote
            state.stack.shift(); // Clear flag
          } else if (stream.peek() === "\\") {
            stream.next();
            stream.next();
          } else {
            stream.match(/^.[^\\\"\']*/);
          }
        }
        return "string";

      case "characterClass":
        while (state.stack[0] === "characterClass" &amp;&amp; !stream.eol()) {
          if (!(stream.match(/^[^\]\\]+/) || stream.match(/^\\./)))
            state.stack.shift();
        }
        return "operator";
      }

      var peek = stream.peek();

      //no stack
      switch (peek) {
      case "[":
        stream.next();
        state.stack.unshift("characterClass");
        return "bracket";
      case ":":
        stream.next();
        return "operator";
      case "\\":
        if (stream.match(/\\[a-z]+/)) return "string-2";
        else {
          stream.next();
          return "atom";
        }
      case ".":
      case ",":
      case ";":
      case "*":
      case "-":
      case "+":
      case "^":
      case "&lt;":
      case "/":
      case "=":
        stream.next();
        return "atom";
      case "$":
        stream.next();
        return "builtin";
      }

      if (stream.match(/\d+/)) {
        if (stream.match(/^\w+/)) return "error";
        return "number";
      } else if (stream.match(/^[a-zA-Z_]\w*/)) {
        if (stream.match(/(?=[\(.])/, false)) return "keyword";
        return "variable-2";
      } else if (["[", "]", "(", ")", "{", "}"].indexOf(peek) != -1) {
        stream.next();
        return "bracket";
      } else if (!stream.eatSpace()) {
        stream.next();
      }
      return null;
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.sql" id="apidoc.element.codemirror.modes.sql">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>sql
        <span class="apidocSignatureSpan">(config, parserConfig)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sql = function (config, parserConfig) {
  "use strict";

  var client         = parserConfig.client || {},
      atoms          = parserConfig.atoms || {"false": true, "true": true, "null": true},
      builtin        = parserConfig.builtin || {},
      keywords       = parserConfig.keywords || {},
      operatorChars  = parserConfig.operatorChars || /^[*+\-%&lt;&gt;!=&amp;|~^]/,
      support        = parserConfig.support || {},
      hooks          = parserConfig.hooks || {},
      dateSQL        = parserConfig.dateSQL || {"date" : true, "time" : true, "timestamp" : true};

  function tokenBase(stream, state) {
    var ch = stream.next();

    // call hooks from the mime type
    if (hooks[ch]) {
      var result = hooks[ch](stream, state);
      if (result !== false) return result;
    }

    if (support.hexNumber &amp;&amp;
      ((ch == "0" &amp;&amp; stream.match(/^[xX][0-9a-fA-F]+/))
      || (ch == "x" || ch == "X") &amp;&amp; stream.match(/^'[0-9a-fA-F]+'/))) {
      // hex
      // ref: http://dev.mysql.com/doc/refman/5.5/en/hexadecimal-literals.html
      return "number";
    } else if (support.binaryNumber &amp;&amp;
      (((ch == "b" || ch == "B") &amp;&amp; stream.match(/^'[01]+'/))
      || (ch == "0" &amp;&amp; stream.match(/^b[01]+/)))) {
      // bitstring
      // ref: http://dev.mysql.com/doc/refman/5.5/en/bit-field-literals.html
      return "number";
    } else if (ch.charCodeAt(0) &gt; 47 &amp;&amp; ch.charCodeAt(0) &lt; 58) {
      // numbers
      // ref: http://dev.mysql.com/doc/refman/5.5/en/number-literals.html
          stream.match(/^[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/);
      support.decimallessFloat &amp;&amp; stream.eat('.');
      return "number";
    } else if (ch == "?" &amp;&amp; (stream.eatSpace() || stream.eol() || stream.eat(";"))) {
      // placeholders
      return "variable-3";
    } else if (ch == "'" || (ch == '"' &amp;&amp; support.doubleQuote)) {
      // strings
      // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html
      state.tokenize = tokenLiteral(ch);
      return state.tokenize(stream, state);
    } else if ((((support.nCharCast &amp;&amp; (ch == "n" || ch == "N"))
        || (support.charsetCast &amp;&amp; ch == "_" &amp;&amp; stream.match(/[a-z][a-z0-9]*/i)))
        &amp;&amp; (stream.peek() == "'" || stream.peek() == '"'))) {
      // charset casting: _utf8'str', N'str', n'str'
      // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html
      return "keyword";
    } else if (/^[\(\),\;\[\]]/.test(ch)) {
      // no highlighting
      return null;
    } else if (support.commentSlashSlash &amp;&amp; ch == "/" &amp;&amp; stream.eat("/")) {
      // 1-line comment
      stream.skipToEnd();
      return "comment";
    } else if ((support.commentHash &amp;&amp; ch == "#")
        || (ch == "-" &amp;&amp; stream.eat("-") &amp;&amp; (!support.commentSpaceRequired || stream.eat(" ")))) {
      // 1-line comments
      // ref: https://kb.askmonty.org/en/comment-syntax/
      stream.skipToEnd();
      return "comment";
    } else if (ch == "/" &amp;&amp; stream.eat("*")) {
      // multi-line comments
      // ref: https://kb.askmonty.org/en/comment-syntax/
      state.tokenize = tokenComment;
      return state.tokenize(stream, state);
    } else if (ch == ".") {
      // .1 for 0.1
      if (support.zerolessFloat &amp;&amp; stream.match(/^(?:\d+(?:e[+-]?\d+)?)/i)) {
        return "number";
      }
      // .table_name (ODBC)
      // // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html
      if (support.ODBCdotTable &amp;&amp; stream.match(/^[a-zA-Z_]+/)) {
        return "variable-2";
      }
    } else if (operatorChars.test(ch)) {
      // operators
      stream.eatWhile(operatorChars);
      return null;
    } else if (ch == '{' &amp;&amp;
        (stream.match(/^( )*(d|D|t|T|ts|TS)( )*'[^']*'( )*}/) || stream.match(/^( )*(d|D|t|T|ts|TS)( )*"[^"]*"( )*}/))) {
      // dates (weird ODBC syntax)
      // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html
      return "number";
    } else {
      stream.eatWhile(/^[_\w\d]/);
      var word = stream.current().toLowerCase();
      // dates (standard SQL syntax)
      // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html
      if ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.stex" id="apidoc.element.codemirror.modes.stex">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>stex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stex = function () {
  "use strict";

  function pushCommand(state, command) {
    state.cmdState.push(command);
  }

  function peekCommand(state) {
    if (state.cmdState.length &gt; 0) {
      return state.cmdState[state.cmdState.length - 1];
    } else {
      return null;
    }
  }

  function popCommand(state) {
    var plug = state.cmdState.pop();
    if (plug) {
      plug.closeBracket();
    }
  }

  // returns the non-default plugin closest to the end of the list
  function getMostPowerful(state) {
    var context = state.cmdState;
    for (var i = context.length - 1; i &gt;= 0; i--) {
      var plug = context[i];
      if (plug.name == "DEFAULT") {
        continue;
      }
      return plug;
    }
    return { styleIdentifier: function() { return null; } };
  }

  function addPluginPattern(pluginName, cmdStyle, styles) {
    return function () {
      this.name = pluginName;
      this.bracketNo = 0;
      this.style = cmdStyle;
      this.styles = styles;
      this.argument = null;   // \begin and \end have arguments that follow. These are stored in the plugin

      this.styleIdentifier = function() {
        return this.styles[this.bracketNo - 1] || null;
      };
      this.openBracket = function() {
        this.bracketNo++;
        return "bracket";
      };
      this.closeBracket = function() {};
    };
  }

  var plugins = {};

  plugins["importmodule"] = addPluginPattern("importmodule", "tag", ["string", "builtin"]);
  plugins["documentclass"] = addPluginPattern("documentclass", "tag", ["", "atom"]);
  plugins["usepackage"] = addPluginPattern("usepackage", "tag", ["atom"]);
  plugins["begin"] = addPluginPattern("begin", "tag", ["atom"]);
  plugins["end"] = addPluginPattern("end", "tag", ["atom"]);

  plugins["DEFAULT"] = function () {
    this.name = "DEFAULT";
    this.style = "tag";

    this.styleIdentifier = this.openBracket = this.closeBracket = function() {};
  };

  function setState(state, f) {
    state.f = f;
  }

  // called when in a normal (no environment) context
  function normal(source, state) {
    var plug;
    // Do we look like '\command' ?  If so, attempt to apply the plugin 'command'
    if (source.match(/^\\[a-zA-Z@]+/)) {
      var cmdName = source.current().slice(1);
      plug = plugins[cmdName] || plugins["DEFAULT"];
      plug = new plug();
      pushCommand(state, plug);
      setState(state, beginParams);
      return plug.style;
    }

    // escape characters
    if (source.match(/^\\[$&amp;%#{}_]/)) {
      return "tag";
    }

    // white space control characters
    if (source.match(/^\\[,;!\/\\]/)) {
      return "tag";
    }

    // find if we're starting various math modes
    if (source.match("\\[")) {
      setState(state, function(source, state){ return inMathMode(source, state, "\\]"); });
      return "keyword";
    }
    if (source.match("$$")) {
      setState(state, function(source, state){ return inMathMode(source, state, "$$"); });
      return "keyword";
    }
    if (source.match("$")) {
      setState(state, function(source, state){ return inMathMode(source, state, "$"); });
      return "keyword";
    }

    var ch = source.next();
    if (ch == "%") {
      source.skipToEnd();
      return "comment";
    } else if (ch == '}' || ch == ']') {
      plug = peekCommand(state);
      if (plug) {
        plug.closeBracket(ch);
        setState(state, beginParams);
      } else {
        return "error";
      }
      return "bracket";
    } else if (ch == '{' || ch == '[') {
      plug = plugins["DEFAULT"];
      plug = new plug();
      pushCommand(state, plug);
      return "bracket";
    } else if (/\d/.test(ch)) {
      source.eatWhile(/[\w.%]/);
      return "atom";
    } else {
      source.eatWhile(/[\w\-_]/);
      plug = getMostPowerful(state);
      if (plug.name == 'begin') {
        plug.argument = source.current();
      }
      return plug.styleIdentifier();
    }
  }

  function inMathMode(source, state, endModeSeq) {
    if (source.eatSpace()) {
      return null;
    }
    if (source.match(endModeSeq)) {
      setState(state, normal);
      return "key ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.stylus" id="apidoc.element.codemirror.modes.stylus">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>stylus
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stylus = function (config) {
  var indentUnit = config.indentUnit,
      tagKeywords = keySet(tagKeywords_),
      tagVariablesRegexp = /^(a|b|i|s|col|em)$/i,
      propertyKeywords = keySet(propertyKeywords_),
      nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_),
      valueKeywords = keySet(valueKeywords_),
      colorKeywords = keySet(colorKeywords_),
      documentTypes = keySet(documentTypes_),
      documentTypesRegexp = wordRegexp(documentTypes_),
      mediaFeatures = keySet(mediaFeatures_),
      mediaTypes = keySet(mediaTypes_),
      fontProperties = keySet(fontProperties_),
      operatorsRegexp = /^\s*([.]{2,3}|&amp;&amp;|\|\||\*\*|[?!=:]?=|[-+*\/%&lt;&gt;]=?|\?:|\~)/,
      wordOperatorKeywordsRegexp = wordRegexp(wordOperatorKeywords_),
      blockKeywords = keySet(blockKeywords_),
      vendorPrefixesRegexp = new RegExp(/^\-(moz|ms|o|webkit)-/i),
      commonAtoms = keySet(commonAtoms_),
      firstWordMatch = "",
      states = {},
      ch,
      style,
      type,
      override;

<span class="apidocCodeCommentSpan">  /**
   * Tokenizers
   */
</span>  function tokenBase(stream, state) {
    firstWordMatch = stream.string.match(/(^[\w-]+\s*=\s*$)|(^\s*[\w-]+\s*=\s*[\w-])|(^\s*(\.|#|@|\$|\&amp;|\[|\d|\+|::?|\{|\&gt;|~|\/)?\s*[\w-]*([a-z0-9-]|\*|\/\*)(\(|,)?)/);
    state.context.line.firstWord = firstWordMatch ? firstWordMatch[0].replace(/^\s*/, "") : "";
    state.context.line.indent = stream.indentation();
    ch = stream.peek();

    // Line comment
    if (stream.match("//")) {
      stream.skipToEnd();
      return ["comment", "comment"];
    }
    // Block comment
    if (stream.match("/*")) {
      state.tokenize = tokenCComment;
      return tokenCComment(stream, state);
    }
    // String
    if (ch == "\"" || ch == "'") {
      stream.next();
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    }
    // Def
    if (ch == "@") {
      stream.next();
      stream.eatWhile(/[\w\\-]/);
      return ["def", stream.current()];
    }
    // ID selector or Hex color
    if (ch == "#") {
      stream.next();
      // Hex color
      if (stream.match(/^[0-9a-f]{6}|[0-9a-f]{3}/i)) {
        return ["atom", "atom"];
      }
      // ID selector
      if (stream.match(/^[a-z][\w-]*/i)) {
        return ["builtin", "hash"];
      }
    }
    // Vendor prefixes
    if (stream.match(vendorPrefixesRegexp)) {
      return ["meta", "vendor-prefixes"];
    }
    // Numbers
    if (stream.match(/^-?[0-9]?\.?[0-9]/)) {
      stream.eatWhile(/[a-z%]/i);
      return ["number", "unit"];
    }
    // !important|optional
    if (ch == "!") {
      stream.next();
      return [stream.match(/^(important|optional)/i) ? "keyword": "operator", "important"];
    }
    // Class
    if (ch == "." &amp;&amp; stream.match(/^\.[a-z][\w-]*/i)) {
      return ["qualifier", "qualifier"];
    }
    // url url-prefix domain regexp
    if (stream.match(documentTypesRegexp)) {
      if (stream.peek() == "(") state.tokenize = tokenParenthesized;
      return ["property", "word"];
    }
    // Mixins / Functions
    if (stream.match(/^[a-z][\w-]*\(/i)) {
      stream.backUp(1);
      return ["keyword", "mixin"];
    }
    // Block mixins
    if (stream.match(/^(\+|-)[a-z][\w-]*\(/i)) {
      stream.backUp(1);
      return ["keyword", "block-mixin"];
    }
    // Parent Reference BEM naming
    if (stream.string.match(/^\s*&amp;/) &amp;&amp; stream.match(/^[-_]+[a-z][\w-]*/)) {
      return ["qualifier", "qualifier"];
    }
    // / Root Reference &amp; Parent Reference
    if (stream.match(/^(\/|&amp;)(-|_|:|\.|#|[a-z])/)) {
      stream.backUp(1);
      return ["variable-3", "reference"];
    }
    if (stream.match(/^&amp;{1}\s*$/)) {
      return ["variable-3", "reference"];
    }
    // Word operator
    if (stream.match(wordOperatorKeywordsRegexp)) {
      return ["operator", "operator"];
    }
    // Word
    if (stream.match(/^\$?[-_]*[a-z0-9]+[\w-]*/i)) {
      // Variable
      if (stream.match(/^(\.|\[)[\w-\'\"\]]+/i, false)) {
        if (!wordIsTag(stream.current())) {
          stream.match(/\./);
          return ["variable-2", "variable-name"];
        }
      }
      retur ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.swift" id="apidoc.element.codemirror.modes.swift">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>swift
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swift = function (config) {
  return {
    startState: function() {
      return {
        prev: null,
        context: null,
        indented: 0,
        tokenize: []
      }
    },

    token: function(stream, state) {
      var prev = state.prev
      state.prev = null
      var tokenize = state.tokenize[state.tokenize.length - 1] || tokenBase
      var style = tokenize(stream, state, prev)
      if (!style || style == "comment") state.prev = prev
      else if (!state.prev) state.prev = style

      if (style == "punctuation") {
        var bracket = /[\(\[\{]|([\]\)\}])/.exec(stream.current())
        if (bracket) (bracket[1] ? popContext : pushContext)(state, stream)
      }

      return style
    },

    indent: function(state, textAfter) {
      var cx = state.context
      if (!cx) return 0
      var closing = /^[\]\}\)]/.test(textAfter)
      if (cx.align != null) return cx.align - (closing ? 1 : 0)
      return cx.indented + (closing ? 0 : config.indentUnit)
    },

    electricInput: /^\s*[\)\}\]]$/,

    lineComment: "//",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    fold: "brace",
    closeBrackets: "()[]{}''\"\"``"
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.tcl" id="apidoc.element.codemirror.modes.tcl">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>tcl
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tcl = function () {
  function parseWords(str) {
    var obj = {}, words = str.split(" ");
    for (var i = 0; i &lt; words.length; ++i) obj[words[i]] = true;
    return obj;
  }
  var keywords = parseWords("Tcl safe after append array auto_execok auto_import auto_load " +
        "auto_mkindex auto_mkindex_old auto_qualify auto_reset bgerror " +
        "binary break catch cd close concat continue dde eof encoding error " +
        "eval exec exit expr fblocked fconfigure fcopy file fileevent filename " +
        "filename flush for foreach format gets glob global history http if " +
        "incr info interp join lappend lindex linsert list llength load lrange " +
        "lreplace lsearch lset lsort memory msgcat namespace open package parray " +
        "pid pkg::create pkg_mkIndex proc puts pwd re_syntax read regex regexp " +
        "registry regsub rename resource return scan seek set socket source split " +
        "string subst switch tcl_endOfWord tcl_findLibrary tcl_startOfNextWord " +
        "tcl_wordBreakAfter tcl_startOfPreviousWord tcl_wordBreakBefore tcltest " +
        "tclvars tell time trace unknown unset update uplevel upvar variable " +
    "vwait");
    var functions = parseWords("if elseif else and not or eq ne in ni for foreach while switch");
    var isOperatorChar = /[+\-*&amp;%=&lt;&gt;!?^\/\|]/;
    function chain(stream, state, f) {
      state.tokenize = f;
      return f(stream, state);
    }
    function tokenBase(stream, state) {
      var beforeParams = state.beforeParams;
      state.beforeParams = false;
      var ch = stream.next();
      if ((ch == '"' || ch == "'") &amp;&amp; state.inParams) {
        return chain(stream, state, tokenString(ch));
      } else if (/[\[\]{}\(\),;\.]/.test(ch)) {
        if (ch == "(" &amp;&amp; beforeParams) state.inParams = true;
        else if (ch == ")") state.inParams = false;
          return null;
      } else if (/\d/.test(ch)) {
        stream.eatWhile(/[\w\.]/);
        return "number";
      } else if (ch == "#") {
        if (stream.eat("*"))
          return chain(stream, state, tokenComment);
        if (ch == "#" &amp;&amp; stream.match(/ *\[ *\[/))
          return chain(stream, state, tokenUnparsed);
        stream.skipToEnd();
        return "comment";
      } else if (ch == '"') {
        stream.skipTo(/"/);
        return "comment";
      } else if (ch == "$") {
        stream.eatWhile(/[$_a-z0-9A-Z\.{:]/);
        stream.eatWhile(/}/);
        state.beforeParams = true;
        return "builtin";
      } else if (isOperatorChar.test(ch)) {
        stream.eatWhile(isOperatorChar);
        return "comment";
      } else {
        stream.eatWhile(/[\w\$_{}\xa1-\uffff]/);
        var word = stream.current().toLowerCase();
        if (keywords &amp;&amp; keywords.propertyIsEnumerable(word))
          return "keyword";
        if (functions &amp;&amp; functions.propertyIsEnumerable(word)) {
          state.beforeParams = true;
          return "keyword";
        }
        return null;
      }
    }
    function tokenString(quote) {
      return function(stream, state) {
      var escaped = false, next, end = false;
      while ((next = stream.next()) != null) {
        if (next == quote &amp;&amp; !escaped) {
          end = true;
          break;
        }
        escaped = !escaped &amp;&amp; next == "\\";
      }
      if (end) state.tokenize = tokenBase;
        return "string";
      };
    }
    function tokenComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (ch == "#" &amp;&amp; maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }
        maybeEnd = (ch == "*");
      }
      return "comment";
    }
    function tokenUnparsed(stream, state) {
      var maybeEnd = 0, ch;
      while (ch = stream.next()) {
        if (ch == "#" &amp;&amp; maybeEnd == 2) {
          state.tokenize = tokenBase;
          break;
        }
        if (ch == "]")
          maybeEnd++;
        else if (ch != " ")
          maybeEnd = 0;
      }
      return "meta";
    }
    return {
      startState: function() {
        return {
          tokenize: tokenBase, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.textile" id="apidoc.element.codemirror.modes.textile">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>textile
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">textile = function () {
  return {
    startState: function() {
      return { mode: Modes.newLayout };
    },
    token: function(stream, state) {
      if (stream.sol()) startNewLine(stream, state);
      return state.mode(stream, state);
    },
    blankLine: blankLine
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.modes.xml" id="apidoc.element.codemirror.modes.xml">
        function <span class="apidocSignatureSpan">codemirror.modes.</span>xml
        <span class="apidocSignatureSpan">(editorConf, config_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xml = function (editorConf, config_) {
  var indentUnit = editorConf.indentUnit
  var config = {}
  var defaults = config_.htmlMode ? htmlConfig : xmlConfig
  for (var prop in defaults) config[prop] = defaults[prop]
  for (var prop in config_) config[prop] = config_[prop]

  // Return variables for tokenizers
  var type, setStyle;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == "&lt;") {
      if (stream.eat("!")) {
        if (stream.eat("[")) {
          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]&gt;"));
          else return null;
        } else if (stream.match("--")) {
          return chain(inBlock("comment", "--&gt;"));
        } else if (stream.match("DOCTYPE", true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat("?")) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock("meta", "?&gt;");
        return "meta";
      } else {
        type = stream.eat("/") ? "closeTag" : "openTag";
        state.tokenize = inTag;
        return "tag bracket";
      }
    } else if (ch == "&amp;") {
      var ok;
      if (stream.eat("#")) {
        if (stream.eat("x")) {
          ok = stream.eatWhile(/[a-fA-F\d]/) &amp;&amp; stream.eat(";");
        } else {
          ok = stream.eatWhile(/[\d]/) &amp;&amp; stream.eat(";");
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) &amp;&amp; stream.eat(";");
      }
      return ok ? "atom" : "error";
    } else {
      stream.eatWhile(/[^&amp;&lt;]/);
      return null;
    }
  }
  inText.isInText = true;

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == "&gt;" || (ch == "/" &amp;&amp; stream.eat("&gt;"))) {
      state.tokenize = inText;
      type = ch == "&gt;" ? "endTag" : "selfcloseTag";
      return "tag bracket";
    } else if (ch == "=") {
      type = "equals";
      return null;
    } else if (ch == "&lt;") {
      state.tokenize = inText;
      state.state = baseState;
      state.tagName = state.tagStart = null;
      var next = state.tokenize(stream, state);
      return next ? next + " tag error" : "tag error";
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      state.stringStartCol = stream.column();
      return state.tokenize(stream, state);
    } else {
      stream.match(/^[^\s\u00a0=&lt;&gt;\"\']*[^\s\u00a0=&lt;&gt;\"\'\/]/);
      return "word";
    }
  }

  function inAttribute(quote) {
    var closure = function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return "string";
    };
    closure.isInAttribute = true;
    return closure;
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    };
  }
  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == "&lt;") {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == "&gt;") {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return "meta";
    };
  }

  function Context(state, tagName, startOfLine) {
    this.prev = state.context;
    this.tagName = tagName;
    this.indent = state.indented;
    this.startOfLine = startOfLine;
    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context &amp;&amp; state.context.noIndent))
      this.noIndent = true;
  }
  function popContext(state) {
    if (state.context) state.context = state.context.prev;
  }
  function maybePopContext(state, nextTagName) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  for (var tag in data) if (data.hasOwnProperty(tag) &amp;&amp; data[tag] != s)
    populate(data[tag]);

  CodeMirror.htmlSchema = data;
  function htmlHint(cm, options) {
    var local = {schemaInfo: data};
    if (options) for (var opt in options) local[opt] = options[opt];
    return CodeMirror.hint.<span class="apidocCodeKeywordSpan">xml</span>(cm, local);
  }
  CodeMirror.registerHelper("hint", "html", htmlHint);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.codemirror.runmode" id="apidoc.module.codemirror.runmode">module codemirror.runmode</a></h1>


    <h2>
        <a href="#apidoc.element.codemirror.runmode.MergeView" id="apidoc.element.codemirror.runmode.MergeView">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>MergeView
        <span class="apidocSignatureSpan">(node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MergeView = function (node, options) {
  if (!(this instanceof MergeView)) return new MergeView(node, options);

  this.options = options;
  var origLeft = options.origLeft, origRight = options.origRight == null ? options.orig : options.origRight;

  var hasLeft = origLeft != null, hasRight = origRight != null;
  var panes = 1 + (hasLeft ? 1 : 0) + (hasRight ? 1 : 0);
  var wrap = [], left = this.left = null, right = this.right = null;
  var self = this;

  if (hasLeft) {
    left = this.left = new DiffView(this, "left");
    var leftPane = elt("div", null, "CodeMirror-merge-pane CodeMirror-merge-left");
    wrap.push(leftPane);
    wrap.push(buildGap(left));
  }

  var editPane = elt("div", null, "CodeMirror-merge-pane CodeMirror-merge-editor");
  wrap.push(editPane);

  if (hasRight) {
    right = this.right = new DiffView(this, "right");
    wrap.push(buildGap(right));
    var rightPane = elt("div", null, "CodeMirror-merge-pane CodeMirror-merge-right");
    wrap.push(rightPane);
  }

  (hasRight ? rightPane : editPane).className += " CodeMirror-merge-pane-rightmost";

  wrap.push(elt("div", null, null, "height: 0; clear: both;"));

  var wrapElt = this.wrap = node.appendChild(elt("div", wrap, "CodeMirror-merge CodeMirror-merge-" + panes + "pane"));
  this.edit = CodeMirror(editPane, copyObj(options));

  if (left) left.init(leftPane, origLeft, options);
  if (right) right.init(rightPane, origRight, options);
  if (options.collapseIdentical)
    this.editor().operation(function() {
      collapseIdenticalStretches(self, options.collapseIdentical);
    });
  if (options.connect == "align") {
    this.aligners = [];
    alignChunks(this.left || this.right, true);
  }
  if (left) left.registerEvents(right)
  if (right) right.registerEvents(left)


  var onResize = function() {
    if (left) makeConnections(left);
    if (right) makeConnections(right);
  };
  CodeMirror.on(window, "resize", onResize);
  var resizeInterval = setInterval(function() {
    for (var p = wrapElt.parentNode; p &amp;&amp; p != document.body; p = p.parentNode) {}
    if (!p) { clearInterval(resizeInterval); CodeMirror.off(window, "resize", onResize); }
  }, 5000);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.StringStream" id="apidoc.element.codemirror.runmode.StringStream">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>StringStream
        <span class="apidocSignatureSpan">(string, tabSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StringStream(string, tabSize) {
  this.pos = this.start = 0;
  this.string = string;
  this.tabSize = tabSize || 8;
  this.lastColumnPos = this.lastColumnValue = 0;
  this.lineStart = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return out.join('');
}

// Unescape \ and / in the replace part, for PCRE mode.
var unescapes = {'\\/': '/', '\\\\': '\\', '\\n': '\n', '\\r'
;: '\r', '\\t': '\t'};
function unescapeRegexReplace(str) {
  var stream = new CodeMirror.<span class="apidocCodeKeywordSpan">StringStream</span>(str);
  var output = [];
  while (!stream.eol()) {
    // Search for \.
    while (stream.peek() &amp;&amp; stream.peek() != '\\') {
      output.push(stream.next());
    }
    var matched = false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.TernServer" id="apidoc.element.codemirror.runmode.TernServer">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>TernServer
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TernServer = function (options) {
  var self = this;
  this.options = options || {};
  var plugins = this.options.plugins || (this.options.plugins = {});
  if (!plugins.doc_comment) plugins.doc_comment = true;
  this.docs = Object.create(null);
  if (this.options.useWorker) {
    this.server = new WorkerServer(this);
  } else {
    this.server = new tern.Server({
      getFile: function(name, c) { return getFile(self, name, c); },
      async: true,
      defs: this.options.defs || [],
      plugins: plugins
    });
  }
  this.trackChange = function(doc, change) { trackChange(self, doc, change); };

  this.cachedArgHints = null;
  this.activeArgHints = null;
  this.jumpStack = [];

  this.getHint = function(cm, c) { return hint(self, cm, c); };
  this.getHint.async = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.autoLoadMode" id="apidoc.element.codemirror.runmode.autoLoadMode">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>autoLoadMode
        <span class="apidocSignatureSpan">(instance, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoLoadMode = function (instance, mode) {
  if (!CodeMirror.modes.hasOwnProperty(mode))
    CodeMirror.requireMode(mode, function() {
      instance.setOption("mode", instance.getOption("mode"));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.colorize" id="apidoc.element.codemirror.runmode.colorize">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>colorize
        <span class="apidocSignatureSpan">(collection, defaultMode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">colorize = function (collection, defaultMode) {
  if (!collection) collection = document.body.getElementsByTagName("pre");

  for (var i = 0; i &lt; collection.length; ++i) {
    var node = collection[i];
    var mode = node.getAttribute("data-lang") || defaultMode;
    if (!mode) continue;

    var text = [];
    textContent(node, text);
    node.innerHTML = "";
    CodeMirror.runMode(text.join(""), mode, node);

    node.className += " cm-s-default";
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.defineMIME" id="apidoc.element.codemirror.runmode.defineMIME">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>defineMIME
        <span class="apidocSignatureSpan">(mime, spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineMIME = function (mime, spec) { mimeModes[mime] = spec; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  defineMode.apply(this, arguments);
};

CodeMirror$1.defineMIME = defineMIME;

// Minimal default mode.
CodeMirror$1.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
CodeMirror$1.<span class="apidocCodeKeywordSpan">defineMIME</span>("text/plain", "null");

// EXTENSIONS

CodeMirror$1.defineExtension = function (name, func) {
  CodeMirror$1.prototype[name] = func;
};
CodeMirror$1.defineDocExtension = function (name, func) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.defineMode" id="apidoc.element.codemirror.runmode.defineMode">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>defineMode
        <span class="apidocSignatureSpan">(name, mode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineMode = function (name, mode) {
  if (arguments.length &gt; 2)
    mode.dependencies = Array.prototype.slice.call(arguments, 2);
  modes[name] = mode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!CodeMirror$1.defaults.mode &amp;&amp; name != "null") { CodeMirror$1.defaults.mode = name; }
  defineMode.apply(this, arguments);
};

CodeMirror$1.defineMIME = defineMIME;

// Minimal default mode.
CodeMirror$1.<span class="apidocCodeKeywordSpan">defineMode</span>("null", function () { return ({token: function (stream
) { return stream.skipToEnd(); }}); });
CodeMirror$1.defineMIME("text/plain", "null");

// EXTENSIONS

CodeMirror$1.defineExtension = function (name, func) {
  CodeMirror$1.prototype[name] = func;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.defineSimpleMode" id="apidoc.element.codemirror.runmode.defineSimpleMode">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>defineSimpleMode
        <span class="apidocSignatureSpan">(name, states)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineSimpleMode = function (name, states) {
  CodeMirror.defineMode(name, function(config) {
    return CodeMirror.simpleMode(config, states);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.extendMode" id="apidoc.element.codemirror.runmode.extendMode">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>extendMode
        <span class="apidocSignatureSpan">(mode, properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendMode = function (mode, properties) {
  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
  copyObj(properties, exts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  define(["../../lib/codemirror"], mod);
else // Plain browser env
  mod(CodeMirror);
})(function(CodeMirror) {
var modes = ["clike", "css", "javascript"];

for (var i = 0; i &lt; modes.length; ++i)
  CodeMirror.<span class="apidocCodeKeywordSpan">extendMode</span>(modes[i], {blockCommentContinue: " * "});

function continueComment(cm) {
  if (cm.getOption("disableInput")) return CodeMirror.Pass;
  var ranges = cm.listSelections(), mode, inserts = [];
  for (var i = 0; i &lt; ranges.length; i++) {
    var pos = ranges[i].head, token = cm.getTokenAt(pos);
    if (token.type != "comment") return CodeMirror.Pass;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.findEnclosingTag" id="apidoc.element.codemirror.runmode.findEnclosingTag">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>findEnclosingTag
        <span class="apidocSignatureSpan">(cm, pos, range, tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findEnclosingTag = function (cm, pos, range, tag) {
  var iter = new Iter(cm, pos.line, pos.ch, range);
  for (;;) {
    var open = findMatchingOpen(iter, tag);
    if (!open) break;
    var forward = new Iter(cm, pos.line, pos.ch, range);
    var close = findMatchingClose(forward, open.tag);
    if (close) return {open: open, close: close};
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.findMatchingTag" id="apidoc.element.codemirror.runmode.findMatchingTag">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>findMatchingTag
        <span class="apidocSignatureSpan">(cm, pos, range)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findMatchingTag = function (cm, pos, range) {
  var iter = new Iter(cm, pos.line, pos.ch, range);
  if (iter.text.indexOf("&gt;") == -1 &amp;&amp; iter.text.indexOf("&lt;") == -1) return;
  var end = toTagEnd(iter), to = end &amp;&amp; Pos(iter.line, iter.ch);
  var start = end &amp;&amp; toTagStart(iter);
  if (!end || !start || cmp(iter, pos) &gt; 0) return;
  var here = {from: Pos(iter.line, iter.ch), to: to, tag: start[2]};
  if (end == "selfClose") return {open: here, close: null, at: "open"};

  if (start[1]) { // closing tag
    return {open: findMatchingOpen(iter, start[2]), close: here, at: "close"};
  } else { // opening tag
    iter = new Iter(cm, to.line, to.ch, range);
    return {open: here, close: findMatchingClose(iter, start[2]), at: "open"};
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  function doMatchTags(cm) {
cm.state.failedTagMatch = false;
cm.operation(function() {
  clear(cm);
  if (cm.somethingSelected()) return;
  var cur = cm.getCursor(), range = cm.getViewport();
  range.from = Math.min(range.from, cur.line); range.to = Math.max(cur.line + 1, range.to);
  var match = CodeMirror.<span class="apidocCodeKeywordSpan">findMatchingTag</span>(cm, cur, range);
  if (!match) return;
  if (cm.state.matchBothTags) {
    var hit = match.at == "open" ? match.open : match.close;
    if (hit) cm.state.tagHit = cm.markText(hit.from, hit.to, {className: "CodeMirror-matchingtag"});
  }
  var other = match.at == "close" ? match.open : match.close;
  if (other)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.findModeByExtension" id="apidoc.element.codemirror.runmode.findModeByExtension">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>findModeByExtension
        <span class="apidocSignatureSpan">(ext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findModeByExtension = function (ext) {
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.ext) for (var j = 0; j &lt; info.ext.length; j++)
      if (info.ext[j] == ext) return info;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
CodeMirror.findModeByFileName = function(filename) {
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.file &amp;&amp; info.file.test(filename)) return info;
  }
  var dot = filename.lastIndexOf(".");
  var ext = dot &gt; -1 &amp;&amp; filename.substring(dot + 1, filename.length);
  if (ext) return CodeMirror.<span class="apidocCodeKeywordSpan">findModeByExtension</span>(ext);
};

CodeMirror.findModeByName = function(name) {
  name = name.toLowerCase();
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.name.toLowerCase() == name) return info;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.findModeByFileName" id="apidoc.element.codemirror.runmode.findModeByFileName">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>findModeByFileName
        <span class="apidocSignatureSpan">(filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findModeByFileName = function (filename) {
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.file &amp;&amp; info.file.test(filename)) return info;
  }
  var dot = filename.lastIndexOf(".");
  var ext = dot &gt; -1 &amp;&amp; filename.substring(dot + 1, filename.length);
  if (ext) return CodeMirror.findModeByExtension(ext);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.findModeByMIME" id="apidoc.element.codemirror.runmode.findModeByMIME">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>findModeByMIME
        <span class="apidocSignatureSpan">(mime)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findModeByMIME = function (mime) {
  mime = mime.toLowerCase();
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.mime == mime) return info;
    if (info.mimes) for (var j = 0; j &lt; info.mimes.length; j++)
      if (info.mimes[j] == mime) return info;
  }
  if (/\+xml$/.test(mime)) return CodeMirror.findModeByMIME("application/xml")
  if (/\+json$/.test(mime)) return CodeMirror.findModeByMIME("application/json")
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  mime = mime.toLowerCase();
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.mime == mime) return info;
    if (info.mimes) for (var j = 0; j &lt; info.mimes.length; j++)
      if (info.mimes[j] == mime) return info;
  }
  if (/\+xml$/.test(mime)) return CodeMirror.<span class="apidocCodeKeywordSpan">findModeByMIME</span>("application/xml"
;)
  if (/\+json$/.test(mime)) return CodeMirror.findModeByMIME("application/json")
};

CodeMirror.findModeByExtension = function(ext) {
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.ext) for (var j = 0; j &lt; info.ext.length; j++)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.findModeByName" id="apidoc.element.codemirror.runmode.findModeByName">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>findModeByName
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findModeByName = function (name) {
  name = name.toLowerCase();
  for (var i = 0; i &lt; CodeMirror.modeInfo.length; i++) {
    var info = CodeMirror.modeInfo[i];
    if (info.name.toLowerCase() == name) return info;
    if (info.alias) for (var j = 0; j &lt; info.alias.length; j++)
      if (info.alias[j].toLowerCase() == name) return info;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.getMode" id="apidoc.element.codemirror.runmode.getMode">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>getMode
        <span class="apidocSignatureSpan">(options, spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getMode = function (options, spec) {
  var spec = exports.resolveMode(spec);
  var mfactory = modes[spec.name];
  if (!mfactory) return exports.getMode(options, "text/plain");
  var modeObj = mfactory(options, spec);
  if (modeExtensions.hasOwnProperty(spec.name)) {
    var exts = modeExtensions[spec.name];
    for (var prop in exts) {
      if (!exts.hasOwnProperty(prop)) continue;
      if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
      modeObj[prop] = exts[prop];
    }
  }
  modeObj.name = spec.name;
  if (spec.helperType) modeObj.helperType = spec.helperType;
  if (spec.modeProps) for (var prop in spec.modeProps)
    modeObj[prop] = spec.modeProps[prop];

  return modeObj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    { if (maps[i] == map$$1 || maps[i].name == map$$1) {
      maps.splice(i, 1);
      return true
    } }
},

addOverlay: methodOp(function(spec, options) {
  var mode = spec.token ? spec : CodeMirror.<span class="apidocCodeKeywordSpan">getMode</span>(this.options, spec);
  if (mode.startState) { throw new Error("Overlays may not be stateful.") }
  insertSorted(this.state.overlays,
               {mode: mode, modeSpec: spec, opaque: options &amp;&amp; options.opaque,
                priority: (options &amp;&amp; options.priority) || 0},
               function (overlay) { return overlay.priority; });
  this.state.modeGen++;
  regChange(this);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.multiplexingMode" id="apidoc.element.codemirror.runmode.multiplexingMode">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>multiplexingMode
        <span class="apidocSignatureSpan">(outer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">multiplexingMode = function (outer) {
  // Others should be {open, close, mode [, delimStyle] [, innerStyle]} objects
  var others = Array.prototype.slice.call(arguments, 1);

  function indexOf(string, pattern, from, returnEnd) {
    if (typeof pattern == "string") {
      var found = string.indexOf(pattern, from);
      return returnEnd &amp;&amp; found &gt; -1 ? found + pattern.length : found;
    }
    var m = pattern.exec(from ? string.slice(from) : string);
    return m ? m.index + from + (returnEnd ? m[0].length : 0) : -1;
  }

  return {
    startState: function() {
      return {
        outer: CodeMirror.startState(outer),
        innerActive: null,
        inner: null
      };
    },

    copyState: function(state) {
      return {
        outer: CodeMirror.copyState(outer, state.outer),
        innerActive: state.innerActive,
        inner: state.innerActive &amp;&amp; CodeMirror.copyState(state.innerActive.mode, state.inner)
      };
    },

    token: function(stream, state) {
      if (!state.innerActive) {
        var cutOff = Infinity, oldContent = stream.string;
        for (var i = 0; i &lt; others.length; ++i) {
          var other = others[i];
          var found = indexOf(oldContent, other.open, stream.pos);
          if (found == stream.pos) {
            if (!other.parseDelimiters) stream.match(other.open);
            state.innerActive = other;
            state.inner = CodeMirror.startState(other.mode, outer.indent ? outer.indent(state.outer, "") : 0);
            return other.delimStyle &amp;&amp; (other.delimStyle + " " + other.delimStyle + "-open");
          } else if (found != -1 &amp;&amp; found &lt; cutOff) {
            cutOff = found;
          }
        }
        if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);
        var outerToken = outer.token(stream, state.outer);
        if (cutOff != Infinity) stream.string = oldContent;
        return outerToken;
      } else {
        var curInner = state.innerActive, oldContent = stream.string;
        if (!curInner.close &amp;&amp; stream.sol()) {
          state.innerActive = state.inner = null;
          return this.token(stream, state);
        }
        var found = curInner.close ? indexOf(oldContent, curInner.close, stream.pos, curInner.parseDelimiters) : -1;
        if (found == stream.pos &amp;&amp; !curInner.parseDelimiters) {
          stream.match(curInner.close);
          state.innerActive = state.inner = null;
          return curInner.delimStyle &amp;&amp; (curInner.delimStyle + " " + curInner.delimStyle + "-close");
        }
        if (found &gt; -1) stream.string = oldContent.slice(0, found);
        var innerToken = curInner.mode.token(stream, state.inner);
        if (found &gt; -1) stream.string = oldContent;

        if (found == stream.pos &amp;&amp; curInner.parseDelimiters)
          state.innerActive = state.inner = null;

        if (curInner.innerStyle) {
          if (innerToken) innerToken = innerToken + " " + curInner.innerStyle;
          else innerToken = curInner.innerStyle;
        }

        return innerToken;
      }
    },

    indent: function(state, textAfter) {
      var mode = state.innerActive ? state.innerActive.mode : outer;
      if (!mode.indent) return CodeMirror.Pass;
      return mode.indent(state.innerActive ? state.inner : state.outer, textAfter);
    },

    blankLine: function(state) {
      var mode = state.innerActive ? state.innerActive.mode : outer;
      if (mode.blankLine) {
        mode.blankLine(state.innerActive ? state.inner : state.outer);
      }
      if (!state.innerActive) {
        for (var i = 0; i &lt; others.length; ++i) {
          var other = others[i];
          if (other.open === "\n") {
            state.innerActive = other;
            state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, "") : 0);
          }
        }
      } else if (state.innerActive.close === "\n") {
        state.innerActive = state.inner = null;
      }
    },

    electricChars: outer.electricChars,

    innerMode: function(state) {
      return state.inner ? {state: state.inner, mode: state.innerActive.mode} : {state: sta ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.newFoldFunction" id="apidoc.element.codemirror.runmode.newFoldFunction">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>newFoldFunction
        <span class="apidocSignatureSpan">(rangeFinder, widget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newFoldFunction = function (rangeFinder, widget) {
  return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.overlayMode" id="apidoc.element.codemirror.runmode.overlayMode">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>overlayMode
        <span class="apidocSignatureSpan">(base, overlay, combine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">overlayMode = function (base, overlay, combine) {
  return {
    startState: function() {
      return {
        base: CodeMirror.startState(base),
        overlay: CodeMirror.startState(overlay),
        basePos: 0, baseCur: null,
        overlayPos: 0, overlayCur: null,
        streamSeen: null
      };
    },
    copyState: function(state) {
      return {
        base: CodeMirror.copyState(base, state.base),
        overlay: CodeMirror.copyState(overlay, state.overlay),
        basePos: state.basePos, baseCur: null,
        overlayPos: state.overlayPos, overlayCur: null
      };
    },

    token: function(stream, state) {
      if (stream != state.streamSeen ||
          Math.min(state.basePos, state.overlayPos) &lt; stream.start) {
        state.streamSeen = stream;
        state.basePos = state.overlayPos = stream.start;
      }

      if (stream.start == state.basePos) {
        state.baseCur = base.token(stream, state.base);
        state.basePos = stream.pos;
      }
      if (stream.start == state.overlayPos) {
        stream.pos = stream.start;
        state.overlayCur = overlay.token(stream, state.overlay);
        state.overlayPos = stream.pos;
      }
      stream.pos = Math.min(state.basePos, state.overlayPos);

      // state.overlay.combineTokens always takes precedence over combine,
      // unless set to null
      if (state.overlayCur == null) return state.baseCur;
      else if (state.baseCur != null &amp;&amp;
               state.overlay.combineTokens ||
               combine &amp;&amp; state.overlay.combineTokens == null)
        return state.baseCur + " " + state.overlayCur;
      else return state.overlayCur;
    },

    indent: base.indent &amp;&amp; function(state, textAfter) {
      return base.indent(state.base, textAfter);
    },
    electricChars: base.electricChars,

    innerMode: function(state) { return {state: state.base, mode: base}; },

    blankLine: function(state) {
      var baseToken, overlayToken;
      if (base.blankLine) baseToken = base.blankLine(state.base);
      if (overlay.blankLine) overlayToken = overlay.blankLine(state.overlay);

      return overlayToken == null ?
        baseToken :
        (combine &amp;&amp; baseToken != null ? baseToken + " " + overlayToken : overlayToken);
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.registerGlobalHelper" id="apidoc.element.codemirror.runmode.registerGlobalHelper">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>registerGlobalHelper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function min() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else if (typeof define == "function" &amp;&amp; define.amd) // AMD
  define(["../../lib/codemirror"], mod);
else // Plain browser env
  mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.<span class="apidocCodeKeywordSpan">registerGlobalHelper</span>("fold", "comment", function(mode) {
return mode.blockCommentStart &amp;&amp; mode.blockCommentEnd;
}, function(cm, start) {
var mode = cm.getModeAt(start), startToken = mode.blockCommentStart, endToken = mode.blockCommentEnd;
if (!startToken || !endToken) return;
var line = start.line, lineText = cm.getLine(line);

var startCh;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.registerHelper" id="apidoc.element.codemirror.runmode.registerHelper">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>registerHelper
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function min() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  eventMixin(CodeMirror);

  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.<span class="apidocCodeKeywordSpan">registerHelper</span>(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };
};

// Used for horizontal relative motion. Dir is -1 or 1 (left or
// right), unit can be "char", "column" (like char, but doesn't
// cross line boundaries), "word" (across next word), or "group" (to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.requireMode" id="apidoc.element.codemirror.runmode.requireMode">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>requireMode
        <span class="apidocSignatureSpan">(mode, cont)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">requireMode = function (mode, cont) {
  if (typeof mode != "string") mode = mode.name;
  if (CodeMirror.modes.hasOwnProperty(mode)) return ensureDeps(mode, cont);
  if (loading.hasOwnProperty(mode)) return loading[mode].push(cont);

  var file = CodeMirror.modeURL.replace(/%N/g, mode);
  if (env == "plain") {
    var script = document.createElement("script");
    script.src = file;
    var others = document.getElementsByTagName("script")[0];
    var list = loading[mode] = [cont];
    CodeMirror.on(script, "load", function() {
      ensureDeps(mode, function() {
        for (var i = 0; i &lt; list.length; ++i) list[i]();
      });
    });
    others.parentNode.insertBefore(script, others);
  } else if (env == "cjs") {
    require(file);
    cont();
  } else if (env == "amd") {
    requirejs([file], cont);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.resolveMode" id="apidoc.element.codemirror.runmode.resolveMode">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>resolveMode
        <span class="apidocSignatureSpan">(spec)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolveMode = function (spec) {
  if (typeof spec == "string" &amp;&amp; mimeModes.hasOwnProperty(spec)) {
    spec = mimeModes[spec];
  } else if (spec &amp;&amp; typeof spec.name == "string" &amp;&amp; mimeModes.hasOwnProperty(spec.name)) {
    spec = mimeModes[spec.name];
  }
  if (typeof spec == "string") return {name: spec};
  else return spec || {name: "null"};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          to: CodeMirror.Pos(cur.line, token.end)};

var start = token.start, end = cur.ch, word = token.string.slice(0, end - start);
if (/[^\w$_-]/.test(word)) {
  word = ""; start = end = cur.ch;
}

var spec = CodeMirror.<span class="apidocCodeKeywordSpan">resolveMode</span>("text/css");

var result = [];
function add(keywords) {
  for (var name in keywords)
    if (!word || name.lastIndexOf(word, 0) == 0)
      result.push(name);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.runMode" id="apidoc.element.codemirror.runmode.runMode">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>runMode
        <span class="apidocSignatureSpan">(string, modespec, callback, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">runMode = function (string, modespec, callback, options) {
  var mode = exports.getMode({indentUnit: 2}, modespec);
  var lines = splitLines(string), state = (options &amp;&amp; options.state) || exports.startState(mode);
  for (var i = 0, e = lines.length; i &lt; e; ++i) {
    if (i) callback("\n");
    var stream = new exports.StringStream(lines[i]);
    if (!stream.string &amp;&amp; mode.blankLine) mode.blankLine(state);
    while (!stream.eol()) {
      var style = mode.token(stream, state);
      callback(stream.current(), style, i, stream.start, state);
      stream.start = stream.pos;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.scanForClosingTag" id="apidoc.element.codemirror.runmode.scanForClosingTag">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>scanForClosingTag
        <span class="apidocSignatureSpan">(cm, pos, name, end)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scanForClosingTag = function (cm, pos, name, end) {
  var iter = new Iter(cm, pos.line, pos.ch, end ? {from: 0, to: end} : null);
  return findMatchingClose(iter, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// If xml-fold is loaded, we use its functionality to try and verify
// whether a given tag is actually unclosed.
function closingTagExists(cm, tagName, pos, state, newTag) {
  if (!CodeMirror.scanForClosingTag) return false;
  var end = Math.min(cm.lastLine() + 1, pos.line + 500);
  var nextClose = CodeMirror.<span class="apidocCodeKeywordSpan">scanForClosingTag</span>(cm, pos, null, end);
  if (!nextClose || nextClose.tag != tagName) return false;
  var cx = state.context;
  // If the immediate wrapping context contains onCx instances of
  // the same tag, a closing tag only exists if there are at least
  // that many closing tags of that type following.
  for (var onCx = newTag ? 1 : 0; cx &amp;&amp; cx.tagName == tagName; cx = cx.prev) ++onCx;
  pos = nextClose.to;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.showHint" id="apidoc.element.codemirror.runmode.showHint">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>showHint
        <span class="apidocSignatureSpan">(cm, getHints, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">showHint = function (cm, getHints, options) {
  if (!getHints) return cm.showHint(options);
  if (options &amp;&amp; options.async) getHints.async = true;
  var newOpts = {hint: getHints};
  if (options) for (var prop in options) newOpts[prop] = options[prop];
  return cm.showHint(newOpts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var HINT_ELEMENT_CLASS        = "CodeMirror-hint";
var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

// This is the old interface, kept around for now to stay
// backwards-compatible.
CodeMirror.showHint = function(cm, getHints, options) {
  if (!getHints) return cm.<span class="apidocCodeKeywordSpan">showHint</span>(options);
  if (options &amp;&amp; options.async) getHints.async = true;
  var newOpts = {hint: getHints};
  if (options) for (var prop in options) newOpts[prop] = options[prop];
  return cm.showHint(newOpts);
};

CodeMirror.defineExtension("showHint", function(options) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.simpleMode" id="apidoc.element.codemirror.runmode.simpleMode">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>simpleMode
        <span class="apidocSignatureSpan">(config, states)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">simpleMode = function (config, states) {
  ensureState(states, "start");
  var states_ = {}, meta = states.meta || {}, hasIndentation = false;
  for (var state in states) if (state != meta &amp;&amp; states.hasOwnProperty(state)) {
    var list = states_[state] = [], orig = states[state];
    for (var i = 0; i &lt; orig.length; i++) {
      var data = orig[i];
      list.push(new Rule(data, states));
      if (data.indent || data.dedent) hasIndentation = true;
    }
  }
  var mode = {
    startState: function() {
      return {state: "start", pending: null,
              local: null, localState: null,
              indent: hasIndentation ? [] : null};
    },
    copyState: function(state) {
      var s = {state: state.state, pending: state.pending,
               local: state.local, localState: null,
               indent: state.indent &amp;&amp; state.indent.slice(0)};
      if (state.localState)
        s.localState = CodeMirror.copyState(state.local.mode, state.localState);
      if (state.stack)
        s.stack = state.stack.slice(0);
      for (var pers = state.persistentStates; pers; pers = pers.next)
        s.persistentStates = {mode: pers.mode,
                              spec: pers.spec,
                              state: pers.state == state.localState ? s.localState : CodeMirror.copyState(pers.mode, pers.state),
                              next: s.persistentStates};
      return s;
    },
    token: tokenFunction(states_, config),
    innerMode: function(state) { return state.local &amp;&amp; {mode: state.local.mode, state: state.localState}; },
    indent: indentFunction(states_, meta)
  };
  if (meta) for (var prop in meta) if (meta.hasOwnProperty(prop))
    mode[prop] = meta[prop];
  return mode;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.codemirror.runmode.startState" id="apidoc.element.codemirror.runmode.startState">
        function <span class="apidocSignatureSpan">codemirror.runmode.</span>startState
        <span class="apidocSignatureSpan">(mode, a1, a2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startState = function (mode, a1, a2) {
  return mode.startState ? mode.startState(a1, a2) : true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    state = info.state;
    mode = info.mode;
  }
  return info || {mode: mode, state: state}
}

function startState(mode, a1, a2) {
  return mode.startState ? mode.<span class="apidocCodeKeywordSpan">startState</span>(a1, a2) : true
}

// STRING STREAM

// Fed to the mode parsers, provides helper functions to make
// parsers more succinct.
...</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.codemirror.worker" id="apidoc.module.codemirror.worker">module codemirror.worker</a></h1>


    <h2>
        <a href="#apidoc.element.codemirror.worker.onmessage" id="apidoc.element.codemirror.worker.onmessage">
        function <span class="apidocSignatureSpan">codemirror.worker.</span>onmessage
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onmessage = function (e) {
  var data = e.data;
  switch (data.type) {
  case "init": return startServer(data.defs, data.plugins, data.scripts);
  case "add": return server.addFile(data.name, data.text);
  case "del": return server.delFile(data.name);
  case "req": return server.request(data.body, function(err, reqData) {
    postMessage({id: data.id, body: reqData, err: err &amp;&amp; String(err)});
  });
  case "getFile":
    var c = pending[data.id];
    delete pending[data.id];
    return c(data.err, data.text);
  default: throw new Error("Unknown message type: " + data.type);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>